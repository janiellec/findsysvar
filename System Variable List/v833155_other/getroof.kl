--    This material is the property of Fanuc Robotics America  
--    and must be  eturned to Fanuc Robotics America  
--    immediately upon request.  This  material
--    and the information illustrated or contained herein may not be
--    reproduced, copied, used, or transmitted in whole or in part in any way
--    without the prior written consent of Fanuc Robotics America  
--    
--             All Rights Reserved
--             Copyright (C)   1999, 2000
--             Fanuc Robotics America  
--    
--             Karel is a registered trademark of
--             Fanuc Robotics America  
--    +
--    Program:  GETROOF
--    
--    Description:
--     
--    Language: KAREL
--    
--    Source File:
-- 
--    Description - 
--
--    SYNTAX:
--    CALL GETROOF(VP,Cam View Num)
--
--      VP : Vision Process Name                   String
--      Cam View Num : Camera View Number          Integer
--
--    Author: David R. Friedeman 
--            Fanuc Robotics America
--    
--    Modification history:
--  04/27/18 FRIEDEMAN Created for GM G4.
--
--
------------------------------------------------------------------
PROGRAM GETROOF
------------------------------------------------------------------
%ALPHABETIZE
%COMMENT = 'GETROOF V833/03'
%NOPAUSE = ERROR + COMMAND + TPENABLE
%NOLOCKGROUP 
%ENVIRONMENT PC
%ENVIRONMENT REGOPE
%ENVIRONMENT IOBLT
%ENVIRONMENT CVIS
%ENVIRONMENT SYSDEF
%SYSTEM
%NOBUSYLAMP
%RWACCESS

%INCLUDE kliotyps
%INCLUDE gmpntcon
%INCLUDE etdccust

VAR
%INCLUDE gmpntvar
  status       : INTEGER
  data_type    : INTEGER
  int_value    : INTEGER
  real_value   : REAL
  string_value : STRING[16]
  vis_proc_nam : STRING[16]
  offst_pr_num : INTEGER
  vis_rqst_num : INTEGER
  vis_stat     : INTEGER
  dummy_int    : INTEGER
  dummy_bool   : BOOLEAN
  dummy_real   : REAL
  vis_timer    : INTEGER
  vis_done     : BOOLEAN

  index        : INTEGER
  string_size  : INTEGER
  dat_buffer   : ARRAY[MAX_BUFFER] OF BYTE

  autoskip_enb : INTEGER
  disbl_offst  : BOOLEAN

  cam_view_num : INTEGER
  vis_reg_num  : INTEGER
  find_status  : INTEGER -- Status of "FIND" operation
  get_status   : INTEGER -- Status of "GET" operation

  vp_name_str  IN CMOS FROM V500_VAR : STRING[16]
  vp_status    IN CMOS FROM V500_VAR : INTEGER
  vp_pr_index  IN CMOS FROM V500_VAR : INTEGER

  offset_xyz   : XYZWPR

ROUTINE check_port( p_io_type, p_index : INTEGER): BOOLEAN FROM pntutils

---------------------------------------------------------------------------
BEGIN
--
--  Send Data(p1,p2,p3,....pMAX_PARAMS)
--
-- initialize the data types
---------------------------------------------------------------------------

  FOR index = 1 TO MAX_BUFFER DO
    dat_buffer[index] = 0
  ENDFOR

  vis_proc_nam = ''
  offst_pr_num = 0
  status       = 0

  -- Get the parameters passed by the calling program
  -- The first parameter is the vision process name
  GET_TPE_PRM(1, data_type, int_value, real_value, vis_proc_nam, status)
  IF vis_proc_nam = '' THEN -- First parameter not a string
    POST_ERR(ER3DLPARAM1,'',0,ER_ABORT) -- Vision Process Name Parameter Bad
    DELAY 200 -- Give time to abort
  ENDIF

  -- The second parameter is the index for the positional data (PR[X])
  GET_TPE_PRM(2, data_type, offst_pr_num, real_value, string_value, status)

  IF (offst_pr_num <> 1) AND (offst_pr_num <> 2) AND
     (offst_pr_num <> 3) THEN -- 2nd param not a PR index
    POST_ERR(ER3DLPARAM2,'',0,ER_ABORT) -- iRV Multi-Find Index Invalid
    DELAY 200 -- Give time to abort
  ENDIF

  IF (offst_pr_num = 1) THEN
    offst_pr_num = VIS_SNP1_REG
  ELSE
    IF (offst_pr_num = 2) THEN
      offst_pr_num = VIS_SNP2_REG
    ELSE -- We didn't abort on previous check, so must be Find #3...
      offst_pr_num = VIS_SNP3_REG
    ENDIF
  ENDIF

  disbl_offst = FALSE

  IF check_port(di_ghost_t,di_ghost_i) THEN  
    IF (DIN[di_ghost_i] = TRUE) THEN      
      disbl_offst = TRUE				    
      vis_stat = VIS_SUCCESS
      -- Set the flag for the TP program - Without this the software might
      -- retry vision repeatedly because the status is bad.
      SET_INT_REG(VIS_PROC_OK,1,status)
      offset_xyz = $MOR_GRP[1].$NILPOS
      -- Ghost mode, so save (0,0,0,0,0,0) in the offset register.
      set_pos_reg(offst_pr_num,offset_xyz, status)
    ENDIF
  ENDIF					    

  -- Skip vision operations if we're in ghost mode.
  IF (disbl_offst = FALSE) THEN

    -- If this is the first snap, let's assume that the vision is okay
    IF (offst_pr_num = VIS_SNP1_REG) THEN
      SET_INT_REG(VIS_PROC_OK,1,status) -- Set the flag for the TP program
    ENDIF

    REPEAT
      vis_rqst_num = 0
      vis_timer    = 0
      vis_done     = FALSE
      cam_view_num = 0  -- Camera '0' is really Camera 1
      vis_reg_num  = 1  -- Always stuff value into VR[1].
      vis_stat = VIS_PENDING

      CONNECT TIMER TO vis_timer
      REPEAT -- Automatically try vision a couple of times
        vis_stat = VIS_PENDING
        vis_rqst_num = vis_rqst_num + 1
        SET_INT_REG(VIS_STAT_REG,V3DL_PENDING,status)

        -- Snap the picture
        v_run_find(vis_proc_nam, cam_view_num, find_status)

        DELAY 20

        -- Get the offset
        v_get_offset(vis_proc_nam, vis_reg_num, get_status)

        IF (visn_debug = TRUE) THEN
          write(cr,vis_proc_nam,' v_run_find stat = ', find_status)
          write(cr,vis_proc_nam,' v_get_offset stat = ', get_status)
        ENDIF

        -- '0' returned from vision calls means success.  Nonzero = error.
        IF (find_status = 0) AND (get_status = 0) THEN
          vis_stat = VIS_SUCCESS
        ENDIF

      UNTIL (vis_stat = VIS_SUCCESS) OR (vis_rqst_num >= MAX_AUTO_TRY) OR
            (vis_timer> 15000)  -- Don't wait for timeout 5x
      IF (vis_stat = VIS_SUCCESS) THEN
        vis_done = TRUE
        -- Write the offset value to a PR.

        -- Don't set this now... It might overwrite FINDBODY data.
--        vreg_offset(vis_reg_num,VIS_CUR_OFST, status)  -- Current offset reg
        vreg_offset(vis_reg_num,offst_pr_num, status)  -- Save for setframe
        IF (status <> 0) THEN
          write(cr,'Failed to read vision register ',vis_reg_num)
        ENDIF

      ELSE
        IF (vis_timer > 15000) THEN
          -- Post timeout
          POST_ERR(ER3DLTIMEOUT,'',0,ER_PAUSE) -- Vision Request Time Out
          DELAY 250
        ELSE
          -- Too many retries - Post 'Not Found'
          -- If this error occurred on the second (or third) vision find, then
          -- we must re-find the entire vehicle body part.  This assumes that
          -- an operator will move the vehicle to get the vision to work, and
          -- if SOME of the vehicle has already been successfully found, the
          -- a bad offset will be computed.  The TP program will automatically
          -- re-start the find process if R[VIS_PROC_OK] = 0.
          IF (offst_pr_num = VIS_SNP2_REG) OR (offst_pr_num = VIS_SNP3_REG) THEN
            SET_INT_REG(VIS_PROC_OK,0,status) -- Set the flag for the TP program          
            vis_done = TRUE -- Skip out so that the TP program can retry
          ENDIF
          POST_ERR(ER3DLNOFOUND,'',0,ER_PAUSE) -- Vision Target Not Found
          DELAY 250
        ENDIF
      ENDIF

    UNTIL (vis_done = TRUE)

  ELSE -- We're in Ghost mode - Tell the TP program it's okay to continue.

    SET_INT_REG(VIS_PROC_OK,1,status) -- Set the flag for the TP program

  ENDIF 

  IF (offst_pr_num > VIS_SNP1_REG) THEN -- Save the VP data
    vp_name_str  = vis_proc_nam
    vp_status    = vis_stat
  ENDIF

END GETROOF
