-- -----------------------------------------------------------------------
--
--   MODULE: MDFYSTUP.kl
--   TITLE:  Modify the fixture group
--
--
--   WRITTEN BY:     Randy Kosaski
--   REVISION DATE:  02/18/2013
--
--   LANGUAGE:       KAREL 8.10
--   CONTROL GROUP:  AUTOMATED SYSTEMS GROUP
--
--   ORDER NUMBER:   None Standard
--   PROJECT NAME:
--
--
--   COPYRIGHT:     Fanuc Robotics America, Inc. retains rights in any
--                  and all Software contained in the material attached
--                  hereto and said Software may not be copied
--                  reproduced without the written permission Fanuc
--                  Robotics America, Inc..
--
--                  All Software, (C) Copyright Fanuc Robotics
--                  America, Inc., 2005
--
--         DESCRIPTION: This program controls the screens for setting up
--                      the fixture grouping.  There are two screens
--                      one for the insert data, one for inspection
--
--         HISTORY OF CHANGES:
--
--         REVISION   DATE       BY               COMMENTS
--         --------   ---------  -------------  --------------------
--
--------------------------------------------------------------------------
PROGRAM MDFYSTUP

%SYSTEM
--%INVISIBLE
                --*****************************************************************
--%NOABORT = ERROR + COMMAND-- *** REMOVE COMMENT FOR PRODUCTION NEED TO IGNORE ABORT
                --*****************************************************************
%NOPAUSE = ERROR + COMMAND + TPENABLE
%NOBUSYLAMP
%NOLOCKGROUP
%PRIORITY=100
%NOPAUSESHFT
%ALPHABETIZE
%COMMENT = 'Modify Stup Menu'

%ENVIRONMENT REGOPE --required for register builtins
%ENVIRONMENT iosetup --required for the SET_PORT builtins
%ENVIRONMENT sysdef --required for the System Variables
%ENVIRONMENT TIM  --required for the time builtins
%ENVIRONMENT multi --required for multi-process control (e.g. run_task)?
%ENVIRONMENT TPE --required for the set_attr tp program header
%ENVIRONMENT uif --variables like x_workt

--%INCLUDE KLEVCCDF  -- needed for the TP Error window
%INCLUDE klevksp  -- TPMM KAREL softpart loader. and the device_stat and tpdc_tp_c
%INCLUDE klevkmsk
%INCLUDE kliosop
--%INCLUDE KLIOTYPS -- used for i/o constants

 CONST

  dly_time    = 4500    --time to keep messages up for
  dict_name   = 'MDFY'  --dictionary name for  data
  max_col_wid = 16      --max column width in schedule
  update_only = 4
  ver = '04/10/16'      -- REV. C edited at Valiant

TYPE

   history_data FROM MDFYSTUP = STRUCTURE
     history_name: STRING[28] -- the name of the program matches dictionary size
     Masteredint : INTEGER -- the master data history
     Modifiedint : INTEGER -- the Modified history
     Masteredstr : STRING[16] -- the Modified history
     Modifiedstr : STRING[16] -- the Mastered history
   ENDSTRUCTURE

   prog_data  FROM  MDFYSTUP = STRUCTURE
     program_name  : STRING[28] -- the name of the program matches dictionary size
     program_cmnt  : STRING[16] -- the comment from the program
     MasteredTime : INTEGER    -- the timestamp when the modified program found
     ModFndTime   : INTEGER    -- the timestamp when the modified program found
     LstmastrInt  : INTEGER    -- the last mastered integer from the read of builtin
     CurmodInt    : INTEGER    -- the last read integer from the read of builtin
     LastMastered : STRING[16] -- the last time mastered (when told to master)
     LastModified : STRING[16] -- Current modified date
     MasterTimStr : STRING[20] -- time and date when mastered date
     Modified_do  : INTEGER    -- THis is the output to turn ON if program has been modified
     historicdata : ARRAY[10] OF history_data -- track the historical data
     mod_found    : BOOLEAN -- this used for finding the modification was caught
     enable_montr : BOOLEAN
   ENDSTRUCTURE

VAR

MasterProgs IN CMOS FROM MDFYSTUP :ARRAY[32] OF prog_data

 -- structure data must be in this program for the ACT_FORM or UNKNOWN variable error occurs
 -- i.e. if FROM progname is used 5/5/03
unlocked,
loaded, -- used for the return from builtin PROG_STATUS if TRUE program is loaded
initialized,-- used for the return from builtin PROG_STATUS if TRUE variable file is loaded
same_io,  -- Used when two schedules have the same output
Detail_done: BOOLEAN -- used to see if the detail is available
i,
entry,
int_value,
term_mask,
term_char,
open_id    : INTEGER -- Used for routine in getting teach pendant positions

-- bleow is used for builtins
rack_no,
slot_no,
phy_PortType,
phy_port_no,
n_ports : INTEGER

-- Below used for the mastering procedure of the schedule driven by teh PLC in CHK_MDFY
MasterFltRst,                  -- Used for DIN to Indicate the PLC has acknowledged the Master Fault and reset the outputs
MasterReqFlt,                  -- Used for DOUT to indicate Mastering FAULT occured and could not be completed
Master_Cmplt,                  -- Used for DOUT to indicate the Mastering was completed succesfully
InitMaster,                    -- Used for DIN number to initiate a master of the current schedule# Master_Req
MastrFltCode,                  -- Used for the GOUT to PLC indicating a code to PLC WHY could not master
Master_Cnfrm,                  -- Used for the GOUT to PLC confirming the GIN sent on Master_Req
Master_Req   IN CMOS : INTEGER -- Used for GIN the PLC will send for requesting Mastering of Schedule#
CommentNum   IN CMOS : ARRAY[7] OF STRING[26] -- used for the comment of the above DI/DO

MastrConFigd IN CMOS : BOOLEAN -- Used for indicating the mastering data is configured

karel_name IN CMOS : STRING[16] -- Used for name of the fixture group variable will be read from
karel_var  IN CMOS : STRING[80] -- Used for variable name to get vars from the karel_name program
status     IN CMOS :INTEGER -- Status of built-in procedure call nice to see if power cycled because of issue can see cmos
form_status IN CMOS :INTEGER -- Status of form built-in call nice to see if power cycled because of issue can see cmos
mod_time : INTEGER -- Used for

strtMstrNum IN CMOS :INTEGER -- used for the start point for configuring the Group input for Mastering input
strtEchoNum IN CMOS :INTEGER -- used for the start point for configuring the Group Output for Mastering Echo output
strtFltNum  IN CMOS :INTEGER -- used for the start pont for configuring the Group Output for Mastering Fault output

ModArryNum     :INTEGER
form_number IN CMOS : INTEGER -- Used for which form to display 1= Insert,2= Inspect, 3 ???
value_array: ARRAY [20] OF STRING [120]
inact_array: ARRAY [20] OF BOOLEAN
change_array: ARRAY[20] OF BOOLEAN
def_item: INTEGER
Var_name  : STRING[128] -- Used for
Det_num_name  : STRING[60] -- Used for
Nest_name  : STRING[60] -- Used for
detail_num :INTEGER
string_value : STRING[128]

Not_mastered,
Prg_Comment,
DO_Comment : STRING[26]
LockMstrProg,    -- used for locking the master programs when they are mastered DEFAULT=TRUE
det_done IN CMOS : BOOLEAN -- Used for

all_done:          BOOLEAN             --user wants to exit laser schedules
prmp_file:         FILE                --prompt window on tp
do_detail:         BOOLEAN             --go to detail page on next loop
version_id    IN CMOS : STRING [15]
-- The following var are for the form routine and user interface
  tbl_vptr:          ARRAY[10, 2] OF INTEGER   --         |
  tbl_data:          XWORK_T                              --         |
  attach_wind:        BOOLEAN                              --         |
  tbl_def_item:      INTEGER                              --         |
  tbl_ina_arry:      ARRAY[2] OF BOOLEAN            -- 2 colunms         |
  tbl_val_arry:      ARRAY[2] OF STRING[120]--         |
  tbl_chg_arry:      ARRAY[10, 2] OF BOOLEAN   -- 10 rows 2 columns table manager vars
  col_data:          ARRAY[2] OF COL_DESC_T         -- two cloumns        |
  tbl_term_chr:      INTEGER                              --         |
  tbl_status:        INTEGER
  num_columns,
  num_rows  : INTEGER

Mastered :ARRAY[10] OF STRING[20] -- used for the table variables
Modified :ARRAY[10] OF STRING[20] -- used for the table variables

%INCLUDE KLEVCCDF  -- provides character definition
%INCLUDE KLIOTYPS
%INCLUDE FXMDFYEG
%INCLUDE klrdutil
%INCLUDE klrdread
-----------------------------------------------------------
ROUTINE int_2_str(p_integer:INTEGER):STRING
-- Routine to convert integers to string variables
-----------------------------------------------------------
VAR
  l_string: STRING[4]
BEGIN
  l_string = ''
  CNV_INT_STR(p_integer, 0, 0, l_string)
  RETURN(SUB_STR(l_string, 2, STR_LEN(l_string)))
END int_2_str
------------------------------------------------------------------------------
-- ROUTINE Trim
-- Remove leading and trailing spaces
-------------------------------------------------------------------------------
ROUTINE Trim (strText : STRING) : STRING

VAR
  strChar      : STRING[1]
  strTemp      : STRING[128]
  intFront     : INTEGER
  intBack      : INTEGER
  intIndex     : INTEGER
  intLength    : INTEGER

BEGIN

  strChar = ''
  strTemp = ''

IF UNINIT(strText) THEN
  strText = 'UNINT'
  POST_ERR(38000, 'String Not Initialized??', 0, 0) --
ENDIF


  intLength = STR_LEN(strText)

  IF intLength = 0 THEN RETURN(strText) ; ENDIF

  intIndex = 1
  intFront = intIndex

  --find the front of the string
  strChar = SUB_STR(strText, intIndex, 1)
  WHILE strChar = ' ' DO
    intIndex = IntIndex + 1
    IF intIndex <= intLength THEN
      strChar = SUB_STR(strText, intIndex, 1)
      intFront = intIndex
    ELSE
      strChar = ''
    ENDIF

  ENDWHILE

  intIndex = STR_LEN(strText)
  intBack = intIndex

  --find the back of the string
  strChar = SUB_STR(strText, intIndex, 1)
  WHILE strChar = ' ' DO
    intIndex = IntIndex - 1
    IF intIndex >= 1 THEN
      strChar = SUB_STR(strText, intIndex, 1)
      intBack = intIndex
    ELSE
      strChar = ''
    ENDIF
  ENDWHILE

  -- using SUB_STR to extract the string between front and back doesn't work - so we do it the hard way
  FOR intIndex=intFront TO intBack DO
    strChar = SUB_STR(strText, intIndex, 1)
    strTemp = strTemp + strChar
  ENDFOR

  RETURN(strTemp)

END Trim
-------------------------------------------------------------------------------
-- ROUTINE Int2Str
-- Converts integer number to string.
-------------------------------------------------------------------------------
ROUTINE Int2Str (intVal : INTEGER) : STRING

VAR
  strOut : STRING[15]

BEGIN

  CNV_INT_STR(intVal, 15, 0, strOut)
  strOut = Trim(strOut)

  RETURN (strOut)

END Int2Str
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
ROUTINE initvars
-- PURPOSE:
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------

BEGIN

IF UNINIT(strtMstrNum) THEN -- the Master Acknowledge start point
  strtMstrNum = 313
ENDIF
IF UNINIT(strtEchoNum) THEN -- the Echo Acknowledge start point
  strtEchoNum = 281
ENDIF
IF UNINIT(strtFltNum) THEN  --  the start number for Fault codes
  strtFltNum = 321
ENDIF


END initvars
-----------------------------------------------------------------------------
ROUTINE get_num(strt_num:INTEGER)
-- PURPOSE: to get the user to enter a value
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------

BEGIN

  WRITE(CHR(137),CHR(128));
  FORCE_SPMENU(tp_panel, SPI_TPUSER, 1)
  -- Main Menu
  WRITE TPDISPLAY('******************************',cr)
  WRITE TPDISPLAY('  Please enter the Start Num. ',cr)
  WRITE TPDISPLAY('  for the Group Input used for',cr)
  WRITE TPDISPLAY('  Mastering. The current Value',cr)
  WRITE TPDISPLAY('  is ',strtMstrNum,' so this  ',cr)
  WRITE TPDISPLAY('  will be the starting point  ',cr)
  WRITE TPDISPLAY('  to config. Master Schedule# ',cr)
  WRITE TPDISPLAY('******************************',cr)
  REPEAT
    READ TPDISPLAY(strtMstrNum)
    IF (strtMstrNum <0) OR (strtMstrNum>($MAX_DIG_PRT)) THEN
     WRITE TPPROMPT('Value Must be between 1&',$MAX_DIG_PRT)
    ENDIF
  UNTIL (strtMstrNum>0) AND (strtMstrNum<($MAX_DIG_PRT))
  -- Test Menu Choice

  WRITE(CHR(137),CHR(128));
  WRITE TPPROMPT(CHR(128))


END get_num
-----------------------------------------------------------------------------
ROUTINE config_io
-- PURPOSE:
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
VAR
endpoint  : INTEGER -- Used for the end of the for loop

BEGIN

IF UNINIT(strtMstrNum) THEN -- the Master Acknowledge start point
  strtMstrNum = 313
ENDIF
IF UNINIT(strtEchoNum) THEN -- the Echo Acknowledge start point
  strtEchoNum = 281
ENDIF
IF UNINIT(strtFltNum) THEN  --  the start number for Fault codes
  strtFltNum = 321
ENDIF



-- Ask the start point for the Master GO number
  --  get_num(strtMstrNum)

  -- get the rack and port from the configured I/O numbers
  GET_PORT_ASG(io_din, 1, rack_no, slot_no, phy_PortType,phy_port_no, n_ports, status)
  IF status <>0 THEN
    POST_ERR(38000, 'Get port 1 Failed', status, 0) --
    POST_ERR(38000, 'Configuration I/O Failed', 0, 0) --
    RETURN
  ENDIF

  SET_PORT_CMT(io_gpin,Master_Req,'Master Schedule#',status)
    IF status <>0 THEN
      POST_ERR(38000, 'GI '+int2str(Master_Req)+' Comment Set Failed', status, 0) --
    ENDIF
--                                              Start point from Appendic C pg 125
-- set the rack and port based on the above GET_PORT_ASG builtin
  SET_PORT_ASG(io_gpin,Master_Req,rack_no,slot_no,io_din,strtMstrNum,8,status)
    IF status <>0 THEN
      POST_ERR(38000, 'GI '+int2str(Master_Req)+' Configure Set Failed', status, 0) --
    ENDIF
  endpoint = strtMstrNum + 7
  FOR i = strtMstrNum TO endpoint DO
    SET_PORT_CMT(io_din,i,'Used MstrPrg GI',status)
    IF status<>0 THEN
      POST_ERR(38000, 'DI '+int2str(i)+' Comment Set Failed', status, 0) --
    ENDIF
  ENDFOR --

--///////////////////////////////////
--    Group Outputs (GOUT's)
--///////////////////////////////////
  SET_PORT_CMT(io_gpout,Master_Cnfrm,'Mstr Sched Echo',status)
    IF status<>0 THEN
      POST_ERR(38000, 'GO '+int2str(Master_Cnfrm)+' Comment Set Failed', status, 0) --
    ENDIF

  SET_PORT_ASG(io_gpout,Master_Cnfrm,rack_no,slot_no,io_dout,strtEchoNum,8,status)
    IF status <>0 THEN
      POST_ERR(38000, 'GI '+int2str(Master_Cnfrm)+' Configure Set Failed', status, 0) --
    ENDIF
  endpoint = strtEchoNum + 7
  FOR i = strtEchoNum TO endpoint DO
    SET_PORT_CMT(io_dout,i,'Used MstrCfrm GO',status)
    IF status<>0 THEN
      POST_ERR(38000, 'DO '+int2str(i)+' Comment Set Failed', status, 0) --
    ENDIF
  ENDFOR --


  SET_PORT_CMT(io_gpout,MastrFltCode,'Mstr Fault Code',status)
    IF status<>0 THEN
      POST_ERR(38000, 'GO '+int2str(MastrFltCode)+' Comment Set Failed', status, 0) --
    ENDIF

--                                       Start point from Appendic C pg 127
  SET_PORT_ASG(io_gpout,MastrFltCode,rack_no,slot_no,io_dout,strtFltNum,4,status)
    IF status <>0 THEN
      POST_ERR(38000, 'GI '+int2str(MastrFltCode)+' Configure Set Failed', status, 0) --
    ENDIF
  endpoint = strtFltNum + 3
  FOR i = strtFltNum TO endpoint DO
    SET_PORT_CMT(io_dout,i,'Used MstrFlt GO',status)
    IF status<>0 THEN
      POST_ERR(38000, 'DO '+int2str(i)+' Comment Set Failed', status, 0) --
    ENDIF
  ENDFOR --

 SET_PORT_CMT(io_din,InitMaster,'Master Prog Rqst',status)
   IF status<>0 THEN
     POST_ERR(38000, 'DI '+int2str(Master_Req)+' Comment Set Failed', status, 0) --
   ENDIF
 SET_PORT_CMT(io_dout,Master_Cmplt,'Mstr Prog Complt',status)
   IF status<>0 THEN
     POST_ERR(38000, 'DO '+int2str(Master_Cmplt)+' Comment Set Failed', status, 0) --
   ENDIF
 SET_PORT_CMT(io_dout,MasterReqFlt,'Mstr Prog Fault',status)
   IF status<>0 THEN
     POST_ERR(38000, 'DO '+int2str(MasterReqFlt)+' Comment Set Failed', status, 0) --
   ENDIF

END config_io
-----------------------------------------------------------------------------
ROUTINE save_history(Schdl_num:INTEGER)
-- PURPOSE: Save history of changes and time that have been made
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
VAR

m,n:INTEGER

BEGIN
-- check initialization
  FOR i = 1 TO ARRAY_LEN(MasterProgs[Schdl_num].historicdata) DO
    IF UNINIT(MasterProgs[Schdl_num].historicdata[i].Masteredstr) THEN
      MasterProgs[Schdl_num].historicdata[i].Masteredstr = '   No Record'
    ENDIF
    IF UNINIT(MasterProgs[Schdl_num].historicdata[i].Modifiedstr) THEN
      MasterProgs[Schdl_num].historicdata[i].Modifiedstr = '   No Record'
    ENDIF
    IF UNINIT(MasterProgs[Schdl_num].historicdata[i].history_name) THEN
      MasterProgs[Schdl_num].historicdata[i].history_name = 'Unknown'
    ENDIF
  ENDFOR --

  FOR m = ARRAY_LEN(MasterProgs[Schdl_num].historicdata) DOWNTO 2 DO
    USING MasterProgs[Schdl_num].historicdata[m] DO --
      n = m - 1 -- need to save previous
      IF m > 0 THEN
        history_name = MasterProgs[Schdl_num].historicdata[n].history_name
        Masteredstr = MasterProgs[Schdl_num].historicdata[n].Masteredstr
        Modifiedstr = MasterProgs[Schdl_num].historicdata[n].Modifiedstr
      ENDIF
    ENDUSING --
  ENDFOR --

  RETURN
END save_history
-----------------------------------------------------------------------------
ROUTINE masterprog
-- PURPOSE: master the date for the current program
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------

BEGIN
IF UNINIT(LockMstrProg) THEN
  LockMstrProg = TRUE
ENDIF
   -- need to check if initialized
 IF UNINIT(MasterProgs[ModArryNum].program_name) THEN
   POST_ERR(38000, 'Program Modify '+int2str(ModArryNum)+' name not setup', 0, 0) --
   RETURN
 ELSE    -- check is loaded
   LOAD_STATUS(MasterProgs[ModArryNum].program_name,loaded, initialized)
    IF NOT loaded THEN -- its loaded, get the modified attribute
      POST_ERR(38000,MasterProgs[ModArryNum].program_name + ' is not loaded on Robot', 0, 0) --
      MasterProgs[ModArryNum].enable_montr = FALSE
      MasterProgs[ModArryNum].program_cmnt = 'File NOT Found'
      RETURN
    ENDIF

-- Need to check it is required
    IF UNINIT(MasterProgs[ModArryNum].CurmodInt) THEN -- needed if program CHK_MDFY program not running to update
     -- get the attribute and save as the last mastered so will be good on compare
      GET_ATTR_PRG(MasterProgs[ModArryNum].program_name, AT_MDFY_TIME, MasterProgs[ModArryNum].CurmodInt, string_value, status)
      IF status<> 0 THEN
        POST_ERR(38000, 'Failed to get '+ MasterProgs[ModArryNum].program_name +' Modified Time', status, 0) --
        Prg_Comment = ''
      ELSE -- set the modified date
        CNV_TIME_STR(MasterProgs[ModArryNum].CurmodInt,MasterProgs[ModArryNum].LastModified)
      ENDIF
    ENDIF

-- check if ever mastered
    IF NOT UNINIT(MasterProgs[ModArryNum].LstmastrInt) THEN
      IF (MasterProgs[ModArryNum].CurmodInt = MasterProgs[ModArryNum].LstmastrInt) THEN -- if last mod is <> Last Mastered
        WRITE TPERROR(CHR(cc_clear_win),MasterProgs[ModArryNum].program_name,' Mastering not required')
        RETURN
      ENDIF
    ELSE -- set it equal to original modifed date because it is 1st time mastered
      MasterProgs[ModArryNum].LstmastrInt = MasterProgs[ModArryNum].CurmodInt
    ENDIF

   -- save the Current Date for the history
   save_history(ModArryNum) -- pass schedule number to save history

   MasterProgs[ModArryNum].historicdata[1].history_name = MasterProgs[ModArryNum].program_name
   -- Convert to date
   IF NOT UNINIT(MasterProgs[ModArryNum].LstmastrInt) THEN
     IF (MasterProgs[ModArryNum].LstmastrInt>0) THEN -- zero,faults INTP-103 Program error,ROUT-035 Value out range
       CNV_TIME_STR(MasterProgs[ModArryNum].LstmastrInt,MasterProgs[ModArryNum].historicdata[1].Masteredstr)
     ENDIF
     MasterProgs[ModArryNum].historicdata[1].Masteredint = MasterProgs[ModArryNum].LstmastrInt
   ENDIF

   IF NOT UNINIT(MasterProgs[ModArryNum].CurmodInt) THEN
     IF (MasterProgs[ModArryNum].CurmodInt >0) THEN -- zero,faults INTP-103 Program error,ROUT-035 Value out range
       CNV_TIME_STR(MasterProgs[ModArryNum].CurmodInt,MasterProgs[ModArryNum].historicdata[1].Modifiedstr)
     ENDIF
     MasterProgs[ModArryNum].historicdata[1].Modifiedint = MasterProgs[ModArryNum].CurmodInt
   ENDIF

       -- get the attribute and save as the last mastered so will be good on compare
   GET_ATTR_PRG(MasterProgs[ModArryNum].program_name, AT_MDFY_TIME, MasterProgs[ModArryNum].LstmastrInt, string_value, status)
   IF status<> 0 THEN
     POST_ERR(38000, 'Failed to get '+ MasterProgs[ModArryNum].program_name +' Modified Time', status, 0) --
     Prg_Comment = ''
   ELSE -- set the modified date
     CNV_TIME_STR(MasterProgs[ModArryNum].LstmastrInt,MasterProgs[ModArryNum].LastMastered)
   ENDIF

   MasterProgs[ModArryNum].mod_found = FALSE -- reset the found variable
   -- save the mastered time stamp
   GET_TIME(MasterProgs[ModArryNum].MasteredTime)
   CNV_TIME_STR(MasterProgs[ModArryNum].MasteredTime,MasterProgs[ModArryNum].MasterTimStr)
   POST_ERR(38000,MasterProgs[ModArryNum].program_name+ ' Modified Mastering Reset', 0, 0) --

   IF LockMstrProg THEN -- set the write protect so program cannot be modified unless someone unprotects
    SET_ATTR_PRG(MasterProgs[ModArryNum].program_name, AT_PROTECT, 2, string_value, status)
      IF (status<>0) THEN
        POST_ERR(38000, MasterProgs[ModArryNum].program_name+' Set Write Protect ON failed', status, 0) --
      ENDIF
   ENDIF

 ENDIF

END masterprog
-----------------------------------------------------------------------------
ROUTINE ModifyTable
-- PURPOSE:
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------

BEGIN

IF UNINIT(ModArryNum) THEN
  ModArryNum = 1
ENDIF

IF UNINIT(attach_wind) THEN
  attach_wind = TRUE -- need this so it attaches to the window otherwise BLANK screen
ENDIF

num_rows = ARRAY_LEN(MasterProgs[ModArryNum].historicdata)
num_columns = 2 -- Mastered and modified

--Var_name = 'MasterProgs['+int2str(ModArryNum)+'].historicdata['+int2str(1)+'].'   -- Program name and Fixdata
FOR i = 1 TO ARRAY_LEN(MasterProgs[ModArryNum].historicdata) DO
  IF UNINIT(MasterProgs[ModArryNum].historicdata[i].MasteredStr) THEN
    MasterProgs[ModArryNum].historicdata[i].MasteredStr = '   No Record'
  ENDIF
  Mastered[i] = MasterProgs[ModArryNum].historicdata[i].MasteredStr
  IF UNINIT(MasterProgs[ModArryNum].historicdata[i].ModifiedStr) THEN
    MasterProgs[ModArryNum].historicdata[i].ModifiedStr = '   No Record'
  ENDIF
  Modified[i] = MasterProgs[ModArryNum].historicdata[i].ModifiedStr
ENDFOR --

   tbl_val_arry[1] = 'Mastered'
   tbl_val_arry[2] = 'Modified'

   col_data[1].item_type   = TPX_KST_ITEM   --Mastered column
   col_data[1].start_col   = 1
   col_data[1].field_width = 20
   col_data[1].format_spec = '%-20s'

   col_data[2].item_type   = TPX_KST_ITEM   --Modified column
   col_data[2].start_col   = 21
   col_data[2].field_width = 20
   col_data[2].format_spec = '%-20s'

  FOR i = 1 to ARRAY_LEN(MasterProgs[ModArryNum].historicdata) DO
    tbl_chg_arry[i,1] = FALSE
    tbl_chg_arry[i,2] = FALSE
  ENDFOR

    tbl_ina_arry[1] = TRUE --FALSE
    tbl_ina_arry[2] = TRUE --FALSE

term_mask =  kc_item_chng  + kc_f1_type + kc_func_key +ky_prev-- kc_f1_type + kc_func_key kc_other --
tbl_term_chr = -1

  TBL_DEF_ITEM = 1

        DISCTRL_TBL('mdfy', modify_hist, num_rows, num_columns, col_data, tbl_ina_arry,
tbl_chg_arry, tbl_def_item, tbl_term_chr, term_mask, tbl_val_arry, attach_wind, tbl_status)

    IF tbl_status <> 0 THEN
      POST_ERR(38000, 'Display Table failed', tbl_status, 0) --
    ENDIF

    form_number = 1

END ModifyTable
-----------------------------------------------------------------------------
ROUTINE chk_config(i_o_type,i_o_num:INTEGER):BOOLEAN
-- PURPOSE: to check if the i/o is configured in the I/O
--
--
-- INPUT:  input type, input number
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
VAR
a_ok : BOOLEAN
BEGIN
         -- if Input is set go get Comment
   GET_PORT_ASG(i_o_Type, i_o_num, rack_no, slot_no, phy_PortType,phy_port_no, n_ports, status)
     IF status<>0 THEN
       a_ok = FALSE
     ELSE
       a_ok = TRUE
     ENDIF

  RETURN(a_ok)

END chk_config
-----------------------------------------------------------------------------
ROUTINE verfiy_io
-- PURPOSE: to verify all I/O configured is ok to used
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY: setup_IOData routine
--
--
-----------------------------------------------------------------------------

BEGIN
-- if output is set go get Comment
   same_io = FALSE

   -- need to check duplicate I/O number
   FOR i = 1 TO ARRAY_LEN(MasterProgs) DO
     IF NOT UNINIT(MasterProgs[i].Modified_do) THEN
       IF (MasterProgs[i].Modified_do = Master_Cmplt) AND (Master_Cmplt >0) THEN
         POST_ERR(38000, 'DO '+ int2str(Master_Cmplt) + ' used in Array '+ int2str(i) + ' already', 0, 0) --
         DELAY 1000
         same_io = TRUE
         Master_Cmplt = 0
         CommentNum[5] = 'Select DO Number'
       ENDIF
     ENDIF
   ENDFOR --
      -- need to check duplicate I/O number
   FOR i = 1 TO ARRAY_LEN(MasterProgs) DO
     IF NOT UNINIT(MasterProgs[i].Modified_do) THEN
       IF (MasterProgs[i].Modified_do = MasterReqFlt) AND (MasterReqFlt >0) THEN
         POST_ERR(38000, 'DO '+ int2str(MasterReqFlt) + ' used in Array '+ int2str(i) + ' already', 0, 0) --
         DELAY 1000
         same_io = TRUE
         MasterReqFlt = 0
         CommentNum[6] = 'Select DO Number'
       ENDIF
     ENDIF
   ENDFOR --
       -- need to check duplicate I/O number
   --FOR i = 1 TO ARRAY_LEN($REFPOS1) DO
     --IF NOT UNINIT($REFPOS1[i].$DOUT_INDX) THEN
       --IF (($REFPOS1[i].$DOUT_INDX = MasterReqFlt) AND (MasterReqFlt >0)) THEN
         --POST_ERR(38000, 'DO '+ int2str(MasterReqFlt) + ' used in REFPOS#'+ int2str(i) + ' already', 0, 0) --
         --DELAY 3000
         --same_io = TRUE
         --MasterReqFlt = 0
         --CommentNum[6] = 'Select DO Number'
       --ENDIF
        --IF (($REFPOS1[i].$DOUT_INDX = Master_Cmplt) AND (Master_Cmplt >0)) THEN
         --POST_ERR(38000, 'DO '+ int2str(Master_Cmplt) + ' used in REFPOS#'+ int2str(i) + ' already', 0, 0) --
         --DELAY 3000
         --same_io = TRUE
         --Master_Cmplt = 0
         --CommentNum[5] = 'Select DO Number'
       --ENDIF
     --ENDIF
   --ENDFOR --

END verfiy_io
-----------------------------------------------------------------------------
ROUTINE comment_vars
-- PURPOSE: get the comment for the i/o selected
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
BEGIN

 IF UNINIT(Master_Req) THEN  -- if Input number is set, go get Comment
   CommentNum[1] = 'Select GI Number'
 ELSE
  IF (Master_Req >0) THEN  -- if Input number is set, go get Comment
    IF chk_config(io_gpin,Master_Req) THEN -- check if config is valid
      GET_PORT_CMT(io_gpin,Master_Req,CommentNum[1],Status)
        IF status<> 0 THEN
          IF Status = 13030 THEN -- is empty string returning PRIO-030 PRIO=13
            CommentNum[1] = 'GI ' +int2str(Master_req) +' Not Commented'
          ELSE
            POST_ERR(38000, 'Failed to get Master_Req comment', status, 0) --
            CommentNum[1] = 'Unknown'
          ENDIF
        ENDIF
    ELSE
      CommentNum[1] = 'GI['+int2str(Master_Req)+'] Needs Config'
    ENDIF
  ELSE
    CommentNum[1] = 'Select GI Number'
  ENDIF
 ENDIF

 IF UNINIT(InitMaster) THEN -- if Input number is set, go get Comment
   CommentNum[2] = 'Select DI Number'
 ELSE
  IF (InitMaster >9)THEN -- if Input number is set, go get Comment
   IF chk_config(io_din,InitMaster) THEN -- check if config is valid
    GET_PORT_CMT(io_din,InitMaster,CommentNum[2],Status)
      IF status<> 0 THEN
        IF Status = 13030 THEN -- is empty string returning PRIO-030 PRIO=13
          CommentNum[2] = 'DI ' +int2str(InitMaster) +' Not Commented'
        ELSE
          POST_ERR(38000, 'Failed to get InitMaster comment', status, 0) --
          CommentNum[2] = 'Unknown'
        ENDIF
      ENDIF
   ELSE
     CommentNum[2] = 'DI['+int2str(InitMaster)+'] Needs Config'
   ENDIF
  ELSE
    CommentNum[2] = 'Select DI Number'
  ENDIF
 ENDIF

 IF UNINIT(MasterFltRst) THEN -- if Input number is set, go get Comment
   CommentNum[7] = 'Select DI Number'
 ELSE
  IF (MasterFltRst >9)THEN -- if Input number is set, go get Comment
   IF chk_config(io_din,MasterFltRst) THEN -- check if config is valid
    GET_PORT_CMT(io_din,MasterFltRst,CommentNum[7],Status)
      IF status<> 0 THEN
        IF Status = 13030 THEN -- is empty string returning PRIO-030 PRIO=13
          CommentNum[7] = 'DI ' +int2str(MasterFltRst) +' Not Commented'
        ELSE
          POST_ERR(38000, 'Failed to get MasterFltRst comment', status, 0) --
          CommentNum[7] = 'Unknown'
        ENDIF
      ENDIF
   ELSE
     CommentNum[7] = 'DI['+int2str(MasterFltRst)+'] Needs Config'
   ENDIF
  ELSE
    CommentNum[7] = 'Select DI Number'
  ENDIF
 ENDIF

 IF UNINIT(Master_Cnfrm) THEN -- if Output Number is set, go get Comment
   CommentNum[3] = 'Select GO Number'
 ELSE
  IF (Master_Cnfrm >0) THEN -- if Output Number is set, go get Comment
   IF chk_config(io_gpout,Master_Cnfrm) THEN -- check if config is valid
    GET_PORT_CMT(io_gpout,Master_Cnfrm,CommentNum[3],Status)
      IF status<> 0 THEN
        IF Status = 13030 THEN -- is empty string returning PRIO-030 PRIO=13
          CommentNum[3] = 'GO ' +int2str(Master_Cnfrm) +' Not Commented'
        ELSE
          POST_ERR(38000, 'Failed to get Master_Cnfrm comment', status, 0) --
          CommentNum[3] = 'Unknown'
        ENDIF
      ENDIF
    ELSE -- configuration failed to check out
      CommentNum[3] = 'GO['+int2str(Master_Cnfrm)+'] Needs Config'
    ENDIF
   ELSE
    CommentNum[3] = 'Select GO Number'
  ENDIF
 ENDIF

 IF UNINIT(MastrFltCode) THEN -- if Output is set go get Comment
   CommentNum[4] = 'Select GO Number'
 ELSE
 IF (MastrFltCode >0)THEN
   IF chk_config(io_gpout,MastrFltCode) THEN -- check if config is valid
    GET_PORT_CMT(io_gpout,MastrFltCode,CommentNum[4],Status)
      IF status<> 0 THEN
        IF Status = 13030 THEN -- is empty string returning PRIO-030 PRIO=13
          CommentNum[4] = 'GO ' +int2str(MastrFltCode) +' Not Commented'
        ELSE
          POST_ERR(38000, 'Failed to get MastrFltCode comment', status, 0) --
          CommentNum[4] = 'Unknown'
        ENDIF
      ENDIF
   ELSE -- configuration failed to check out
     CommentNum[4] = 'GO['+int2str(MastrFltCode)+'] Needs Config'
   ENDIF
  ELSE
    CommentNum[4] = 'Select GO Number'
  ENDIF
 ENDIF

 -- if Output is set go get Comment
 IF UNINIT(Master_Cmplt) THEN
   CommentNum[5] = 'Select DO Number'
 ELSE
  IF (Master_Cmplt >9) THEN -- if Output is set go get Comment
   IF chk_config(io_dout,Master_Cmplt) THEN -- check if config is valid
    GET_PORT_CMT(io_dout,Master_Cmplt,CommentNum[5],Status)
      IF status<> 0 THEN
        IF Status = 13030 THEN -- is empty string returning PRIO-030 PRIO=13
          CommentNum[5] = 'DO ' +int2str(Master_Cmplt) +' Not Commented'
        ELSE
          POST_ERR(38000, 'Failed to get Master_Cmplt comment', status, 0) --
          CommentNum[5] = 'Unknown'
        ENDIF
      ENDIF
   ELSE -- configuration failed to check out
     CommentNum[5] = 'DO['+int2str(Master_Cmplt)+'] Needs Config'
   ENDIF
  ELSE
    CommentNum[5] = 'Select DO Number'
  ENDIF
 ENDIF

 IF UNINIT(MasterReqFlt) THEN -- if Output is set go get Comment
   CommentNum[6] = 'Select DO Number'
 ELSE
  IF (MasterReqFlt >9) THEN -- if Output is set go get Comment
   IF chk_config(io_dout,MasterReqFlt) THEN -- check if config is valid
    GET_PORT_CMT(io_dout,MasterReqFlt,CommentNum[6],Status)
      IF status<> 0 THEN
        IF Status = 13030 THEN -- is empty string returning PRIO-030 PRIO=13
          CommentNum[6] = 'DO ' +int2str(MasterReqFlt) +' Not Commented'
        ELSE
          POST_ERR(38000, 'Failed to get MasterReqFlt comment', status, 0) --
          CommentNum[6] = 'Unknown'
        ENDIF
      ENDIF
    ELSE -- configuration failed to check out
     CommentNum[6] = 'DO['+int2str(MasterReqFlt)+'] Needs Config'
   ENDIF
  ELSE
    CommentNum[6] = 'Select DO Number'
  ENDIF
 ENDIF

END comment_vars
-----------------------------------------------------------------------------
ROUTINE Setup_IOData
-- PURPOSE: used for the setup table for the GI/GOUT of mastering from PLC
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
 BEGIN

IF UNINIT(strtMstrNum) THEN
  strtMstrNum = 313
ENDIF
IF UNINIT(strtEchoNum) THEN
  strtEchoNum = 281
ENDIF
IF UNINIT(strtFltNum) THEN
  strtFltNum = 321
ENDIF


REPEAT --

Value_array[1]= 'Master_Req'
Value_array[2]= 'CommentNum[1]'
Value_array[3]= 'strtMstrNum'

Value_array[4]= 'InitMaster'
Value_array[5]= 'CommentNum[2]'
Value_array[6]= 'MasterFltRst'    -- added 3-18-14
Value_array[7]= 'CommentNum[7]'   -- added 3-18-14

Value_array[8]= 'Master_Cnfrm'
Value_array[9]= 'CommentNum[3]'
Value_array[10]= 'strtEchoNum'
Value_array[11]= 'MastrFltCode'
Value_array[12]= 'CommentNum[4]'
Value_array[13]= 'strtFltNum'

Value_array[14]= 'Master_Cmplt'
Value_array[15]= 'CommentNum[5]'
Value_array[16]= 'MasterReqFlt'
Value_array[17]= 'CommentNum[6]'

 FOR i = 1 TO ARRAY_LEN(inact_array) DO
   IF MastrConfigd THEN -- If mastered cannot allow modifing
     inact_array[i] = TRUE
   ELSE
     inact_array[i] = FALSE
   ENDIF
 ENDFOR --


 -- call routine to setup comments for i/o selected
 comment_vars

IF UNINIT(MastrConfigd) THEN
  MastrConfigd = FALSE
ENDIF
 -- call program to check I/O is not used other places
-- If master configured is not done cannot compare the I/O
IF MastrConfigd THEN
 verfiy_io
ENDIF

-- kc_f1_type to handle the TYPE key processing with custommenu[x].$option = 31 will have TYPE work No FORCE USER!
term_mask =  kc_item_chng  + kc_f1_type + kc_func_key +ky_prev-- kc_f1_type + kc_func_key  --kc_other
term_char = -1
  DISCTRL_FORM('mdfy', iosetup_det, value_array, inact_array, change_array, term_mask, def_item, term_char, form_status)
    IF form_status<>0 THEN
      all_done = TRUE
      POST_ERR(38000, 'mdfy i/osetup_det Display Failed', form_status, 2) --
    ENDIF

 SELECT (term_char) OF -- select how the form was ended or which key pressed
    CASE(ky_new_menu):
    CASE(ky_f1): -- Handled by SETUP [TYPE] functioning
    CASE(ky_f2):-- Selected Config.
    CASE(ky_f3,ky_prev):  -- Selected to Do the Inspection detail.
       Form_number = 1
       -- Do the history of changes
       --RETURN
    CASE(ky_f4):-- Selected Config
        IF MastrConfigd THEN -- If mastered cannot allow modifing
          POST_ERR(38000, 'I/O Setup ALREADY DONE', 0, 0) --
        ELSE
          config_io
          POST_ERR(38000, 'Cycle Power if New GI/GO', 0, 0) --
          MastrConfigd = TRUE
        ENDIF
        --KCL> SMON('RE_POWER')
    CASE(ky_f8): --user want to change setup
        MastrConfigd = FALSE
        POST_ERR(38000, 'Setup I/O Unlocked Again', 0, 0) --
    CASE(ky_undef):
    ELSE: --
   ENDSELECT   --det_term_chr OF

UNTIL ((term_char = ky_new_menu) OR (form_status <>0 ) OR (Form_number <> 3)) -- New Screen selected

END Setup_IOData
-----------------------------------------------------------------------------
ROUTINE Modify_data
-- PURPOSE:
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------

BEGIN

IF UNINIT(all_done) THEN
  all_done = FALSE
ENDIF

FOR i = 1 TO ARRAY_LEN(inact_array) DO
  inact_array[i] = FALSE
ENDFOR --

IF (UNINIT(ModArryNum)) THEN
  ModArryNum = 1
ENDIF

  IF (ModArryNum > ARRAY_LEN(MasterProgs)) THEN
    ModArryNum = 1
  ENDIF

FOR i = 1 TO ARRAY_LEN(value_array) DO
  value_array[i] = ''
ENDFOR --


REPEAT --
 FOR i = 1 TO ARRAY_LEN(inact_array) DO
   IF unlocked THEN -- if user know secret to unlock
     IF UNINIT(MasterProgs[ModArryNum].enable_montr) THEN
       MasterProgs[ModArryNum].enable_montr = FALSE
     ENDIF
     IF (MasterProgs[ModArryNum].enable_montr = FALSE) THEN
       inact_array[i] = FALSE
     ELSE -- need to allow modifications
       inact_array[i] = TRUE
     ENDIF
   ELSE
     inact_array[i] = TRUE
   ENDIF
 ENDFOR --

-- unlock program array number to allow user to adjust
inact_array[1] = FALSE
IF unlocked THEN -- if user know secret to unlock
  inact_array[4]= FALSE
ENDIF

Var_name = 'MasterProgs['+int2str(ModArryNum)+'].'  -- Program name and Fixdata

Value_array[1]= 'ModArryNum'    -- this is variable structure name
Value_array[2]= Var_name +'program_name' -- Program name text

  IF UNINIT(MasterProgs[ModArryNum].program_name) THEN
     MasterProgs[ModArryNum].program_cmnt = 'Select a Program'
   ELSE
    LOAD_STATUS(MasterProgs[ModArryNum].program_name,loaded, initialized)
    IF loaded THEN -- its loaded, get the modified attribute
     GET_ATTR_PRG(MasterProgs[ModArryNum].program_name,AT_COMMENT,int_value,MasterProgs[ModArryNum].program_cmnt,status)
       IF status<> 0 THEN
         POST_ERR(38000, 'Failed to get '+ MasterProgs[ModArryNum].program_name +' comment', status, 0) --
       ENDIF
     ELSE -- program is not loaded
       MasterProgs[ModArryNum].program_cmnt = 'File NOT Found'
     ENDIF
   ENDIF

--Value_array[3]= 'Prg_Comment' --
Value_array[3]= Var_name + 'program_cmnt' --
Value_array[4]= Var_name + 'Modified_do' -- display the output to turn on when modified

-- setup the display for the program comment
Value_array[5]= 'DO_Comment'
-- if output is set go get Comment
 IF UNINIT(MasterProgs[ModArryNum].Modified_do) THEN
   DO_Comment = 'Enter DO Number'
 ELSE
   same_io = FALSE
   -- need to check duplicate I/O number
   FOR i = 1 TO ARRAY_LEN(MasterProgs) DO
     IF (i <> ModArryNum) THEN -- ensure not comparing active Program
       IF NOT UNINIT(MasterProgs[i].Modified_do) THEN
         IF (MasterProgs[ModArryNum].Modified_do = MasterProgs[i].Modified_do) AND &
            (MasterProgs[ModArryNum].Modified_do >0) THEN
           POST_ERR(38000, 'DO '+ int2str(MasterProgs[ModArryNum].Modified_do) + ' used in Array '+ int2str(i) + ' already', status, 0) --
           DELAY 1000
           MasterProgs[ModArryNum].Modified_do = 0
           DO_Comment = 'Enter New DO #'
           same_io = TRUE
         ENDIF
       ENDIF
     ENDIF
   ENDFOR --
   IF (same_io = FALSE) AND (MasterProgs[ModArryNum].Modified_do >0) THEN
    GET_PORT_CMT(io_dout,MasterProgs[ModArryNum].Modified_do,DO_Comment,Status)
      IF status<> 0 THEN
        IF Status = 13030 THEN -- is empty string returning PRIO-030 PRIO=13
          IF MasterProgs[ModArryNum].enable_montr THEN -- only comment if enabled
            DO_Comment = 'Prg Mon#'+int2str(ModArryNum)+' is OK'
            SET_PORT_CMT(io_dout,MasterProgs[ModArryNum].Modified_do,DO_Comment,status)
              IF status<>0 THEN
                POST_ERR(38000, 'DO '+int2str(MasterProgs[ModArryNum].Modified_do)+' Comment Set Failed', status, 0) --
              ENDIF
          ELSE -- otherwise point it out so user will do
            DO_Comment = 'Not Commented'
          ENDIF
        ELSE
          POST_ERR(38000, 'Failed to get I/O comment', status, 0) --
          DO_Comment = 'Unknown'
        ENDIF
      ENDIF

   ENDIF
 ENDIF

-- set the enabled variable
Value_array[6] = Var_name + 'enable_montr'

-- Check if mastering has never been done
IF UNINIT(MasterProgs[ModArryNum].LastMastered) THEN
  Not_mastered = 'Not Completed'
  Value_array[7]= 'Not_mastered' -- display the mastered date
ELSE
 Value_array[7]= Var_name + 'LastMastered' -- display the mastered date
ENDIF

IF UNINIT(MasterProgs[ModArryNum].program_name) THEN
ELSE
  LOAD_STATUS(MasterProgs[ModArryNum].program_name,loaded, initialized)
    IF loaded THEN -- its loaded, get the modified attribute
      GET_ATTR_PRG(MasterProgs[ModArryNum].program_name, AT_MDFY_TIME, mod_time, string_value, status)
        IF status<> 0 THEN
          POST_ERR(38000, 'Failed to get '+ MasterProgs[ModArryNum].program_name +' Modified Time', status, 0) --
          Prg_Comment = ''
        ELSE
          CNV_TIME_STR(mod_time,MasterProgs[ModArryNum].LastModified)
        ENDIF
    ENDIF
ENDIF

Value_array[8]= Var_name + 'LastModified' -- display the last date modified
Value_array[9]= Var_name + 'MasterTimStr' -- Dispaly mastered time    --term_mask
-- kc_f1_type to handle the TYPE key processing with custommenu[x].$option = 31 will have TYPE work No FORCE USER!
term_mask =  kc_item_chng  + kc_f1_type + kc_func_key-- kc_f1_type + kc_func_key  --kc_other
term_char = -1
  DISCTRL_FORM('mdfy', modify_det, value_array, inact_array, change_array, term_mask, def_item, term_char, form_status)
    IF form_status<>0 THEN
      all_done = TRUE
      POST_ERR(38000, 'mdfy Display Failed', form_status, 2) --
    ENDIF

--WRITE TPERROR(CHR(cc_clear_win),'SOMETHING CHANGED')
 -- form has ended

  SELECT (term_char) OF -- select how the form was ended or which key pressed
    CASE(ky_new_menu):

    CASE(ky_f1): -- EXIT ??? Have to try to get the DATA [TYPE] functioning

    CASE(ky_f2):-- Selected to Do the previous detail.
      IF ModArryNum > 1 THEN  -- could do nest if def_item is 2????
        ModArryNum = ModArryNum - 1
      ELSE
        ModArryNum = ARRAY_LEN(MasterProgs)
      ENDIF
    CASE(ky_f3):  -- Selected to Do the Inspection detail.
       -- Do the history of changes
       form_number = 2
      -- ModifyTable
      -- form_number = 1
    CASE(ky_f4):  -- Selected to Do the Next detail.
      IF ModArryNum < ARRAY_LEN(MasterProgs) THEN
        ModArryNum = ModArryNum + 1
      ELSE
        ModArryNum = 1
      ENDIF

    CASE(ky_f7): -- I/O setup has been requested
       form_number = 3
      -- Setup_IOData
    CASE(ky_f8): -- selected to unlock parameters
        IF unlocked THEN
          WRITE TPERROR(CHR(cc_clear_win),'Locked Program Monitoring Setup')
          unlocked = FALSE
        ELSE
          WRITE TPERROR(CHR(cc_clear_win),'Unlocked Program Monitoring Setup')
          unlocked = TRUE
        ENDIF
    CASE(ky_undef):
    ELSE: --
  ENDSELECT   --det_term_chr OF

UNTIL ((term_char = ky_new_menu) OR (form_status <>0) OR (Form_number <> 1)) -- New Screen selected

END Modify_data
-- --------------------------------------------------------------------
--
-- ROUTINE:     CH_TASKS
-- TITLE:       Check Programs For Status
--
-- DESCRIPTION: This routine Restarts a Paused Task or Restarts a Aborted Tasks
--
--
-- PARAMETERS: [IN]  task_name to check upon reciving the cycle start &
--                   group_number is the group for the robot to check if
--                   it is ready
--             [OUT] TRUE OR FALSE Based on whether the program was restarted
--
-- --------------------------------------------------------------------

ROUTINE ch_tasks (task_name:string)

VAR

task_status : INTEGER
tp_state    : BOOLEAN
task_num    : INTEGER
value_str   : STRING[20]


BEGIN
  task_status = 0 -- if task was not ever ran task_status is uninit.

LOAD_STATUS(task_name,loaded, initialized)

  IF loaded = FALSE THEN
    POST_ERR(38000, task_name +' is NOT LOADED', 0, 0) --
    RETURN
  ENDIF

--IF $MOR_GRP[group_number].$SERVO_READY THEN   -- if drives are energized,
REPEAT --
       -- check if TP is enabled before running
   tp_state = OPOUT[7]

    task_num = 0

  GET_TSK_INFO(task_name,task_num,TSK_STATUS,task_status,value_str,status) --
    IF status <> 0 THEN
      IF status = 3016 THEN -- task was not ran
        RUN_TASK(task_name,0,FALSE,tp_state,0,status)
        IF status <>0 THEN
          POST_ERR(38000,'FAILED RUN TASK ' + task_name, status,0) --
          RETURN
        ENDIF
      ELSE
        POST_ERR(38000,'FAILED GET TASK INFO ' + task_name, status,0) --
        RETURN
      ENDIF
    ELSE -- when program not running abort it and restart it
      IF task_status = PG_RUNNING THEN
        RETURN
      ENDIF
        POST_ERR(38000, task_name+ ' Program was NOT running', 0, 0) --
        IF task_status = PG_PAUSED THEN -- Programs should be aborted in case of Program bugs cause it to pause
          ABORT_TASK(task_name,TRUE,TRUE,status)
          IF status <> 0 THEN
            POST_ERR(38000, task_name +' FAILED TO ABORT', status, 0) --
            DELAY 2000
          ENDIF
        ENDIF
    ENDIF

UNTIL (task_status = PG_ABORTED) OR (status = 3016) --

  RUN_TASK(task_name,0,FALSE,tp_state,0,status)
    IF status <> 0 THEN
      POST_ERR(38000,task_name +' FAILED TO START', status,0) --
      DELAY 2000
    ENDIF

END ch_tasks

--------------------------------------------------------------------------------
--------------------        MAIN BODY OF PROGRAM     ---------------------------
--------------------------------------------------------------------------------

BEGIN

 version_id = ver
-- forcing the menu is not needed when using custom menu and $option set to 31 for TYPE function
-- FORCE_SPMENU(tp_panel,SPI_TPUSER2,1) -- force the user screen to display forms

IF UNINIT(form_number) THEN
  form_number = 1
ENDIF

initvars

-- need to verify program is running
 ch_tasks('CHK_MDFY')

  all_done = FALSE-- set the loop flag
 unlocked = FALSE
 WHILE NOT (all_done) DO -- do diplay until they say stop
   SELECT (form_number) OF --
      CASE (1):  --
        Modify_data
      CASE (2):  --
        ModifyTable
      CASE (3):  --
        Setup_IOData
      ELSE: --
         all_done = FALSE
        --  WRITE TPERROR(CHR(cc_clear_win),'Insertion Data display completed')
   ENDSELECT --
 ENDWHILE --
        --  WRITE TPERROR(CHR(cc_clear_win),'Insertion Data display completed')

END MDFYSTUP
