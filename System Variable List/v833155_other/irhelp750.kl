--    This material is the joint property of Fanuc Robotics Corporation  and
--    FANUC  LTD  Japan,  and  must  be  returned  to  either Fanuc Robotics
--    Corporation or FANUC LTD Japan immediately upon request.  This  material
--    and   the  information  illustrated  or  contained  herein  may  not  be
--    reproduced, copied, used, or transmitted in whole or in part in any  way
--    without the prior written consent of both Fanuc Robotics and FANUC.
--    
--             All Rights Reserved
--             Copyright (C)   2000
--             Fanuc Robotics Corporation
--             FANUC LTD Japan
--    
--             Karel is a registered trademark of
--             Fanuc Robotics Corporation
--    +
--    Program:  iRHelp
--    
--    Language: KAREL
--    
--    Source File:   irHelp 25 sep 2009
-- 
--    Description - 
--	Perform help function for irmath
--
--    SYNTAX:
--    CALL irHelp(FC, Entry)
--      FC : Function code               Integer
--	29 = help

--    Author: Tom Nemmers 
--            Fanuc Robotics Corporation
--            2000 South Adams Road
--            Auburn Hills, Michigan    48326-2800
--    
--    Modification history:
--  Ver 1.0  25-Sep-2009   T. Nemmers - Begin INIT MACROS, HELP, TASK COMMENTS
--  Ver 1.1   10-20-2009  T Nemmers - add irHelpext
-- ver 29  11/11/09 T Nemmers add back lash match version numbers
-- Ver 29.1 1/7/10   T Nemmers add save vars and Load Vars function for irmath
-- Ver 29.2 1/7/10   T Nemmers Fix help for log functions
--  Ver 31.0 12/10/2009 T Nemmers Add Hires parameter for LogR and LogPR
-- ver 31.1 1/21/2010 t.nemmers increase MAX_PARMS t o 4
--  Ver 31.3  1/21/2010 T Nemmers Add  fcClearProg to irhelp
--  Ver 31.4i  1/21/2010 T Nemmers Make invisible
-- ver 32.1  Post_err in CheckStatus,
--		 grouped functions that use PR parameter together, 
--		remove GetNextRobID  
--		Add SphereLine  FcSphereLine
-- ver 32.2 add GetFunction to irHelp
-- ver 32.3 add capitalize 
-- ver 32.4 correct help for 'comments' function
-- ver 33.0 11/30/2010 nemmerst add irLogger for holding logging functions
-- ver 33.1 11/30/2010 nemmerst add fcOZFrame function
-- ver 34.0 1/25/2011 nemmerst Back to Irhelp and irmath files
-- ver 34.1 1/28/2011 nemmerst mover init macros to its own program and folder
-- ver 34.2 3/3/2011 nemmerst Add Carrousel function
-- ver 34.3v 3/14/2011 add posn type 5 matrix
-- ver 34.4v 3/23/2011 add Best fit Plane and best fit circle
-- ver 34.5v 3/28/2011 add Best Carrousel. start of Best paraboloid
-- ver 34.7v 4/12/2011 add logging to TPDISPLAY
--    10-15-13 jja R30iB Development ver 3.0
------------------------------------------------------------------
PROGRAM irHelp
------------------------------------------------------------------
%ALPHABETIZE
%COMMENT = 'iRhelp  v4.0'
%NOPAUSE = ERROR + COMMAND + TPENABLE
%NOLOCKGROUP 
%NOBUSYLAMP
%RWACCESS
--%invisible

%ENVIRONMENT KCLOP
%ENVIRONMENT TIM
%ENVIRONMENT REGOPE 
%ENVIRONMENT sysdef
%ENVIRONMENT ripdef -- you may need to copy ripdef.ev to compile
%ENVIRONMENT VECTR 
%ENVIRONMENT CVIS 

%INCLUDE irCons
%INCLUDE irVars

------------------------------------------------------------------------------------------------------------------
ROUTINE LogError ( TextIn : STRING; Int_data : INTEGER; DataType : INTEGER)
------------------------------------------------------------------------------------------------------------------
BEGIN
SELECT dataType OF
	CASE(0): -- CR and String
		WRITE TPERROR (CR, TextIn)
	CASE(1): -- String only
		WRITE TPERROR (TextIn)
	CASE(2): -- integer
		WRITE TPERROR (int_data)
	CASE(3): -- CR only
		WRITE TPERROR (CR)
	ELSE:
ENDSELECT
END LogError

-------------------------------------------------------------------------------------------
ROUTINE LogErrCr ( TextIn : STRING)
-------------------------------------------------------------------------------------------
BEGIN
LogError (TextIn,0,0)
IF UNINIT(debugFlag) THEN debugFlag = FALSE;ENDIF
IF debugFlag THEN
	PAUSE
ENDIF
END LogErrCr

-------------------------------------------------------------------------------------------
ROUTINE LogErrS  ( TextIn : STRING)
-------------------------------------------------------------------------------------------
BEGIN
LogError (TextIn,0,1)
END LogErrS 

-------------------------------------------------------------------------------------------
ROUTINE LogErrI ( Int_data : INTEGER)
-------------------------------------------------------------------------------------------
BEGIN
LogError ('',int_data,2)
END LogErrI

--------------------------------------------------------------------------------------------------------------------------
ROUTINE CheckStatus(StatusIn : INTEGER; text : STRING; Ivalue : INTEGER) : BOOLEAN
--------------------------------------------------------------------------------------------------------------------------
BEGIN
IF STATUSIn <> 0 THEN
	Post_err(StatusIn,'',0,cc_warn)
	LogErrCr(text)
 	IF Ivalue <> 0 THEN
    		LogErrI (ivalue)
  	ENDIF
 	RETURN (FALSE)
ENDIF
RETURN (TRUE)
END CheckStatus

------------------------------------------------------------------------
ROUTINE CheckEC (text : STRING) : BOOLEAN
------------------------------------------------------------------------
---- check status of last log file operation
-- Input
--	text - description of last log operation
-- Output
--	return false if last operation had an error
BEGIN
ec = IO_STATUS (logfile)
RETURN(CheckStatus(ec, text , 0))
END CheckEC

------------------------------------------------------------------------
ROUTINE LogInit
------------------------------------------------------------------------
BEGIN
IF UNINIT (logOpened) THEN logOpened = FALSE; ENDIF
IF UNINIT (FileName) THEN FileName = 'irMath.csv'; ENDIF  
END LogInit

------------------------------------------------------------------------
ROUTINE LogOpen
------------------------------------------------------------------------
BEGIN

--USING PickTable DO

IF UNINIT (FileName) THEN LogInit; ENDIF 
IF FIleName = 'TPDISPLAY' THEN
	Logopened = true
ELSE 
	OPEN FILE logfile ('AP',filename)
	LogOpened = CheckEC('Failed to Open ' + FileName +': ')
ENDIF
END LogOpen

------------------------------------------------------------------------
ROUTINE LogCR
------------------------------------------------------------------------

BEGIN
IF logOpened THEN    
	IF FileName = 'TPDISPLAY' THEN
		WRITE TPDISPLAY (CR)
		LogOk = true
	ELSE
		WRITE logfile (CR)
		LogOK = CheckEC ('Failed to log CR, ')
	ENDIF
ENDIF
END LogCR

------------------------------------------------------------------------
ROUTINE LogDate (delim : INTEGER) -- Date and Time
------------------------------------------------------------------------
VAR
iTime         : INTEGER
strTime       : STRING[20]
BEGIN
IF logOpened THEN

	GET_TIME(iTime)
	CNV_TIME_STR(iTime,strTime) -- displayed in DD-MMM-YYY HH:MM: format. 

	SELECT delim OF
		CASE (99): -- null
			IF FileName = 'TPDISPLAY' THEN
				WRITE tpdisplay (strTime)
			else
				WRITE logfile (strTime)
			ENDIF
		CASE (1): -- CR
			IF FileName = 'TPDISPLAY' THEN
				WRITE tpdisplay (CR,strTime)
			else
				WRITE logfile (CR,strTime)
			endif
		ELSE: -- comma
			IF FileName = 'TPDISPLAY' THEN
				WRITE logfile (',',strTime)
			else
				WRITE logfile (',',strTime)
			endif
	ENDSELECT
ENDIF
END LogDate

------------------------------------------------------------------------
ROUTINE LogI (i : INTEGER; delim : INTEGER)
------------------------------------------------------------------------
BEGIN
IF logOpened THEN
	SELECT delim OF
		CASE (99): -- null
			IF FileName = 'TPDISPLAY' THEN
				WRITE tpdisplay (i::7) 
			ELSE
				WRITE logfile (i::7) 
			ENDIF
		CASE (1): -- CR
			IF FileName= 'TPDISPLAY' THEN
				WRITE tpdisplay (CR,i::7) 
			else
				WRITE logfile (CR,i::7) 
			endif
		ELSE: -- comma
			IF FileName = 'TPDISPLAY' THEN
			 	WRITE tpdisplay (',',i::7) 
			else
				WRITE logfile (',',i::7) 
			endif
	ENDSELECT
	LogOK = CheckEC('Failed to Log integer, ')
ENDIF
END LogI

------------------------------------------------------------------------
ROUTINE LogR (r : REAL; delim : INTEGER)
------------------------------------------------------------------------
BEGIN
IF logOpened THEN
	SELECT delim OF
		CASE (99): -- null
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (r::8::2) 
			ELSE
				WRITE logfile (r::8::2) 
			ENDIF
		CASE (1): -- CR
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (CR,r::8::2) 
			ELSE
				WRITE logfile (CR,r::8::2) 
			ENDIF
		ELSE: -- comma
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (',',r::8::2) 
			ELSE
				WRITE logfile (',',r::8::2) 
			ENDIF
	ENDSELECT
	LogOK = CheckEC('Failed to Log Real, ')
ENDIF
END LogR
------------------------------------------------------------------------
ROUTINE LogRh (r : REAL; delim : INTEGER)
------------------------------------------------------------------------
BEGIN
IF logOpened THEN
	SELECT delim OF
		CASE (99): -- null
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (r::15::5) 
			ELSE
				WRITE logfile (r::15::5) 
			ENDIF
		CASE (1): -- CR
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (CR,r::15::5) 
			ELSE
				WRITE logfile (CR,r::15::5) 
			endif
		ELSE: -- comma
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (CR,r::15::5) 
			else
				WRITE logfile (CR,r::15::5) 
			endif
	ENDSELECT
	LogOK = CheckEC('Failed to Log Real, ')
ENDIF
END LogRh

------------------------------------------------------------------------
ROUTINE LogS (s : STRING; delim : INTEGER)
------------------------------------------------------------------------
BEGIN
IF logOpened THEN
	SELECT delim OF
		CASE (99): -- null
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (s)
			ELSE
				WRITE logfile (s)
			ENDIF
		CASE (1): -- CR
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (CR,s)
			ELSE
				WRITE logfile (CR,s)
			ENDIF
		ELSE: -- comma
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (',',s)
			ELSE
				WRITE logfile (',',s)
			ENDIF
	ENDSELECT
	LogOK = CheckEC('Failed to Log String, ')
ENDIF
END LogS

------------------------------------------------------------------------
ROUTINE LogPR (E: XYZWPREXT; Delim : INTEGER) 
------------------------------------------------------------------------
BEGIN
IF logOpened 	THEN
	SELECT delim OF
		CASE (99): -- null
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (e.x::8::2,',',e.y::8::2,',',e.z::8::2)
			ELSE
				WRITE logfile (e.x::8::2,',',e.y::8::2,',',e.z::8::2)
			ENDIF
		CASE (1): -- CR
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (CR,e.x::8::2,',',e.y::8::2,',',e.z::8::2)
			ELSE
				WRITE logfile (CR,e.x::8::2,',',e.y::8::2,',',e.z::8::2)
			ENDIF
		ELSE: -- comma
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (',',e.x::8::2,',',e.y::8::2,',',e.z::8::2)
			ELSE
				WRITE logfile (',',e.x::8::2,',',e.y::8::2,',',e.z::8::2)
			ENDIF
	ENDSELECT
	WRITE logfile ( ',',e.w::8::3,',',e.p::8::3,',',e.r::8::3)
	LogOK = CheckEC('Failed to Log PR, ')
ENDIF
END LogPR


------------------------------------------------------------------------
ROUTINE LogPRh (E: XYZWPREXT; Delim : INTEGER) 
------------------------------------------------------------------------
BEGIN
IF logOpened  THEN
	SELECT delim OF
		CASE (99): -- null
			IF FileName = 'TPDISPLAY' THEN
				WRITE logfile (e.x::12::5,',',e.y::12::5,',',e.z::12::5)
			ELSE
				WRITE logfile (e.x::12::5,',',e.y::12::5,',',e.z::12::5)
			ENDIF
		CASE (1): -- CR
			IF FileName = 'TPDISPLAY' THEN
				WRITE logfile (CR,e.x::12::5,',',e.y::12::5,',',e.z::12::5)
			ELSE
				WRITE logfile (CR,e.x::12::5,',',e.y::12::5,',',e.z::12::5)
			ENDIF
		ELSE: -- comma
			IF FileName = 'TPDISPLAY' THEN
				WRITE logfile (',',e.x::12::5,',',e.y::12::5,',',e.z::12::5)
			ELSE
				WRITE logfile (',',e.x::12::5,',',e.y::12::5,',',e.z::12::5)
			ENDIF
	ENDSELECT    
	WRITE logfile ( ',',e.w::10::5,',',e.p::10::5,',',e.r::10::5)
	LogOK = CheckEC('Failed to Log PR, ')
ENDIF
END LogPRh

------------------------------------------------------------------------
ROUTINE LogV (v: VECTOR; Delim : INTEGER) 
------------------------------------------------------------------------
BEGIN
IF logOpened THEN
	SELECT delim OF
		CASE (99): -- null
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (v.x::12::5,',',v.y::12::5,',',v.z::12::5)
			ELSE
				WRITE logfile (v.x::12::5,',',v.y::12::5,',',v.z::12::5)
			ENDIF
		CASE (1): -- CR
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (CR,v.x::12::5,',',v.y::12::5,',',v.z::12::5)
			ELSE
				WRITE logfile (CR,v.x::12::5,',',v.y::12::5,',',v.z::12::5)
			ENDIF
		ELSE: -- comma
			IF FileName = 'TPDISPLAY' THEN
				WRITE TPDISPLAY (',',v.x::12::5,',',v.y::12::5,',',v.z::12::5)
			ELSE
				WRITE logfile (',',v.x::12::5,',',v.y::12::5,',',v.z::12::5)
			ENDIF
	ENDSELECT
	LogOK = CheckEC('Failed to Log vector, ')
	ENDIF
END LogV

-----------------------------------------------------------------------
ROUTINE LogClose
------------------------------------------------------------------------
BEGIN
IF UNINIT(logOpened) THEN LogOpened = FALSE; ENDIF
IF logOpened THEN
	IF FileName = 'TPDISPLAY' THEN
		logOpened = FALSE
	ELSE
		CLOSE FILE logfile 
		LogOpened = NOT CheckEC('Failed to Close, ')
	ENDIF
ENDIF
END LogClose


--------------------------------------------------------------------------------------------------------------------
ROUTINE get_reg_any(reg: INTEGER; int_val : INTEGER; real_val : REAL) : BOOLEAN
--------------------------------------------------------------------------------------------------------------------
VAR
  real_flag : BOOLEAN

BEGIN -- get_reg_real
real_val = 0.0
int_val = 0
GET_REG(reg, real_flag, int_val, real_val,STATUS1)
ok = CheckStatus(STATUS1,'GET_REG failed for register ',reg)
RETURN (real_flag)
END get_reg_any

------------------------------------------------------------------------
ROUTINE get_reg_real(reg: INTEGER) : REAL
------------------------------------------------------------------------
VAR
  real_flag : BOOLEAN
  real_val  : REAL
  int_val   : INTEGER

BEGIN -- get_reg_real
real_val = 0.0
IF reg > 0 THEN
	IF NOT get_Reg_any(reg, int_val, real_val) THEN
		real_val = int_val
		LogErrCr('Register contains an Integer')
	ENDIF
ELSE
	IF reg < -PrTableSz THEN
		LogErrCr('irMath - Parameter Too Negative parameter')
		ok = FALSE
	Else
		IF reg = 0 THEN
			LogErrCr('irMath - Parameter cannot be 0')
			ok = FALSE
		else   
			real_val = realtable [( -1) * reg]
		ENDIF 
	ENDIF
ENDIF  
    
RETURN (real_val)
END get_reg_real

------------------------------------------------------------------------
ROUTINE get_reg_int(reg: INTEGER) : INTEGER
------------------------------------------------------------------------
VAR
  real_flag : BOOLEAN
  real_val  : REAL
  int_val   : INTEGER

BEGIN -- get_reg_int
int_val = 0
IF UNINIT(reg) THEN
	ok = FALSE
	LogErrCr('irMath - Parameter uninitialized')
ELSE
	IF reg > 0 THEN
		IF get_Reg_any(reg, int_val, real_val) THEN
			int_val=ROUND(real_val)
			LogErrCr('Register contains a Real')
		ENDIF
	ELSE
		IF reg < -PrTableSz THEN
			LogErrCr('irMath - Parameter Too Negative parameter')
			ok = FALSE
		ELSE
			IF reg = 0 THEN
				LogErrCr('irMath - Parameter cannot be 0')
				ok = FALSE
			ELSE   
				int_val = inttable[ ( -1) * reg]
			ENDIF
		ENDIF
	ENDIF
ENDIF  
  
RETURN (int_val)
END get_reg_int

-------------------------------------------------------------------------------------------
ROUTINE Set_Grp_no (Grp_no_in : Integer)
-------------------------------------------------------------------------------------------
BEGIN
Grp_no = grp_no_in
ok = true
End Set_grp_no

-------------------------------------------------------------------------------------------
ROUTINE getposr (PrReg : INTEGER;PrIn : XYZWPREXT)
-------------------------------------------------------------------------------------------
-- Return value or PR Reg in PRin
-- Input 
--	PrReg < 0 indicates table source
--	PrReg > 0 indicates PR source
--	PrReg = 0 indicates no value return $NILPOS
-- Output
--	PRin	value of PRreg
--	OK is false if a system call failed (bad reg index, bad reg type)
BEGIN
IF ok THEN
	IF prreg < 0 THEN
		IF Prreg < (-PrTableSz )THEN
			LogErrCr('irMath - Table index to large')
			ok = FALSE
		ELSE
			IF UNINIT(prtable[-prreg]) THEN 
				LogErrCr('PRTABLE value is UNINITED')
				ok = FALSE
			ELSE
				prin = PRTable[-prreg]
			ENDIF
		ENDIF
    
	ELSE 
 		IF prreg > 0 THEN  -- PrReg >= 0
			POS_REG_TYPE (prreg, grp_no, posn_type, num_axes, STATUS1) 
			ok = CheckStatus(STATUS1,'iRMath - POS_REG_TYPE failed for PR: ',prreg)
			IF Ok THEN
				SELECT posn_type OF
					CASE (1,2,5, 6) : -- POSITION, XYZWPR, MATRIX, XYZWPREXT
						prin = GET_POS_REG(prreg,STATUS1,grp_no)
						IF STATUS1 <> 0 THEN
							ok = CheckStatus(STATUS1,'iRMath - GET_POS_REG failed for PR',prreg)
						ENDIF
					CASE (9) : -- JOINTPOS
						Jointin = GET_JPOS_REG(prreg, STATUS1 ,grp_no) 
						ok = CheckStatus(STATUS1,'iRMath - GET_JPOS_REG failed for PR',prreg)
						IF ok THEN     
							IF $MNUFRAMENUM[grp_no] = 0 THEN 
								$UFRAME = $MOR_GRP[grp_no].$NILPOS
							ELSE
								$UFRAME = $MNUFRAME[grp_no,$MNUFRAMENUM[grp_no]]
							ENDIF
							IF $MNUTOOLNUM[grp_no] = 0 THEN
								$UTOOL = $MOR_GRP[grp_no].$NILPOS
							ELSE
								$UTOOL = $MNUTOOL[grp_no,$MNUTOOLNUM[grp_no]]
							ENDIF
						prin = jointin
						ENDIF
          					ELSE:
					            LogErrCr('iRMath - Invalid pos type for PR[')
					            LogErrI(prreg)
					            LogErrS('] type = ')
					            LogErrI(posn_type)
					            ok = FALSE
				ENDSELECT
			ELSE
			        LogErrCr('iRMath - Missing getpos Parameter')
			        ok = FALSE
			ENDIF
 		ELSE -- PrReg = 0 , return $NILPOS
 			PrIn = $MOR_GRP[Grp_no].$NILPOS
    		ENDIF
  	ENDIF
ENDIF
END getposr

---------------------------------------------------------------------------------------------
ROUTINE getposrOK (PrReg : INTEGER;PrIn : XYZWPREXT) : BOOLEAN
---------------------------------------------------------------------------------------------
BEGIN
Ok = true
getposr (PrReg,PrIn )
RETURN (ok)
END getposrOK

---------------------------------------------------------------------------------------------------------------------------------------------
ROUTINE Get_VR_Real(var_name : STRING; real1 : REAL) : BOOLEAN
---------------------------------------------------------------------------------------------------------------------------------------------

BEGIN
GET_VAR(entry,  '*SYSTEM*', var_name, real1, Kstatus)
IF Kstatus <> 0 THEN
	Return( CheckStatus(Kstatus,'iRMath - Get_Var_Real Failed for  ' + var_name,0) )
ENDIF
RETURN(TRUE)
END Get_VR_Real
---------------------------------------------------------------------------------------------------------------------------------------------
ROUTINE Get_VR_Int(var_name : STRING; integer1 : INTEGER) : BOOLEAN
---------------------------------------------------------------------------------------------------------------------------------------------

BEGIN
program_name = '*SYSTEM*'
GET_VAR(entry, '*SYSTEM*', var_name, integer1, Kstatus)
IF Kstatus <> 0 THEN
	Return( CheckStatus(Kstatus,'iRMath - Get_Var_Int Failed for  ' + var_name,0) )
ENDIF
RETURN(TRUE)
END Get_VR_Int
---------------------------------------------------------------------------------------------------------------------------------------------
ROUTINE Get_VR_Str(var_name, string1 : STRING) : BOOLEAN
---------------------------------------------------------------------------------------------------------------------------------------------

BEGIN
GET_VAR(entry, '*SYSTEM*', var_name,string1, Kstatus)
IF Kstatus <> 0 THEN
	Return( CheckStatus(Kstatus,'iRMath - Get_Var_String Failed for  ' + var_name,0) )
ENDIF
RETURN(TRUE)
END Get_VR_str

---------------------------------------------------------------------------------------------------------------------------------------------
ROUTINE Get_VR_View(VRN, GN,ViewNo : INTEGER; e : XYZWPREXT) : BOOLEAN
---------------------------------------------------------------------------------------------------------------------------------------------
--  Inputs:
-- VRN:		vision Register number index
-- GN:		group number
--  Outputs: 	1 to 4 views may have data otherwise 
-- e:		Found Offset, Found Position[1] - FoundPosition[4]
-- model_ID:	array of models id of each of four views
-- meas value:	array of 10 measurement values
-- Return FALSE if at least one GETVAR failed

BEGIN
e = $MOR_GRP[GN].$NILPOS
IF (VRN < 1) OR (VRN > 10 ) THEN
  	LogErrCr('Invalid Vision Register Number')
  	RETURN(FALSE)
ENDIF  

IF VRN = 10 THEN
	sreg = '10'
ELSE
	svreg        =	 CHR(48+VRN)
ENDIF
sViewNo        	 =	 CHR(48+ViewNo)

var_name = '$VR[' + svreg + '].$VIEW[' + sViewNo + '].$'
IF NOT Get_VR_Real(var_name + 'X', e.x) THEN
  	RETURN(FALSE)
ENDIF
IF NOT Get_VR_Real(var_name+ 'X', e.x) THEN
  	RETURN(FALSE)
ENDIF
IF NOT Get_VR_Real(var_name + 'Y', e.y) THEN
  	RETURN(FALSE)
ENDIF
IF NOT Get_VR_Real(var_name + 'Z', e.z) THEN
  	RETURN(FALSE)
ENDIF
IF NOT Get_VR_Real(var_name + 'W', e.w) THEN
  	RETURN(FALSE)
ENDIF
IF NOT Get_VR_Real(var_name + 'P', e.P) THEN
  	RETURN(FALSE)
ENDIF

IF NOT Get_VR_Real(var_name + 'R', e.R) THEN
  	RETURN(FALSE)
ENDIF
RETURN (TRUE)
END Get_VR_View

----------------------------------------------------------------------------------------------------------------------------
ROUTINE GET_VR_Model(VRN, ViewNo: INTEGER; model_ID :INTEGER) : BOOLEAN
-----------------------------------------------------------------------------------------------------------------------------

VAR
svreg        	 : STRING[5]
sview        	 : STRING[5]

BEGIN
Model_ID = 0
IF (VRN < 1) OR (VRN > 10 ) THEN
  	LogErrCr('Invalid Vision Register Number')
  	RETURN(FALSE)
ENDIF  

CNV_INT_STR(VRN,1,0,sreg)
CNV_INT_STR(ViewNo,1,0,sview)

var_name = '$VR[' + sreg + '].$VIEW[' + sview + '].$MODELID'
IF NOT Get_VR_Int(var_name, model_ID) THEN
  	RETURN(FALSE)
ENDIF

RETURN (TRUE)
END Get_VR_Model

----------------------------------------------------------------------------------------------------------------------------
ROUTINE GET_VR_Meas(VRN, MeasNo: INTEGER;  Meas : REAL) : BOOLEAN
-----------------------------------------------------------------------------------------------------------------------------

VAR
sVReg        	 : STRING[5]
sMeasNo       	 : STRING[5]

BEGIN
Meas = 0.0
IF (VRN < 1) OR (VRN > 10 ) THEN
  	LogErrCr('Invalid Vision Register Number')
  	RETURN(FALSE)
ENDIF  

CNV_INT_STR(VRN,1,0,sreg)
CNV_INT_STR(MeasNo,1,0,sMeasNo)

var_name = '$VR[' + sreg + '].$MEAS[' + sMeasNo + ']'
IF NOT Get_VR_Real(var_name, meas) THEN
  	RETURN(FALSE)
ENDIF

RETURN (TRUE)
END Get_VR_Meas

----------------------------------------------------------------------------------------------------------------------------
ROUTINE GET_VR_BarC(VRN: INTEGER; BarCode :STRING) : BOOLEAN
-----------------------------------------------------------------------------------------------------------------------------
--- Input
--	VRN vision register number
-- Output
--	Barcode value in the Vision register String value
--	Return false if bad VR number or GETVAR failed
VAR
sVReg        	 : STRING[5]

BEGIN
BarCode = ''
IF (VRN < 1) OR (VRN > 10 ) THEN
  	LogErrCr('Invalid Vision Register Number')
  	RETURN(FALSE)
ENDIF  

CNV_INT_STR(VRN,1,0,sreg)
var_name = '$VR[' + sreg + '].$STRING'

IF NOT Get_VR_str(var_name, BarCode) THEN
  	RETURN(FALSE)
ENDIF

RETURN (TRUE)
END Get_VR_BarC

-------------------------------------------------------------------------------------------
ROUTINE putposr (PrReg: INTEGER; PrIn : XYZWPREXT)
-------------------------------------------------------------------------------------------
  
BEGIN
IF prreg < 0 THEN
	IF prreg < (-PrTableSz) THEN
		LogErrCr('irMath - PRTABLE index too large')
		ok = FALSE
	else
		PRTABLE[(-1)*PrReg] = PrIn
	endif
else
	IF prreg > 0 THEN 
		SET_POS_REG(prreg,(PrIn),STATUS1,grp_no)
		ok = checkStatus(STATUS1,'iRMath - error writing to PR ',prreg)
	ENDIF
endif
END putposr

-------------------------------------------------------------------------------------------
ROUTINE PutIntReg (Reg : INTEGER;  Value: INTEGER)
-------------------------------------------------------------------------------------------

BEGIN
IF reg > 0 THEN
	SET_INT_REG(reg,value,STATUS1)
	ok = checkStatus(STATUS1,'iRMath - error writing integer to R ',reg)
ELSE
	IF reg < -PrTableSz THEN
		LogErrCr('irMath - Parameter Too Negative parameter')
		ok = FALSE
	Else
		IF reg = 0 THEN
			LogErrCr('irMath - Parameter cannot be 0')
			ok = FALSE
		else   
			inttable [( -1) * reg] = value
		ENDIF
	ENDIF
ENDIF
END PutIntReg

-------------------------------------------------------------------------------------------
ROUTINE PutRealReg (Reg : INTEGER;  Value: REAL)
-------------------------------------------------------------------------------------------

BEGIN
IF reg > 0 THEN
	SET_REAL_REG(reg,value,STATUS1)  
	ok = checkStatus(STATUS1,'iRMath - error writing real to R ',reg)
ELSE
	IF reg < -PrTableSz THEN
		LogErrCr('irMath - Parameter Too Negative parameter')
		ok = FALSE
	Else
		IF reg = 0 THEN
			LogErrCr('irMath - Parameter cannot be 0')
			ok = FALSE
		else   
			realtable [( -1) * reg] = value
		ENDIF
	ENDIF
ENDIF  
END PutRealReg
 
---------------------------------------------------------------------------
Routine CheckRingIdx(idx : Integer) : Boolean
---------------------------------------------------------------------------

BEGIN

IF ( idx <= $PH_ROSIP.$NUM_MEMBERS) and (idx > 0 ) THEN
	IF idx <> $PH_ROSIP.$MY_INDEX  THEN
		SELECT $PH_MEMBERS[idx].$STATE OF
			CASE(-1) : -- Not initialized
				LogErrCr('irMath Check Ring ID, Other robot not  inited')
 			CASE (0) : -- Offline
				LogErrCr('irMath Check Ring ID Other robot Off Line')
			CASE (1) : -- Online
				LogErrCr('irMath Check Ring ID, Other robot not  in Synch')
			CASE (2) : -- Synchronized
				Return (true)
		ENDSELECT
	ELSE
		logErrCr('irMath Check Ring ID, Ring ID is this robot') 	
	ENDIF
Else
	logErrCr('irMath Check Ring ID, Invalid Ring  index')  
ENDIF
Return (false)
END CheckRingIdx

----------------------------------------------------------------------------------------
ROUTINE Get_Var_Int(robot_id, Reg_num : INTEGER ): INTEGER
----------------------------------------------------------------------------------------
VAR

entry      	: INTEGER
STATUS3     	: INTEGER
int_data   	: INTEGER

BEGIN
int_data = 0
IF CheckRingIdx (Robot_id) THEN
	robot_name = $PH_MEMBERS[robot_id].$NAME 
	program_name = '\\' + Robot_Name + '\*numreg*'
	CNV_INT_STR(reg_num,1,0,sreg)
	var_name = '$NUMREG[' + sreg + ']'
	GET_VAR(entry, program_name, var_name, int_data, STATUS3)
	ok = CheckStatus(STATUS3,'Get_Var_Int Failed for Reg ',reg_num)
ENDIF
RETURN (int_data)
END Get_Var_Int

----------------------------------------------------------------------------------------------------------
ROUTINE MSet_Var_Int(ring_mask, Reg_num : INTEGER; int_data : INTEGER )
----------------------------------------------------------------------------------------------------------
VAR

idx, midx   : INTEGER

entry       : INTEGER
STATUS3     : INTEGER

BEGIN
idx = 1 
midx = 1
WHILE (idx <= $PH_ROSIP.$NUM_MEMBERS) AND (ok)  DO
	IF ((Midx AND Ring_mask) <> 0) THEN
		If CheckRingIdx(idx) THEN
			robot_name = $PH_MEMBERS[idx].$NAME 
			program_name = '\\' + Robot_Name + '\*numreg*'
			CNV_INT_STR(reg_num,1,0,sreg)
			var_name = '$NUMREG[' + sreg + ']'
			IF UNINIT (int_data) THEN int_data = 0;ENDIF
			SET_VAR(entry, program_name, var_name, int_data, STATUS3)
			ok = CheckStatus(STATUS3,'Set_Var_Int Failed for ',reg_num)
		ENDIF
	ENDIF       
	midx = midx*2
	idx = idx+1
ENDWHILE
END MSet_Var_Int

--------------------------------------------------------------------------------------
ROUTINE Get_Var_Real(robot_id, Reg_num : INTEGER ): REAL
--------------------------------------------------------------------------------------
VAR

entry		: INTEGER
STATUS3	: INTEGER
real_data	: REAL

BEGIN
real_data = 0.0
If CheckRingIdx(robot_id) THEN
	robot_name = $PH_MEMBERS[robot_id].$NAME 
	program_name = '\\' + Robot_Name + '\*numreg*'
	CNV_INT_STR(reg_num,1,0,sreg)
	var_name = '$NUMREG[' + sreg + ']'
	GET_VAR(entry, program_name, var_name, real_data, STATUS3)
	ok = CheckStatus(STATUS3,'Get_Var_Real Failed for reg ',reg_num)
ENDIF
RETURN (real_data)
END Get_Var_Real

-------------------------------------------------------------------------------------------------------
ROUTINE MSet_Vr_Real(ring_mask, Reg_num : INTEGER; real_data : REAL)
-------------------------------------------------------------------------------------------------------
VAR

entry		: INTEGER
STATUS3	: INTEGER
idx, midx	: INTEGER

BEGIN
idx = 1 
midx = 1
WHILE ( idx <= $PH_ROSIP.$NUM_MEMBERS) AND (ok) DO
	IF ((Midx AND Ring_mask) <> 0) THEN
		If CheckRingIdx(idx) THEN
			robot_name = $PH_MEMBERS[idx].$NAME 
			program_name = '\\' + Robot_Name + '\*numreg*'
			CNV_INT_STR(reg_num,1,0,sreg)
			var_name = '$NUMREG[' + sreg + ']'
			IF UNINIT (real_data) THEN real_data = 0 ; ENDIF
			SET_VAR(entry, program_name, var_name, real_data, STATUS3)
			ok = CheckStatus(STATUS3,'Set_Var_Real Failed for reg ',reg_num)
		ENDIF
	ENDIF       
	midx = midx*2
	idx = idx+1
ENDWHILE

END MSet_Vr_Real


------------------------------------------------------------------------------------------------
ROUTINE Get_Var_PR(robot_id, Reg_num : INTEGER ): XYZWPREXT
------------------------------------------------------------------------------------------------
VAR

entry		: INTEGER
STATUS3	: INTEGER
Dummy1Data	: ARRAY [16] OF INTEGER
posext_data	: XYZWPREXT
Dummy2Data	: ARRAY [16] OF INTEGER

BEGIN
posext_data = $MOR_GRP[grp_no].$NILPOS  
If CheckRingIdx(robot_id) THEN
	robot_name = $PH_MEMBERS[robot_id].$NAME 
	program_name = '\\' + Robot_Name + '\*posreg*'
	CNV_INT_STR(reg_num,1,0,sreg)
	CNV_INT_STR(grp_no,1,0,sgrp)
	var_name = '$POSREG[' + sgrp + ',' + sreg + ']'
	GET_VAR(entry, program_name, var_name, posext_data, STATUS3)
	ok = CheckStatus(STATUS3,'Get_Var_PR Failed for PR',reg_num)
ENDIF
RETURN (posext_data)
END Get_Var_PR

-----------------------------------------------------------------------------------------------------------------------
ROUTINE MSet_Var_PR(ring_mask, Reg_num : INTEGER ; posext_data : XYZWPREXT)
-----------------------------------------------------------------------------------------------------------------------

VAR

entry       : INTEGER
STATUS3     : INTEGER
idx, midx   : INTEGER

BEGIN
idx = 1 
midx = 1
WHILE (idx <= $PH_ROSIP.$NUM_MEMBERS) and (ok)  DO
	IF ((Midx AND Ring_mask) <> 0) Then
		If CheckRingIdx(idx) THEN
		
		
			robot_name = $PH_MEMBERS[idx].$NAME 
			program_name = '\\' + Robot_Name + '\*posreg*'
			CNV_INT_STR(reg_num,1,0,sreg)
			CNV_INT_STR(grp_no,1,0,sgrp)
			var_name = '$POSREG[' + sgrp + ',' + sreg + ']'
			IF UNINIT (posext_data) THEN posext_data = $MOR_GRP[grp_no].$NILPOS ; ENDIF
			SET_VAR(entry, program_name, var_name, posext_data, STATUS3)
			ok =CheckStatus(STATUS3,'Set_Var_PR Failed for PR ',reg_num)
		ENDIF
	ENDIF       
	midx = midx*2
	idx = idx+1
ENDWHILE
END MSet_Var_PR



----------------------------------------------------------------------------------------------------------------------------------
ROUTINE ReadParm(MaxParm: INTEGER; data_type,int_value : ARRAY OF INTEGER;--
real_value: ARRAY OF REAL; string_value: ARRAY OF STRING --
no_of_data : INTEGER): BOOLEAN
-----------------------------------------------------------------------------------------------------------------------------------
VAR
i 		: INTEGER
done 		: BOOLEAN
Status4 	: INTEGER
ok 		: BOOLEAN

BEGIN
  
-- initialize the data types

FOR i = 1 TO MAXPARM DO
	data_type[i] = 0  -- initialize
	int_value[i] = 0
	real_value[i] = 0
	string_value[i]=''
ENDFOR

ok = TRUE
done=FALSE
STATUS1 = 0
i = 0
no_of_data = 0

--write tpdisplay(cr,cr,'Parameters ')

WHILE (STATUS1 = 0) AND (NOT done) AND (i < MAXPARM) DO
	i = i + 1
	GET_TPE_PRM(i, data_type[i], int_value[i],real_value[i],string_value[i],Status1)
	IF Status1 = 0 THEN
		no_of_data = no_of_data + 1
	ELSE
		IF Status1 = 17042  THEN -- "ER17042 ROUT-142 Parameter doesn't exist" 
			Status1 = 0
			done = TRUE
		ELSE
			ok =CheckStatus(Status4,'GET_TPE_PRM Failed for parm ',i)
		ENDIF
	ENDIF
ENDWHILE
RETURN(ok) 
END ReadParm
 
-----------------------------------------------------------------------------------------
ROUTINE capitalize ( RawString : STRING) :STRING
-----------------------------------------------------------------------------------------
VAR
I,J,M		: INTEGER
TempStr	: STRING[128]
BEGIN

M = STR_LEN(RawString)
I = 0
TempStr = ''
WHILE I < M DO
	I = I +1
	J = ORD(RawString,I)
	-- capitalize small letters
	IF (96 < J ) AND (J < 123) THEN J = J -32; ENDIF
	TempStr = TempStr + CHR(J)
ENDWHILE
	
RETURN(TempStr)
END capitalize

------------------------------------------------------------------------------------------------------------
ROUTINE setn(FC : INTEGER; strFC, strparm : STRING)
------------------------------------------------------------------------------------------------------------
BEGIN
fcNames[fc] = strfc
fcParms[fc] = strparm
END setn

------------------------------------------------------------------------------------------------------------
ROUTINE InitFc
------------------------------------------------------------------------------------------------------------
BEGIN
	setn(fcMultiply,  'MULTIPLY' , '0,0,P1,p2,p3')
	setn(FcInverse,  'INVERSE',  '0,0,P1,[p2]')
	setn(FcClear , 'CLEAR' , '0,0,P1')
	setn(FcInRange,'INRANGE'  , 'R1,0,p1')
	setn(FcDot, 'DOTPRODUCT' , '0,R2,p1,p2')
	setn(FcCross , 'CROSSPRODUCT'  , '0,0,P1,p2,p3')
	setn(FcFrame , 'FRAMEOXY' ,'0,0,P1,p2,p3,p4')
	setn(FcDistance , 'DISTANCE' ,'0,R2,p1,p2')
	setn(FcArctan , 'ARCTAN' , '0,R2,p1,[p2]')
	
	setn(FcCartesian, 'CARTESIAN' ,'0,0,P1')
	setn(FcMovePReg, 'MOVEPR' ,'0,0,P1,p2')
	setn(FcPts2Line, 'POINTS2LINE' , '0,0,P1,p2,p3')
	setn(FcOX2Frame , 'FRAMEOX' ,'0,0,P1,p2,p3')
	setn(FcOXZ2Frame,  'FRAMEOXZ' ,'0,0,P1,p2,p3,p4')
	setn(FcPts2Pt, 'PTS2PT', '0,0,p1,p2,p3,p4,[P5],[P6],P7')
	setn(FcMove2Pt, 'MOVE2PT'  ,'0,r2,P1,p2,p3')
	setn(FcRMove, 'MOVER','0,R1,r2')
	setn(FcIMove, 'MOVEI','0,0,I1,i2')
	
	setn(FcSetGrpMsk, 'SETGROUPMASK','0,0,R1,r2,r3')
	setn(FcPowers, 'X2YTH','0,0,R1,r2,r3')
	setn(FcGetVarI,'GETVARI','0,0,I1,i2,ringId')
	setn(FcSetVarI, 'SETVARI' ,'0,0I1,i2,ringMsk')
	setn(FcGetVarR , 'GETVARR'  ,'0,0,R1,r2,ringId')
	setn(FcSetVarR , 'SETVARR' ,'0,0,R1,r2,ringMsk')
	setn( FcGetVarPR, 'GETVARPR'  ,'0,0,P1,p2,ringId')
	setn( FcSetVarPR, 'SETVARPR'  ,'0,0,P1,p2.ringMsk')
	setn(FcPXLN2PT, 'LINEXPLANE'  ,'0,0,P1,p2,p3')
	
	setn(FcReQueue, 'REQUEUE' ,'0,0,q1,vr2')
	setn(FcHelp , 'HELP'  ,'	0)')
	setn( fcLogOpen, 'LOGOPEN'  ,'0,"FileName"')
	setn(fcLogClose, 'LOGCLOSE'  ,'0')	
	setn(fcLogDate , 'LOGDATETIME'  ,'0')
	setn(fcLogPR , 'LOGPR' ,'0,0,p1,[del],[hires]')
	setn(fcLogR, 'LOGR', '0,0,r1,[del],[hires]')
	setn(fcLogI, 'LOGI'  ,'0,0,i1,[del]')
	setn( fcLns2Fr, 'LINES2FRAME'  ,'0,0,P1,p2,p3,p4,p5')
	
	setn(fcLogS, 'LOGSTR'  ,'0,str,0,[del] ')
	setn(fcSine, 'SIN'  ,'0,R1,r2 ')
	setn( fcCos , 'COS' ,'0,R1,r2')
	setn( fcTangent, 'TAN' 	,'0,R1,p1,[p2]') 
	setn(fcPls2Line, 'PLANES2LINE'  ,'0,0,P1,p2 p3')
	setn(   fcLns2Pt, 'LINES2POINT','0,0,p1,p2,[P3],[P4],P5') 
	setn(  fcComments, 'COMMENTS','"Task",0,CRflg') 
	setn(  fcBackLash, 'BACKLASH','0,r,P1,p2') 
	setn(  fcPoint2line, 'POINT2LINE','0,R,P1,p2,p3,p4')  
	
	setn(   fcSaveVars, 'SAVEVARS','0')
	setn( fcLoadVars,'LOADVARS'	,'0')
	setn(  fcDeleteFile, 'DELETEFILE','0,"FileName"' )
	setn(  fcQuickTool, 'QUICKTOOL','0,0,P1[,UTn,UT0]') 
	setn(   FcSphereLine, 'SPHEREXLINE','N,D,P1,e1,e2,ctr,r,[P2]') 
	setn( fcOZ2Frame,'FRAMEOZ','0,0,Fpr,Opr,Zpr')
	setn(fcBestPlane,'BESTPLANE','0,0,Frame,first,last')
	setn(fcBestCircle,'BESTCIRCLE','0,0,Frame,first,last')
	setn(fcCarrousel,'CARROUSEL','0,0,Frame,first,last')
END InitFc

------------------------------------------------------------------------------------------------------------
Routine GetFunction ( S : STRING) : INTEGER
------------------------------------------------------------------------------------------------------------
VAR
	done	: Boolean
	i	: INTEGER
BEGIN
IF UNINIT (fcNames[1]) THEN
	Initfc
ENDIF

i = 0
done = false
WHILE (Not done) and (i < MAXFUNCTIONS) DO
	i = i + 1
	IF fcNames[i] = s THEN
		done = true
	endif
ENDWHILE
IF NOT done THEN
	i = 0
ENDIF
RETURN (i)
END GetFunction
-------------------------------------------------------------------------------------------
ROUTINE Getnparms
-------------------------------------------------------------------------------------------

VAR
i : INTEGER
BEGIN
StrName = ''
fc = int_value[1]
streg    = int_value[2]
streg2  = int_value[3]
pr1reg = int_value[4]
pr2reg = int_value[5]
pr3reg = int_value[6]
pr4reg = int_value[7]
pr5reg = int_value[8]
pr6reg = int_value[9]
pr7reg = int_value[10]

i = 0
While (i <  no_of_data) AND (ok)  DO
	i = i + 1
	IF data_type[i] <> PARM_INTEGER THEN
		IF (i =1) AND ( Data_type[i] = PARM_STRING) THEN
			fc = GetFunction(capitalize(string_value[i]) )
		ELSE
			IF (i =3) AND ( Data_type[i] = PARM_STRING) THEN
				strName = String_value[i]
			ELSE
				ok =false
				LogErrCr('iRMath - Wrong Type Parameter[')
				LogErrI(i)
				LogErrS(']')
			endif
		ENDIF
	ENDIF
ENDWHILE

END getnparms



-------------------------------------------------------------------------------------------
ROUTINE tpHelp(page:INTEGER)
-------------------------------------------------------------------------------------------
VAR
	j	: INTEGER
BEGIN
IF UNINIT (fcNames[1] ) THEN
	Initfc
ENDIF

SELECT page OF
	CASE (1):
		WRITE TPDISPLAY(CR)
	    	FOR j = fcMultiply TO fcARCTAN DO
		  	WRITE TPDISPLAY (CR, fcnames[j] + '/' , j , ',' + fcparms[j] )
		ENDFOR
	  	FORCE_SPMENU(TP_PANEL, SPI_TPUSER , 1) 
	  	
	    CASE(2):
	    	FOR j = fcCartesian TO fcIMove DO
		  	WRITE TPDISPLAY (CR, fcnames[j] + '/' , j , ',' + fcparms[j] )
		ENDFOR
	  	FORCE_SPMENU(TP_PANEL, SPI_TPUSER , 1) 
	  	
	    CASE(3):
	    	FOR j = fcSetGrpMsk TO FcPXLN2PT DO 
		  	WRITE TPDISPLAY (CR, fcnames[j] + '/' , j , ',' + fcparms[j] )
		ENDFOR
	  	FORCE_SPMENU(TP_PANEL, SPI_TPUSER , 1) 
	  
	    CASE(4):
	    	FOR j = fcReQueue TO fcLns2Fr DO
		  	WRITE TPDISPLAY (CR, fcnames[j] + '/' , j , ',' + fcparms[j] )
		ENDFOR
	  	FORCE_SPMENU(TP_PANEL, SPI_TPUSER , 1) 
	  
	    CASE (5):
	    	FOR j = fcLogS TO fcPoint2line DO
		  	WRITE TPDISPLAY (CR, fcnames[j] + '/' , j , ',' + fcparms[j] )
		ENDFOR
	  	FORCE_SPMENU(TP_PANEL, SPI_TPUSER , 1) 
	  
	    CASE (6):  
	    	FOR j = fcSaveVars TO MAXFUNCTIONS DO
		  	WRITE TPDISPLAY (CR, fcnames[j] + '/' , j , ',' + fcparms[j]  )
		ENDFOR
	  	FORCE_SPMENU(TP_PANEL, SPI_TPUSER , 1) 
	    ELSE:
ENDSELECT
END tphelp


-----------------------------
ROUTINE irHelpExt
-----------------------------
BEGIN

FORCE_SPMENU(TP_PANEL, SPI_TPUSER , 1) 
IF UNINIT (help_page) THEN help_page = 0; ENDIF
help_page = help_page + 1
IF help_page > MAX_HELP THEN
	help_page = 1
ENDIF
tpHelp(help_page)
END irHelpExt

----------------------------------------------------------------------------------
ROUTINE irComment(NameIn: STRING; Header :INTEGER)
----------------------------------------------------------------------------------
VAR
dummyint 	: INTEGER

BEGIN
Prog_name = NameIn
Comment    = ''
GET_ATTR_PRG(Prog_Name, AT_COMMENT, dummyInt, Comment, STATUS1) 

SELECT Status1 OF
	CASE(7073): --7073 The PROGRAM specified IN program_name does NOT exist 
		Comment = 'Does Not Exist'
	CASE(0): -- OK
	ELSE:
		-- 17027 string_value is NOT large enough TO contain the attribute STRING. The value has been truncated TO fit. 
		-- 17033 attr_number has an illegal value 
		Comment = 'Get_ATTR failed'
ENDSELECT
		
IF header= 1 THEN
	WRITE TPDISPLAY (CR,CR,'Program Name ---:-Comment -------')
ENDIF
			
WRITE TPDISPLAY (CR,Prog_Name::16,': ',Comment)
FORCE_SPMENU(TP_PANEL, SPI_TPUSER , 1) 
END irComment
  
-------------------------------------------------------------------------------------------
-- main
-------------------------------------------------------------------------------------------

BEGIN

IF NOT ReadParm(MAX_PARAMS, data_type, int_value, real_value, string_value, no_of_data ) THEN
	 LogErrCr('irHelp: Read Parameters failed')
	ABORT
ENDIF
fc = 0
IF data_type[1] = PARM_STRING THEN
	fc = GetFunction (  capitalize ( string_value[1]) )
ELSE
	fc = int_value[1]
ENDIF
first_entry = int_value[2]

SELECT fc OF 
	CASE (Fchelp):
	    irHelpExt
		  
	CASE(fcComments): 	--43 call irhelp(43,"TaskName")[,1])
				-- Fc, task Name,, Print header if 1
		Prog_Name   = '********'
		IF STRING_VALUE[2] = '' THEN
			Comment   = 'ARG[2] not a Program Name'
		ELSE
			Prog_name = STRING_VALUE[2]
			irComment(Prog_name,int_value[4])
		ENDIF
  
	CASE(  fcSaveVars) : --	= 46 -- save irmath vars to irmath00.vr
		KCL ('SAVE VARS irmath00 = irmath ', STATUS1) 
		IF status1 <> 0 THEN
			WRITE TPERROR (CR,'Save failed, status = ',status1)
		ELSE			
			WRITE TPERROR (CR,'Saved to irmath00.vr')
		ENDIF
		
	CASE(  fcLoadVars) : --	= 47	load irmath vars from irmath00.vr
		KCL ('LOAD VARS irmath00 ', STATUS1) 
		IF status1 <> 0 THEN
			WRITE TPERROR (CR,'Load failed, status = ',status1)
		ELSE			
			WRITE TPERROR (CR,'irmath00.vr Loaded')
		ENDIF
		
	CASE( fcDeleteFile): --48 call irhelp(48,"FileName")
		IF STRING_VALUE[2] = '' THEN
			WRITE TPERROR (CR,'Arg [2] not a file name')
		ELSE
			STATUS1    = 0 
			strCmd = 'DELETE FILE ' +  STRING_VALUE[2] + ' YES'
			KCL (strCmd, STATUS1) 
			SELECT Status1 OF
				CASE(0):		
					WRITE TPERROR (CR,STRING_VALUE[2] + ' DELETED')
				CASE (2014):
					WRITE TPERROR (CR,STRING_VALUE[2] + ' FILE NOT FOUND')
				ELSE:	
					WRITE TPERROR (CR,'Delete File failed, status = ',status1,'   ')
			ENDSELECT
		ENDIF
	ELSE:
		 LogErrCr('irHelp: First Parameter not Valid')
		ABORT
		
ENDSELECT

END irHelp




