--    This material is the joint property of Fanuc Robotics Corporation  and
--    FANUC  LTD  Japan,  and  must  be  returned  to  either Fanuc Robotics
--    Corporation or FANUC LTD Japan immediately upon request.  This  material
--    and   the  information  illustrated  or  contained  herein  may  not  be
--    reproduced, copied, used, or transmitted in whole or in part in any  way
--    without the prior written consent of both Fanuc Robotics and FANUC.
--
--             All Rights Reserved
--             Copyright (C)   1992
--             Fanuc Robotics Corporation
--             FANUC LTD Japan
--
--             Karel is a registered trademark of
--             Fanuc Robotics Corporation
--    +
--    Program:   atcustom
--
--    Description:
--
--    Language: KAREL
--
--    Source File:   atcustom.kl   28-APR-05   10:05AM
--
--    Author: DRESLISM
--            Fanuc Robotics Corporation
--            3900 W. Hamlin
--            Rochester Hill, Michigan    48309
--
--
--
--
-- General Information:
--  Shell Area "Hooks"/calls
--        * Power Up **
--        * Entry to AUTO (CR keyswitch) **
--        * Exit from AUTO (CR keyswitch) **
--        * Error handling entry Only on Spot+
--        * Error handling exit  Only on Spot+
--        * Before execution of each Style **
--        * Before resume of each style **
--        * After end execution of each Style **
--        * shell polling? ** Only on Spot+
--        * RESET pressed to clear shell polling flags	**
--
-- For above to work, $shell_cfg.$custom bit 2 must be set.
--                    bit 1 set means don't display custom softpanel
--
--    Modification History:
--    1/31/16   RRK implemented the at_Custom from GMPT atCustom
--    2016-03-15: marchaka - added call to set_std_cold for wizard configuration on powerup
--    5/26/2016 RRK added array for programs atcustom can start
--              also added vacuum and PP errors to restart the controller
--    2016/11/08 marchaka Modified SPR gun open and close logic to work for G4
--    2016/11/12 marchaka Modified SPR gun open and close logic to look at
--                        current equipment and gun to determine which gun to jog.
--    2-4-17     R.KOsaski Modified for the custom menus improvements
--    2017/02/05 marchaka Use Karel variables for DI[6], DI[93] and DI[157].
--    2-17-17    R.Kosaski Had to INITIALIZE custo active vars in custpowerup routine
--    2-24-17    R.Kosaski Change MHND-104 alarm to APPL so user may knows more details
--    3-05-17    R.Kosaski Added code so GMCFG file get comments at powerup along with MENU vr files
--    4-27-17    R.Kosaski Added code for WE robot to ensure monitoring variable is enabled in "custpowerup" routine
--    6-24-17    R.Kosaski Edited code for WE robot to ensure monitoring variable is enabled in "custpowerup" routine
--    2-28-18    marchaka  Add ArcTool variable file names to CmntCnfgFile routine.
--    2018/04/03 marchaka  Reset ZDT alarm variables every power cycle.
--    2018/05/04 marchaka  Reset $slsetup[x].enb_autoffst to FALSE every power cycle
--    2018/06/27 Kosaskrr  Reset $ATCELLSETUP.$HOME_IO_PRG to HOME_IO every power cycle if not set correctly
--    2018/09/10 marchaka  Do not allow $dcs_cfg.$pioc_dsp if DCS I/O connect write protection is being used.
--    2018/10/11 marchaka  Do not allow setting of variable in dispense_var routine if the read of the variable failed.
--                         The read failure error was being posted but it was not preventing the variable from getting set.
--    2018/10/26 marchaka  For virtual robots, do not write protect the DCS I/O connect map and hide it.
--    2019/08/03 marchaka  Change manual intervention output to get turned off to the user digital output.
--    2019/09/11 schoensm  V8.33P08 added multigroup motion awareness prompts.
--    2019/03/16 schoensm  V8.33P09 added code for $FSAC settings. 
--    2020/11/03 schoensm  V8.33P10 added gmcfgmig settings 
--    2020/11/10 marchaka  V8.33P10 removed gmcfgmig VAR settings.  VAR file doesn't show up on a SpotTool+ robot.      
------------------------------------------------------------------
PROGRAM ATCUSTOM
------------------------------------------------------------------
%RWACCESS
%STACKSIZE = 1024
%NOLOCKGROUP
%SYSTEM
%noabort = error + command
%nopause = command + error + tpenable
%nobusylamp
%INVISIBLE
%COMMENT='Custom Shell'


%ENVIRONMENT ATCLDEF
%ENVIRONMENT REGOPE
%ENVIRONMENT TPE
%ENVIRONMENT swgdef  --need this for SPOTEQ
%ENVIRONMENT sysdef
%ENVIRONMENT multi
%ENVIRONMENT uif
%ENVIRONMENT ioblt    -- iovalset
%ENVIRONMENT sycedef  --  $MSKKEY
%ENVIRONMENT iosetup   --need this for SET_PORT_CMT

%INCLUDE kliotyps    --need this for IO_FLAG
%INCLUDE KLEVCCDF   -- needed for the TPERROR

--%INCLUDE atconst
--%INCLUDE atdcatsh
%INCLUDE klevutil
--%include atdcsoft

-- SOP I/O constants
%INCLUDE kliosop

-- TP I/O constants
%INCLUDE klevkeys

-- RS4 Specific Variables
%INCLUDE gmevrs4io
%INCLUDE SWEVSHLL --Offline IOVALSET
%INCLUDE gm_var    --GM variables

 TYPE
  Setup_Prog FROM ATCUSTOM = STRUCTURE -- Program that need start up
    NeedToRun      : BOOLEAN -- True or False for Program needs to run or be checked
    NeedForProd    : BOOLEAN -- True or False for Program needed for production, if cant start need to resolve
    Prog_Name      : STRING[16] -- String Of programs that can be checked for Running
    FailedToStrt   : INTEGER -- used for the times the program was attempted to start
 ENDSTRUCTURE
-- 3-5-17 Rkosaski addded
TYPE
  Setup_Cmnts  = STRUCTURE -- Wizard Setup configuration files comments
    vr_filename   : STRING[12] -- Used for program name to setup comment on
    prog_comment  : STRING[16] -- Used for comment to put on VR_FILENAME
  ENDSTRUCTURE

CONST
  Revision = '2020-11-10'

  -- Errors:
  ER_WARN = 0
 -- WARN_MSG = 41104   -- MHND-104 WARN %s
  
%INCLUDE etdcmhnd -- needed for the error codes declaration for MH gripper errors and handling
%INCLUDE GMCNSTNT -- Used for the constants of MFG_AREA vars and other GM constants

VAR
  Cur_Revision : STRING[32] -- Used for knowing the current version if this program
  g_tmpfile: FILE
  hotstart     in dram  FROM ATSHELL: BOOLEAN
  awa_prevgrp                          : INTEGER
  awa_prevmode                         : INTEGER
--debug IN CMOS: BOOLEAN
  allow_nostrk IN CMOS FROM SWSHELL: BOOLEAN
  skip_1more	IN CMOS FROM SWAXTASK: BOOLEAN
  cont_next IN CMOS FROM FFR_OPTN: BOOLEAN
  ok_flag   IN SHADOW FROM CUSTOOK : BOOLEAN
  yn_flag   IN SHADOW FROM CUSTOYN : BOOLEAN
  lst_flag  IN SHADOW FROM CUSTOLST : BOOLEAN

  prmpt_back    IN SHADOW FROM GMCUSTO  : BOOLEAN
  dnet64size    IN SHADOW FROM GMCUSTO  : BOOLEAN

  WEMontrPurge,   -- Used for result of Sysvar $RI_AIRPURGE[1] used for WE robot(H731).RK
  ReEnbWEMontr,   -- Used for if WE monitoring is disabled on WE, should it automatically be reenabled. RK
  WEChkStart ,    -- Used for if checking WE settings every cycle start in prestart
  WEChkReset ,    -- Used for if checking WE setting every reset should occur in custm_reset routine
  WEChkifSim,     -- Used for if checking WE setting for simulated inputs

  User_Aborted  , -- Used for identifying if the program was aborted or finished
  Rcvry_Active IN SHADOW : BOOLEAN -- Used for if the user recovery is being executed to start CH

  ansd_yn,      -- Used as the answer the user entered in Y/N Menu
  yn_answer     IN SHADOW FROM custoyn: INTEGER
  ansd_ok,      -- Used as the answer the user entered in OK Menu
  ok_answer     IN SHADOW FROM custook: INTEGER
  ansd_lst,     -- Used as the answer the user entered in List Menu
  lst_answer    IN SHADOW FROM custolst : INTEGER

  RepostTimer,  -- used as a timer to repost reset to return to user
  RepostTime    IN SHADOW : INTEGER -- used as a value to repost return to User

  SHELL_ERR_R IN CMOS : INTEGER -- Used for data register # to use as interface to TP
                                -- when PRE Cyle checks enabled
  MaxStrtFails IN SHADOW : INTEGER -- this is the maximum number of failures a "prgs2run" can fail

  last_error FROM ATERRJOB :INTEGER -- used to know what error is trying to be processed

  task_name   : STRING [16]  -- Current Tasks Name To Check Status
 -- entry        : INTEGER -- Variable # return from GET VAR built-in
  task_num     IN CMOS : INTEGER
  gm_status    : INTEGER
  status       : INTEGER
  entry,                  -- used in the GET_VAR routine
  value_int    : INTEGER
  task_status  : INTEGER
  value_str   : STRING[20]
  tp_state      : BOOLEAN

   FileComments IN SHADOW FROM ATCUSTOM :ARRAY[35] OF Setup_Cmnts  -- Wizard Configuration File Comments

   Prgs2RunCell IN SHADOW FROM ATCUSTOM :ARRAY[20] OF Setup_Prog -- Programs ran/check on Cycle Start for ALL robots
   Prgs2RunGMPT IN SHADOW FROM ATCUSTOM :ARRAY[20] OF Setup_Prog -- GMPT Programs ran/check on Cycle Start
   Prgs2RunPRS  IN SHADOW FROM ATCUSTOM :ARRAY[10] OF Setup_Prog -- Press Programs ran/check on Cycle Start
   Prgs2RunBS   IN SHADOW FROM ATCUSTOM :ARRAY[10] OF Setup_Prog -- Body Shop Programs ran/check on Cycle Start
   Prgs2RunPS   IN SHADOW FROM ATCUSTOM :ARRAY[10] OF Setup_Prog -- Paint Shop Programs ran/check on Cycle Start

  tp_curr_eq    IN CMOS FROM SWSHELL: INTEGER
  tp_curr_gun   IN CMOS FROM SWSHELL: INTEGER

  gmsafeioprot  IN SHADOW FROM ATCUSTOM: BOOLEAN --monitor use of DCS I/O write protection

  frvrc  IN CMOS from atshell   :  BOOLEAN 
  
  multiarm_jg  IN SHADOW FROM GMCUSTO  : BOOLEAN
  multiarm_r1  IN SHADOW FROM GMCUSTO  : STRING[16]
  multiarm_r2  IN SHADOW FROM GMCUSTO  : STRING[16]
  
%INCLUDE GMCFGCEL -- used for the MFG_AREA variable
%INCLUDE klrdutil -- Need for the CLR_STND_SCR routine
%INCLUDE atrdcstm
%INCLUDE gmrdutil

ROUTINE Post_Custlst FROM CUSTOLST
ROUTINE Post_Custok  FROM CUSTOOK
ROUTINE Post_Custyn  FROM CUSTOYN
ROUTINE set_std_cold FROM gmmain1
ROUTINE MH_Rcvy_Done(p_option:INTEGER) FROM GMERRCVY -- has Post recovery for MH Faults
ROUTINE fsac_1 FROM GMFSAC
ROUTINE fsac_2 FROM GMFSAC
-- --------------------------------------------------------------------
-- ROUTINE:     CH_TASKS
-- TITLE:       Check to Programs For Status
--
-- DESCRIPTION: This routine Restarts a Paused Task or Restarts a Aborted Tasks
--
--
-- PARAMETERS: [IN]  task_name to check upon reciving the cycle start &
--                   group_number is the group for the robot to check if
--                   it is ready
--             [OUT] TRUE OR FALSE Based on whether the program was restarted
-- --------------------------------------------------------------------

ROUTINE ch_tasks (task_name:string):BOOLEAN
VAR

loaded,
initialized : BOOLEAN

BEGIN
  task_status = 0 -- if task was not ever ran task_status is uninit.

  loaded = FALSE
  initialized = FALSE

 IF UNINIT(task_name) THEN
   POST_ERR(38000, 'ch_tasks was Passed UNINIT prog name', 0, 0) --
   RETURN(FALSE)
 ENDIF

LOAD_STATUS(task_name,loaded, initialized)

  IF loaded = FALSE THEN
    POST_ERR(38000, task_name +' is NOT LOADED', 0, 0) --
    RETURN(FALSE)
  ENDIF

REPEAT --

    task_num = 0

  GET_TSK_INFO(task_name,task_num,TSK_STATUS,task_status,value_str,status) --
    IF status <> 0 THEN
      IF status = 3016 THEN -- task was not ran
        RUN_TASK(task_name,0,FALSE,FALSE,0,status)
        IF status <>0 THEN
          POST_ERR(38000,'FAILED RUN TASK ' + task_name, status,0) --
          RETURN(FALSE)
        ENDIF
      ELSE
        POST_ERR(38000,'FAILED GET TASK INFO ' + task_name, status,0) --
        RETURN(FALSE)
      ENDIF
    ELSE -- when program not running abort it and restart it
      IF task_status = PG_RUNNING THEN
        RETURN(TRUE)
      ENDIF
        IF task_status = PG_PAUSED THEN -- Programs should be aborted in case of Program bugs cause it to pause
          ABORT_TASK(task_name,TRUE,TRUE,status)
          IF status <> 0 THEN
            POST_ERR(38000, task_name +' FAILED TO ABORT', status, 0) --
            DELAY 2000
          ENDIF
        ENDIF
    ENDIF

UNTIL (task_status = PG_ABORTED) OR (status = 3016) --

  RUN_TASK(task_name,0,FALSE,FALSE,0,status)
    IF status <> 0 THEN
      POST_ERR(38000,task_name +' FAILED TO START', status,0) --
      DELAY 2000
      RETURN(FALSE)
    ENDIF
  RETURN(TRUE)

END ch_tasks
-----------------------------------------------------------------------------
ROUTINE ChkPrgs2Run
-- PURPOSE: to check if shop specific programs that should be ran need to be started
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
VAR

i :INTEGER

BEGIN

Cur_Revision = Revision --

IF UNINIT(MaxStrtFails) THEN  -- if after this attempts to start need to set not to
  MaxStrtFails = 10
ENDIF
-- Set up all workcell specific
FOR i = 1 TO (ARRAY_LEN(Prgs2RunCell)) DO
  IF UNINIT(Prgs2RunCell[i].NeedToRun) THEN
    Prgs2RunCell[i].NeedToRun = FALSE
  ENDIF
  IF UNINIT(Prgs2RunCell[i].Prog_Name) THEN
    Prgs2RunCell[i].Prog_Name = ''
  ENDIF
  IF UNINIT(Prgs2RunCell[i].FailedToStrt) THEN
    Prgs2RunCell[i].FailedToStrt = 0
  ENDIF
  IF UNINIT(Prgs2RunCell[i].NeedForProd) THEN
    Prgs2RunCell[i].NeedForProd = FALSE
  ENDIF
ENDFOR -- Make sure all CELL programs to Run have been setup
IF Prgs2RunCell[1].Prog_Name = '' THEN -- needed for the Analog for Baluff Block
  Prgs2RunCell[1].Prog_Name = 'CNVRTGIN' -- this can be overwritten if needed later
ENDIF


FOR i = 1 TO (ARRAY_LEN(Prgs2RunGMPT)) DO
  IF UNINIT(Prgs2RunGMPT[i].NeedToRun) THEN
    Prgs2RunGMPT[i].NeedToRun = FALSE
  ENDIF
  IF UNINIT(Prgs2RunGMPT[i].Prog_Name) THEN
    Prgs2RunGMPT[i].Prog_Name = ''
  ENDIF
  IF UNINIT(Prgs2RunGMPT[i].FailedToStrt) THEN
    Prgs2RunGMPT[i].FailedToStrt = 0
  ENDIF
  IF UNINIT(Prgs2RunGMPT[i].NeedForProd) THEN
    Prgs2RunGMPT[i].NeedForProd = FALSE
  ENDIF
ENDFOR -- Make sure all GMPT programs to Run have been setup

FOR i = 1 TO (ARRAY_LEN(Prgs2RunPRS)) DO
  IF UNINIT(Prgs2RunPRS[i].NeedToRun) THEN
    Prgs2RunPRS[i].NeedToRun = FALSE
  ENDIF
  IF UNINIT(Prgs2RunPRS[i].Prog_Name) THEN
    Prgs2RunPRS[i].Prog_Name = ''
  ENDIF
  IF UNINIT(Prgs2RunPRS[i].FailedToStrt) THEN
    Prgs2RunPRS[i].FailedToStrt = 0
  ENDIF
  IF UNINIT(Prgs2RunPRS[i].NeedForProd) THEN
    Prgs2RunPRS[i].NeedForProd = FALSE
  ENDIF
ENDFOR -- Make sure all Press programs to Run have been setup

FOR i = 1 TO (ARRAY_LEN(Prgs2RunBS)) DO
  IF UNINIT(Prgs2RunBS[i].NeedToRun) THEN
    Prgs2RunBS[i].NeedToRun = FALSE
  ENDIF
  IF UNINIT(Prgs2RunBS[i].Prog_Name) THEN
    Prgs2RunBS[i].Prog_Name = ''
  ENDIF
  IF UNINIT(Prgs2RunBS[i].FailedToStrt) THEN
    Prgs2RunBS[i].FailedToStrt = 0
  ENDIF
  IF UNINIT(Prgs2RunBS[i].NeedForProd) THEN
    Prgs2RunBS[i].NeedForProd = FALSE
  ENDIF
ENDFOR -- Make sure all Body Shop programs to Run have been setup

FOR i = 1 TO (ARRAY_LEN(Prgs2RunPS)) DO
  IF UNINIT(Prgs2RunPS[i].NeedToRun) THEN
    Prgs2RunPS[i].NeedToRun = FALSE
  ENDIF
  IF UNINIT(Prgs2RunPS[i].Prog_Name) THEN
    Prgs2RunPS[i].Prog_Name = ''
  ENDIF
  IF UNINIT(Prgs2RunPS[i].FailedToStrt) THEN
    Prgs2RunPS[i].FailedToStrt = 0
  ENDIF
  IF UNINIT(Prgs2RunPS[i].NeedForProd) THEN
    Prgs2RunPS[i].NeedForProd = FALSE
  ENDIF
ENDFOR -- Make sure all Paint Shop programs to Run have been setup


-- GO through all the programs and any that should be ran ensure are running
-- Loop though and if ANY program is told to be used, then try to run it
FOR i = 1 TO (ARRAY_LEN(Prgs2RunCell)) DO
  IF (Prgs2RunCell[i].NeedToRun) THEN
    IF ch_tasks(Prgs2RunCell[i].Prog_Name) THEN
      Prgs2RunCell[i].FailedToStrt = 0
    ELSE
      Prgs2RunCell[i].FailedToStrt = Prgs2RunCell[i].FailedToStrt + 1
    ENDIF

  ENDIF
ENDFOR -- Make sure all CELL programs to Run are checked to be running

SELECT (mfg_area) OF --
  CASE (mfg_area_bs):  -- Body Shop
    FOR i = 1 TO (ARRAY_LEN(Prgs2RunBS)) DO
      IF Prgs2RunBS[i].NeedToRun THEN
        IF ch_tasks(Prgs2RunBS[i].Prog_Name) THEN
          Prgs2RunBS[i].FailedToStrt = 0
        ELSE
          Prgs2RunBS[i].FailedToStrt = Prgs2RunBS[i].FailedToStrt + 1
        ENDIF

      ENDIF
    ENDFOR -- Make sure all Body Shop programs to Run are checked to be running

  CASE (mfg_area_ps):  -- Press Shop
    FOR i = 1 TO (ARRAY_LEN(Prgs2RunPRS)) DO
      IF(Prgs2RunPRS[i].NeedToRun) THEN
        IF ch_tasks(Prgs2RunPRS[i].Prog_Name) THEN
          Prgs2RunPRS[i].FailedToStrt = 0
        ELSE
          Prgs2RunPRS[i].FailedToStrt = Prgs2RunPRS[i].FailedToStrt + 1
        ENDIF

      ENDIF
    ENDFOR -- Make sure all Press programs to Run are checked to be running

  CASE (mfg_area_pt):  -- Powertrain
    FOR i = 1 TO (ARRAY_LEN(Prgs2RunGMPT)) DO
      IF (Prgs2RunGMPT[i].NeedToRun) THEN
        IF ch_tasks(Prgs2RunGMPT[i].Prog_Name) THEN
          Prgs2RunGMPT[i].FailedToStrt = 0
        ELSE
          Prgs2RunGMPT[i].FailedToStrt = Prgs2RunGMPT[i].FailedToStrt + 1
        ENDIF

      ENDIF
    ENDFOR -- Make sure all GMPT programs to Run are checked to be running

  CASE (mfg_area_pn):  -- Paint Shop
    FOR i = 1 TO (ARRAY_LEN(Prgs2RunPS)) DO
      IF Prgs2RunPS[i].NeedToRun THEN
        IF ch_tasks(Prgs2RunPS[i].Prog_Name) THEN
          Prgs2RunPS[i].FailedToStrt = 0
        ELSE
          Prgs2RunPS[i].FailedToStrt = Prgs2RunPS[i].FailedToStrt + 1
        ENDIF

      ENDIF
    ENDFOR -- Make sure all Paint Shop programs to Run are checked to be running

  ELSE: --
    POST_ERR(38000, 'MFG_AREA '+ int2STR(mfg_area) +' in ATCUSTOM unknown', 0, 0) --
ENDSELECT --

END ChkPrgs2Run
------------------------------------------------------------------------------
ROUTINE getIntReg(p_reg: INTEGER; p_val: INTEGER): BOOLEAN
--
-- Gets integer value from a register
--
-- Input/Output Paramaters:
--
-- [IN]  p_reg - Register #
-- [OUT] p_val - Register value
-- [OUT] T=SUCCESS,F=FAILED
------------------------------------------------------------------------------
VAR
 l_realFlag : BOOLEAN
 l_status   : INTEGER
 l_int      : INTEGER
 l_real     : REAL
 l_str      : STRING[3]

BEGIN

  GET_REG(p_reg, l_realFlag, l_int, l_real, l_status)
  IF (l_status<>0) THEN
    POST_ERR(WARN_MSG, '[atcustom] getIntReg failed R[' + int2str(p_reg) + ']', 0, ER_WARN)
    RETURN (FALSE)
-- indicate the register was not an Interger
  ELSE
    IF l_realFlag THEN
      POST_ERR(WARN_MSG, '[atcustom] getIntReg expectd INT R[' + int2str(p_reg) + ']', 0, ER_WARN)
      RETURN (FALSE)
 -- indicate the register was not an Interger
    ENDIF
  ENDIF

  p_val= l_int
-- update the passed value to the read integer
  RETURN(TRUE)

END getIntReg
-------------------------------------------------------------------------------
ROUTINE GRP_AWARE_1  --Grp1 Prompt for Group Awareness if Multi-Arm
-------------------------------------------------------------------------------
VAR
  rtn : INTEGER 
  gm_status : INTEGER

BEGIN
  IF($JCR_GRP[1].$TRACK_JOG=FALSE)THEN
    IF($JCR.$JOG_GP = 1)THEN
      rtn = DB_PROMPT(DB_PS_OK, 
            'Multi-Arm Active Group', 
            'Current active Group is 1\nONLY ' + multiarm_r1 + ' will move if/when jogging\n\nSELECT OK to Continue', 
            255) 
    ENDIF
    IF($JCR.$JOG_GP = 2)THEN
      rtn = DB_PROMPT(DB_PS_OK, 
            'Multi-Arm Active Group', 
            'Current active Group is 2\nONLY ' + multiarm_r2 + ' will move if/when jogging\n\nSELECT OK to Continue', 
            255) 
    ENDIF
  ENDIF
  IF($JCR_GRP[1].$TRACK_JOG=TRUE)THEN
    IF($JCR_GRP[1].$TJOG_MODE=1)THEN
      rtn = DB_PROMPT(DB_PS_OK, 
            'Multi-Arm Active Group', 
            'Current active Group = Tracking Mode\nBOTH ROBOTS will move if/when jogging\n\nSELECT OK to Continue', 
            255)
    ENDIF
    IF($JCR_GRP[1].$TJOG_MODE=2)THEN
      rtn = DB_PROMPT(DB_PS_OK, 
            'Multi-Arm Active Group', 
            'Current active Group = Mirror Mode\nBOTH ROBOTS will move if/when jogging\n\nSELECT OK to Continue', 
            255)
    ENDIF
  ENDIF 
  awa_prevgrp=$JCR.$JOG_GP
  awa_prevmode=$JCR_GRP[1].$TJOG_MODE
  ENABLE CONDITION[CH_GRPPROMPT]

END GRP_AWARE_1
-------------------------------------------------------------------------------
ROUTINE GRP_AWARE_2
-------------------------------------------------------------------------------
VAR
  rtn : INTEGER
  gm_status : INTEGER

BEGIN
  IF(awa_prevgrp <> $JCR.$JOG_GP) THEN
    GRP_AWARE_1
  ENDIF
  
  IF(awa_prevmode <> $JCR_GRP[1].$TJOG_MODE)THEN
    GRP_AWARE_1
  ENDIF

  ENABLE CONDITION[CH_GRPCHANGE]
END GRP_AWARE_2
-------------------------------------------------------------------------------
ROUTINE T2_PRMPT_BOX
-------------------------------------------------------------------------------
VAR
  rtn : INTEGER
  gm_status : INTEGER

BEGIN
  SET_REG_CMT(500,'T2 Prompmt Box', gm_status)
  SET_INT_REG(500,  1, gm_status)
  rtn = DB_PROMPT(DB_PS_OK,
            'Switched to T2 Mode',
            'Robot is capable of running at FULL Speed \nSELECT OK to Continue',
            255)

  SET_INT_REG(500,  0, gm_status)

  ENABLE CONDITION[CH_T2PROMPT]
  
  IF(multiarm_jg = TRUE) THEN
    GRP_AWARE_1
  ENDIF
END T2_PRMPT_BOX
-------------------------------------------------------------------------------
ROUTINE SPR_GUN_OFF
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER
  l_ignore : INTEGER

BEGIN

  IF ((tp_curr_eq = 1) AND ((tp_curr_gun = 1) OR (tp_curr_gun = 3))) THEN  --equipment 1 gun 1
    l_ignore = iovalset($spoteqio[1].$do_cl_gun_t[1], sprctrl[1].spr_gun[1].do_cl_gun_i, 0)
  ENDIF
  ENABLE CONDITION[CH_SPRJOGGUN]

END SPR_GUN_OFF
-------------------------------------------------------------------------------
ROUTINE SPR_GUN_ON
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER
  l_ignore : INTEGER

BEGIN

  IF ((tp_curr_eq = 1) AND ((tp_curr_gun = 1) OR (tp_curr_gun = 3))) THEN  --equipment 1 gun 1
    l_ignore = iovalset($spoteqio[1].$do_cl_gun_t[1], sprctrl[1].spr_gun[1].do_cl_gun_i, 1)
  ENDIF
  ENABLE CONDITION[CH_SPRJOGGUN]

END SPR_GUN_ON
-------------------------------------------------------------------------------
ROUTINE SPR_GUN_OFF2
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER
  l_ignore : INTEGER

BEGIN

  IF ((tp_curr_eq = 1) AND ((tp_curr_gun = 1) OR (tp_curr_gun = 3))) THEN  --equipment 1 gun 1
    l_ignore = iovalset($spoteqio[1].$do_op_bu_t[1], sprctrl[1].spr_gun[1].do_op_bu_i, 0)
  ENDIF
  ENABLE CONDITION[CH_SPRJOGGUN]

END SPR_GUN_OFF2
-------------------------------------------------------------------------------
ROUTINE SPR_GUN_ON2
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER
  l_ignore : INTEGER

BEGIN

  IF ((tp_curr_eq = 1) AND ((tp_curr_gun = 1) OR (tp_curr_gun = 3))) THEN  --equipment 1 gun 1
    l_ignore = iovalset($spoteqio[1].$do_op_bu_t[1], sprctrl[1].spr_gun[1].do_op_bu_i, 1)
  ENDIF
  ENABLE CONDITION[CH_SPRJOGGUN]

END SPR_GUN_ON2
-------------------------------------------------------------------------------
ROUTINE SPR2_GUNOFF
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER
  l_ignore : INTEGER

BEGIN

IF ($spotnumeq = 1) THEN
  IF ((tp_curr_eq = 1) AND ((tp_curr_gun = 1) OR (tp_curr_gun = 3))) THEN  --equipment 1 gun 1
    l_ignore = iovalset($spoteqio[1].$do_cl_gun_t[1], sprctrl[2].spr_gun[1].do_cl_gun_i, 0)
  ENDIF
ENDIF
IF ($spotnumeq = 2) THEN
  IF ((tp_curr_eq = 2) AND ((tp_curr_gun = 1) OR (tp_curr_gun = 3))) THEN  --equipment 2 gun 1
    l_ignore = iovalset($spoteqio[2].$do_cl_gun_t[1], sprctrl[2].spr_gun[1].do_cl_gun_i, 0)
  ENDIF
ENDIF

  ENABLE CONDITION[CH_SPRJOGGN2]

END SPR2_GUNOFF
-------------------------------------------------------------------------------
ROUTINE SPR2_GUNON
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER
  l_ignore : INTEGER

BEGIN

IF ($spotnumeq = 1) THEN
  IF ((tp_curr_eq = 1) AND ((tp_curr_gun = 1) OR (tp_curr_gun = 3))) THEN  --equipment 1 gun 1
    l_ignore = iovalset($spoteqio[1].$do_cl_gun_t[1], sprctrl[2].spr_gun[1].do_cl_gun_i, 1)
  ENDIF
ENDIF
IF ($spotnumeq = 2) THEN
  IF ((tp_curr_eq = 2) AND ((tp_curr_gun = 1) OR (tp_curr_gun = 3))) THEN  --equipment 2 gun 1
    l_ignore = iovalset($spoteqio[2].$do_cl_gun_t[1], sprctrl[2].spr_gun[1].do_cl_gun_i, 1)
  ENDIF
ENDIF

  ENABLE CONDITION[CH_SPRJOGGN2]

END SPR2_GUNON
-------------------------------------------------------------------------------
ROUTINE SPR2_GUNOFF2
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER
  l_ignore : INTEGER

BEGIN

IF ($spotnumeq = 1) THEN
  IF ((tp_curr_eq = 1) AND ((tp_curr_gun = 1) OR (tp_curr_gun = 3))) THEN  --equipment 1 gun 1
    l_ignore = iovalset($spoteqio[1].$do_op_bu_t[1], sprctrl[2].spr_gun[1].do_op_bu_i, 0)
  ENDIF
ENDIF
IF ($spotnumeq = 2) THEN
  IF ((tp_curr_eq = 2) AND ((tp_curr_gun = 1) OR (tp_curr_gun = 3))) THEN  --equipment 2 gun 1
    l_ignore = iovalset($spoteqio[2].$do_op_bu_t[1], sprctrl[2].spr_gun[1].do_op_bu_i, 0)
  ENDIF
ENDIF

  ENABLE CONDITION[CH_SPRJOGGN2]

END SPR2_GUNOFF2
-------------------------------------------------------------------------------
ROUTINE SPR2_GUNON2
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER
  l_ignore : INTEGER

BEGIN

IF ($spotnumeq = 1) THEN
  IF ((tp_curr_eq = 1) AND ((tp_curr_gun = 1) OR (tp_curr_gun = 3))) THEN  --equipment 1 gun 1
    l_ignore = iovalset($spoteqio[1].$do_op_bu_t[1], sprctrl[2].spr_gun[1].do_op_bu_i, 1)
  ENDIF
ENDIF
IF ($spotnumeq = 2) THEN
  IF ((tp_curr_eq = 2) AND ((tp_curr_gun = 1) OR (tp_curr_gun = 3))) THEN  --equipment 2 gun 1
    l_ignore = iovalset($spoteqio[2].$do_op_bu_t[1], sprctrl[2].spr_gun[1].do_op_bu_i, 1)
  ENDIF
ENDIF

  ENABLE CONDITION[CH_SPRJOGGN2]

END SPR2_GUNON2
-------------------------------------------------------------------------------
ROUTINE AdptW1P1_ON
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER

BEGIN
  IF (proces_name[1] = '(SPOT1)') THEN
    IF (DIN[di_adprun_p1] = ON) THEN
      l_stat = IOValSet(doAdptOff_t[1] + IGNOR_OFFLIN, doAdptOff_i[1], 1)
    ENDIF
  ENDIF
  ENABLE CONDITION[CH_ADAP_ON]
END AdptW1P1_ON
-------------------------------------------------------------------------------
ROUTINE AdptW1P1_OFF
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER

BEGIN
  IF (proces_name[1] = '(SPOT1)') THEN
    IF (DIN[di_adprun_p1] = OFF) THEN
      l_stat = IOValSet(doAdptOff_t[1] + IGNOR_OFFLIN, doAdptOff_i[1], 0)
    ENDIF
  ENDIF
  ENABLE CONDITION[CH_ADAP_ON]
END AdptW1P1_OFF
-------------------------------------------------------------------------------
ROUTINE AdptW1P2_ON
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER

BEGIN
  --DI[93&157:diAdaptRerunPt] from PLC
  IF (proces_name[2] = '(SPOT1)') THEN
    IF (DIN[di_adprun_p2] = ON) THEN
      l_stat = IOValSet(doAdptOff_t[1] + IGNOR_OFFLIN, doAdptOff_i[1], 1)
    ENDIF
  ENDIF
  ENABLE CONDITION[CH_ADAP_ON_B]
END AdptW1P2_ON
-------------------------------------------------------------------------------
ROUTINE AdptW1P2_OFF
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER

BEGIN
  IF (proces_name[2] = '(SPOT1)') THEN
    IF (DIN[di_adprun_p2] = OFF) THEN
      l_stat = IOValSet(doAdptOff_t[1] + IGNOR_OFFLIN, doAdptOff_i[1], 0)
    ENDIF
  ENDIF
  ENABLE CONDITION[CH_ADAP_ON_B]
END AdptW1P2_OFF
-------------------------------------------------------------------------------
ROUTINE AdptW2P2_ON
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER

BEGIN
  IF (proces_name[2] = '(SPOT2)') THEN
    IF (DIN[di_adprun_p2] = ON) THEN
      l_stat = IOValSet(doAdptOff_t[2] + IGNOR_OFFLIN, doAdptOff_i[2], 1)
    ENDIF
  ENDIF
  ENABLE CONDITION[CH_ADAP_ON2]
END AdptW2P2_ON
-------------------------------------------------------------------------------
ROUTINE AdptW2P2_OFF
-------------------------------------------------------------------------------
VAR
  l_stat : INTEGER

BEGIN
  IF (proces_name[2] = '(SPOT2)') THEN
    IF (DIN[di_adprun_p2] = OFF) THEN
      l_stat = IOValSet(doAdptOff_t[2] + IGNOR_OFFLIN, doAdptOff_i[2], 0)
    ENDIF
  ENDIF
  ENABLE CONDITION[CH_ADAP_ON2]
END AdptW2P2_OFF
-------------------------------------------------------------------------------
-----------------------------------------------------------------------------
ROUTINE CmntCnfgFile
-- PURPOSE: to put comments on the variable files for Wizard Configuration Files
--
-- CALLED BY: Power up routine, these need updating because not retained
--
--
-----------------------------------------------------------------------------
CONST

   MSG_OK =  1 --tmenu_ok        -- 1 prompt box ok
   MSG_YN = 2 --tmenu_yn        -- 2 prompt box yes/no
   MSG_LIST = 3 --tmenu_lst     -- 3 select from a list
   MSG_STAT = 4 --tmenu_status  -- 4 monitor values
   MSG_OPER = 5 --tmenu_entry   -- 5 setup values
   max_mnu_used = 50--WAS 24 12-11-15        -- maxinum number of menus used  (per type)

VAR
i,ix,entry,int_value : INTEGER
menucomment  : STRING[16] -- the text to be added to attribute
vrfilename   : STRING[8] -- Variable name for the menu vr file names


BEGIN

FOR i = 1 TO ARRAY_LEN(FileComments) DO
  IF UNINIT(FileComments[i].vr_filename) THEN
    FileComments[i].vr_filename = ''
  ENDIF
  IF UNINIT(FileComments[i].prog_comment) THEN
    FileComments[i].prog_comment = ''
  ENDIF
ENDFOR --
                              --1234567890123456--
FileComments[1].vr_filename = 'GMCFGBDY'
FileComments[1].prog_comment = 'Body Shop Config'
FileComments[2].vr_filename = 'GMCFGCEL'
FileComments[2].prog_comment = 'WorkCell Config'
FileComments[3].vr_filename = 'GMCFGDMP'
FileComments[3].prog_comment = 'Dimpler Config'
FileComments[4].vr_filename = 'GMCFGDSP'
FileComments[4].prog_comment = 'Dispense Config'
FileComments[5].vr_filename = 'GMCFGERR'
FileComments[5].prog_comment = 'Errors Config'
FileComments[6].vr_filename = 'GMCFGFDS'
FileComments[6].prog_comment = 'FlwDrlScrwConfig'
FileComments[7].vr_filename = 'GMCFGMH'
FileComments[7].prog_comment = 'M.H. Config'
FileComments[8].vr_filename = 'GMCFGPJW'
FileComments[8].prog_comment = 'ProjctWeldConfig'
FileComments[9].vr_filename = 'GMCFGPNT'
FileComments[9].prog_comment = 'Paint Config'
FileComments[10].vr_filename = 'GMCFGPRS'
FileComments[10].prog_comment = 'Press Config'
FileComments[11].vr_filename = 'GMCFGPWR'
FileComments[11].prog_comment = 'PowertrainConfig'
FileComments[12].vr_filename = 'GMCFGSPR'
FileComments[12].prog_comment = 'SlfPrcRvtConfig'
FileComments[13].vr_filename = 'GMCFGSPT'
FileComments[13].prog_comment = 'SpotWeld Config'
FileComments[14].vr_filename = 'GMCFGSTD'
FileComments[14].prog_comment = 'StudWeld Config'
FileComments[15].vr_filename = 'GMCFGTLC'
FileComments[15].prog_comment = 'ToolChnge Config'
FileComments[16].vr_filename = 'GMCFGVIS'
FileComments[16].prog_comment = 'Vision Config'
FileComments[17].vr_filename = 'GMCFGLAS'
FileComments[17].prog_comment = 'AT Laser Config'

--GMCFGARC and GMCFGMIG don't show up in SpotTool yet, when it does, this can be added
--can't put it in yet because it will post a warning every power cycle
--FileComments[xx].vr_filename = 'GMCFGARC'
--FileComments[xx].prog_comment = 'ArcTool Config'
--FileComments[xx].vr_filename = 'GMCFGMIG'
--FileComments[xx].prog_comment = 'Mig-Weld Config'

FOR i = 1 TO ARRAY_LEN(FileComments) DO
  USING FileComments[i] DO --
    IF vr_filename <> '' THEN
      SET_ATTR_PRG(vr_filename, AT_COMMENT ,value_int, prog_comment, gm_status)
      IF gm_status <> 0 THEN
        POST_ERR(38000, 'Failed to set'+vr_filename +' to ' +prog_comment, gm_status, 0) --
      ENDIF
    ENDIF
  ENDUSING --
ENDFOR --

FOR i = MSG_OK TO MSG_OPER DO -- Loop through all menu numbers
   FOR ix = 1 TO max_mnu_used DO
     vrfilename = 'MENU'+ Int2Str(i) -- make menu name
     IF ix <10 THEN -- need to add zero to <10 to make name correct filename
       vrfilename = vrfilename +'0'
     ENDIF
     vrfilename = vrfilename +Int2Str(ix) -- Add the menu element number
       menucomment = '' -- clear comment name
       GET_VAR(entry, vrfilename , 'menu_name', menucomment, status)
         IF (status <> 0) AND (status <> 16011) THEN -- 16011 = VARS-011 No Data Defined for Program
           POST_ERR(38000, 'Get Var '+ vrfilename +' menu_name FAILED', status, 0) --
         ELSE
           IF menucomment <>'' THEN  -- is a menu name avialable for comment
             SET_ATTR_PRG(vrfilename, AT_COMMENT , int_value, menucomment, status)
             IF status <>0 THEN
               POST_ERR(38000, 'Failed to set ' + vrfilename+ ' Comment Attribute', status, 0) --
               DELAY 100
             ENDIF
           ENDIF
         ENDIF
    ENDFOR --
 ENDFOR --


END CmntCnfgFile
-----------------------------------------------------------------------------
ROUTINE ClnUpRcvyMnu
-- PURPOSE: to tun off alarm and set screen back for Custoxyz Alarm recovery
--          if menu is active and ABORT condition occurs, then the routine is also
--          called.
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:  CUSTOYN, CUSTOOK,CUSTOLST  ABORT condition handler in ATCUSTOM
--
--
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(Rcvry_Active) THEN
  Rcvry_Active = FALSE
ENDIF
IF UNINIT(user_aborted) THEN
  user_aborted = FALSE
ENDIF
IF UNINIT(ok_flag) THEN
  ok_flag = FALSE
ENDIF
IF UNINIT(yn_flag) THEN
  yn_flag = FALSE
ENDIF
IF UNINIT(lst_flag) THEN
  lst_flag = FALSE
ENDIF

--  IF (Rcvry_Active = TRUE) THEN
     DISABLE CONDITION[CHWatchTimer] -- don't need watch screen timer
     DISABLE CONDITION[CHWatchScrn] -- don't need watch user screen

     DISCONNECT TIMER RepostTimer  -- Disconnect timer Start the Timer

     CANCEL FILE TPPROMPT -- Need to cancel read if aborting

     CLR_STND_SCR(gm_status)

     WRITE TPERROR(CHR(129))-- Clear line from previous writing
     WRITE TPDISPLAY (CHR(128),CHR(137))
     WRITE TPPROMPT(CHR(129))-- Clear line from previous writing
     RepostTimer = 0 -- Reset the Timer

     IF NOT (TPIN[tpi_enable]) THEN -- dont change screen on user???
       FORCE_SPMENU(tp_panel,SPI_TPTCH,1)
     ELSE
       FORCE_SPMENU(tp_panel,SPI_TPUSER,1)
     ENDIF

     IF (user_aborted = TRUE) THEN
       POST_ERR(38000, 'User Aborted Before Answer', 0, 0) --
     ELSE
       IF (ok_flag = TRUE) THEN
         POST_ERR(38000, 'User is OK to Continue', 0, 0) --
       ENDIF
       IF (yn_flag = TRUE) THEN
         POST_ERR(38000, 'R['+int2str(yn_answer)+'] = '+int2str(ansd_yn)+' for User Recovery', 0, 0) --
       ENDIF
       IF (lst_flag = TRUE) THEN
         POST_ERR(38000, 'R['+int2str(lst_answer)+'] = '+int2str(ansd_lst)+' for User Recovery', 0, 0) --
       ENDIF
     ENDIF

    -- Reset all menu related vars NO 2 should be active at once Right?
     ok_flag = FALSE
     yn_flag = FALSE
     lst_flag = FALSE
     Rcvry_Active = FALSE -- Reset the User menu is active
     user_aborted = FALSE

     IF dnet64size = FALSE THEN -- Not sure why this is a condition ????
       gm_status = iovalset(2, prmp_dout, 0)
       IF (gm_status <> 0) THEN 
         POST_ERR(38000, 'Failed to set User Manual Inteverntion DO to OFF', 0, 0)
       ENDIF 
     ENDIF


--  ENDIF -- ENDIF for Rcvry_Active=TRUE

END ClnUpRcvyMnu
-----------------------------------------------------------------------------
ROUTINE UserRcvyActv
-- PURPOSE: to put message on tp error window so user know to go back to the
--          user menu for prompt to be answered. If user left, then came back
--          need to turn off one handler and clean the TPERROR screen when TP is
--          on because if reset it pressed and TP on, then the reposting doesnt occur
--          so need to clear the previous write here. This stuff is so stupid!!!!
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY: Condition Handlers
--
--
-----------------------------------------------------------------------------

BEGIN

IF ($TP_INUSER=FALSE) THEN

  IF (TPIN[tpi_enable]=OFF) THEN
    WRITE TPERROR(CHR(129),CHR(137), 'Press RESET to return to Recovery  ')
  ELSE
    WRITE TPERROR(CHR(129),CHR(137), 'MENU then 9 to Complete Recovery   ')
  ENDIF

  RepostTimer = 0 -- Reset the Timer
  CONNECT TIMER TO RepostTimer -- Remark Start the Timer
  ENABLE CONDITION[CHWatchTimer]

ELSE -- Back on user screen

  IF TPIN[tpi_enable] THEN -- only if TP is enabled otherwise reposting takes care of
    WRITE TPERROR(CHR(129),CHR(137), '                                  ')
  ENDIF

  DISCONNECT TIMER RepostTimer --
  DISABLE CONDITION[CHWatchTimer]
  ENABLE CONDITION[CHWatchScrn] -- enable monitoring for going off screen

ENDIF

END UserRcvyActv
-----------------------------------------------------------------------------
ROUTINE ChkWERobot
-- PURPOSE: to check the WE robot if purge monitoring
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------

BEGIN

IF UNINIT(WEChkReset) THEN
  WEChkReset = FALSE -- if checking WE setting every reset should occur in custm_reset routine
ENDIF
IF UNINIT(WEChkStart) THEN
  WEChkStart = FALSE -- If checking WE settings every cycle start in prestart
ENDIF
IF UNINIT(WEChkifSim) THEN -- If the RI7 & RI8 should be checked for being simulated
  WEChkifSim = FALSE
ENDIF

    WEMontrPurge = FALSE

    GET_VAR(entry, '*SYSTEM*' , '$RI_AIRPURGE[1]', WEMontrPurge, gm_status) -- check purge monitoring is enabled
      IF gm_status <> 0 THEN
        POST_ERR(38000, 'GetVar $RI_AIRPURGE[1] FAILED in ATCUSTOM', gm_status, 0) --
      ELSE -- verify Purge Monitoring is not OFF
        IF WEMontrPurge = FALSE THEN
          POST_ERR(38000, 'Purge Air Monitor DISABLED', 0, 0) --Post information Error for user
          IF UNINIT(ReEnbWEMontr) THEN
            ReEnbWEMontr = TRUE -- Changed from False RK 6-23-17
          ENDIF
          IF ReEnbWEMontr = TRUE THEN -- if purge monitor should be auto re-enabled on Power up
            Set_B_sVar('$RI_AIRPURGE[1]',TRUE)-- if WE robot, unconditionally enable the Purge
                                              -- monitoring for Group#1 on RI 7 & RI 8
            POST_ERR(38000, 'RE-ENABLED Purge Air Monitor', 0, 0) --Post information Error for user
          ENDIF
        ENDIF
      ENDIF


END ChkWERobot
------------------------------------------------------------------------------
ROUTINE zdt_var
--
--  Ensure ZDT variables are set properly every power cycle
--
--
-----------------------------------------------------------------------------
BEGIN

  Set_B_sVar('$RCMCFG.$MOTION_ENB', FALSE)
  Set_B_sVar('$RCMCFG.$SYSTEM_ENB', FALSE)
  Set_B_sVar('$RCMCFG.$APPL_ENB', FALSE)
  Set_B_sVar('$RCMCFG.$COMM_ENB', FALSE)

END zdt_var
------------------------------------------------------------------------------
ROUTINE dispense_var
--
--  Ensure dispense variables are set properly every power cycle
--
--
-----------------------------------------------------------------------------
VAR
  x:  INTEGER
  a:  STRING[4]
  tot_disp_eq:  INTEGER

BEGIN

  --find out how many dispense equipments
  GET_VAR(entry, '*system*', '$sleqnum', tot_disp_eq,  gm_status)
    IF (gm_status <> 0) THEN --couldn't read variable
      POST_ERR(38000, 'Failed to read number of dispense eq', 0,0)
    ELSE  --could read number of dispense equipment
      FOR x = 1 TO tot_disp_eq DO
        CNV_INT_STR(x, 1, 0, a)
        a = SUB_STR(a, 2, 3)
        Set_B_sVar('$SLSETUP[' + a + '].ENB_AUTOFFST', FALSE)
      ENDFOR
    ENDIF  --couldn't read variable

END dispense_var
-----------------------------------------------------------------------------
ROUTINE chkHomIOStup -- RK added 6-27-18
-- PURPOSE:to verify someone has not changed the HOME_IO setup to be ran
--         when the robot returns home, this cause alot of down time because
--         user had chose something differant and left the scene.
-----------------------------------------------------------------------------
VAR
crnthmioprg : STRING[20]-- used for the name of the program to run when robot transistions
                        -- robot at home rising edge.
BEGIN

GET_VAR(entry, '*SYSTEM*' , '$ATCELLSETUP.$HOME_IO_PRG', crnthmioprg, gm_status)
  IF gm_status <> 0 THEN
    POST_ERR(38000, '[*SYSTEM*].$ATCELLSETUP.$HOME_IO_PRG FAILED', gm_status, 0) --
  ELSE
    IF (crnthmioprg<>'HOME_IO') THEN
      Set_S_sVar('$ATCELLSETUP.$HOME_IO_PRG','HOME_IO')
      POST_ERR(38000, '$HOME_IO_PRG reset from '+crnthmioprg+'to HOME_IO',0, 0) --
    ENDIF
  ENDIF

END chkHomIOStup
------------------------------------------------------------------------------
ROUTINE hide_safeio
--
--  hide hidden portion of DCS Safe I/O connect menu if DCS safe i/o connect
--  menu write protection is being used
--  
--  
-----------------------------------------------------------------------------
BEGIN
  
  IF FRVRC THEN
    --don't do anything, allow people to set this to display
  ELSE --not virtual robot, make sure write protected safe I/O connect remains hidden
    Set_B_sVAR('$dcs_cfg.$pioc_disp', false)
  ENDIF --if FRVRC

  ENABLE CONDITION[CH_dcsioprot]

END hide_safeio
------------------------------------------------------------------------------
ROUTINE unhidesafeio
--
--  turn off write protection and unhide the hidden lines of the DCS I/O 
--  connect menu if FRVRC
--  
--  
--  
-----------------------------------------------------------------------------
BEGIN

  Set_I_sVar('$dcs_piocnum', 0) --turn off write protection on DCS I/O connect menu
  Set_B_PVar('atcustom','gmsafeioprot',FALSE) --turn off condition handler before next power cycle
                                              --to allow the DCS I/O connect menu to be unhidden
  Set_B_sVar('$dcs_cfg.$pioc_disp', TRUE) --unhide the DCS I/O connect lines

END unhidesafeio
-------------------------------------------------------------------------------
ROUTINE WriteConsole(p_message : string)
-------------------------------------------------------------------------------
BEGIN
  open file g_tmpfile ('RW', 'CONS:\')
  clr_io_stat(g_tmpfile)
  write g_tmpfile(p_message, CR)
  close file g_tmpfile
END WriteConsole
--------------------------------------------------------------------------------
ROUTINE WriteStatus(p_message : string; p_status : integer)
--------------------------------------------------------------------------------
BEGIN
  open file g_tmpfile ('RW', 'CONS:\')
  clr_io_stat(g_tmpfile)
  write g_tmpfile(p_message, ': ', p_status, CR)
  close file g_tmpfile
END WriteStatus
------------------------------------------------------------------------------
ROUTINE run_shltask(p_tskName: STRING)
-- Runs the shl* tasks. Routine waits for the task to be
-- completed before returning. This method is used instead
-- of calling the TP programs directly to protect the shell
-- from pausing due to problems with the TP program, ie
-- writing to an IO port that doesn't exist.
------------------------------------------------------------------------------
VAR
  l_loaded    : BOOLEAN
  l_inited    : BOOLEAN
  l_status    : INTEGER
  l_tskStatus : INTEGER

BEGIN

  IF UNINIT(p_tskName) THEN p_tskName= ''; ENDIF

  IF (p_tskName<>'') THEN
    -- Check if prog is loaded
    LOAD_STATUS(p_tskName, l_loaded, l_inited)
    IF l_loaded THEN
      GET_TSK_ATTR(p_tskName, TSK_STATUS, l_tskStatus)
      SELECT (l_tskStatus) OF
        CASE (PG_ABORTED):
        CASE (PG_PAUSED):  ABORT_TASK(p_tskName, TRUE, FALSE, l_status)
        CASE (PG_RUNNING): ABORT_TASK(p_tskName, TRUE, FALSE, l_status)
        ELSE:
      ENDSELECT
      RUN_TASK (p_tskName, 0, FALSE, FALSE, 1, l_status)
      IF (l_status=0) THEN
        REPEAT
          GET_TSK_ATTR(p_tskName, TSK_STATUS, l_tskStatus)
          IF (l_tskStatus=PG_PAUSED) THEN
            ABORT_TASK(p_tskName, TRUE, FALSE, l_status)
          ELSE
            DELAY 100
          ENDIF
        UNTIL(l_tskStatus=PG_ABORTED)
      ELSE
        POST_ERR (WARN_MSG, p_tskName + ' failed to run', l_status, 0)
      ENDIF
    ENDIF
  ENDIF

END run_shltask
---------------------------------------------------------------
ROUTINE custm_reset
-- customize routine for
--  WHEN (TPIN[tpi_reset]+) OR (OPIN[sopi_reset]+) OR  (OPIN[uopi_reset + 15]+) DO
--  Use this to clear any flags you use in your shell polling routine on Spot+ so that
--  error only gets posted once per reset.
--  This still gets sent on non spot+ robots, so you can do what you want with it.
---------------------------------------------------------------
BEGIN

-- if menu active then need to do below, if not skip it
 IF ((Rcvry_Active = TRUE) AND (NOT TPIN[tpi_enable])) THEN
   IF (ok_flag = TRUE) THEN Post_Custok ; ENDIF  -- need to refresh screen
   IF (yn_flag = TRUE) THEN Post_Custyn ; ENDIF  -- need to refresh screen
   IF (lst_flag = TRUE) THEN Post_Custlst ; ENDIF  -- need to refresh screen

   IF ($TP_INUSER=TRUE) THEN
     DISCONNECT TIMER RepostTimer  -- Disconnect timer the Timer
     DISABLE CONDITION[CHWatchTimer] -- dont need to watch timer because should be back on user if above ran
     ENABLE CONDITION[CHWatchScrn] -- enable monitoring for going off screen
   ENDIF

 ENDIF

 IF (ok_flag = FALSE) AND (yn_flag = FALSE) AND (lst_flag = FALSE) THEN
   Rcvry_Active = FALSE
 ENDIF

-- below added by RK
  run_shltask('SHLRESET')


    IF (WEChkifSim = TRUE) AND (WEChkReset = TRUE) THEN -- if setup to chk simulation inputs
      IF ChkSimulated(io_rdi,7) THEN -- call routine to chk if simulated
        WRITE TPERROR(CHR(cc_clear_win),'RI[7] Purge Monitor SIMULATED')
        DELAY 100
      ENDIF
      IF ChkSimulated(io_rdi,8) THEN -- call routine to chk if simulated
        WRITE TPERROR(CHR(cc_clear_win),'RI[8] Purge Monitor SIMULATED')
      ENDIF
    ENDIF


END custm_reset
---------------------------------------------------------------
ROUTINE custm_t1t2
-- customize routine run when t1t2 is selected
---------------------------------------------------------------
BEGIN

-- below added by RK

  run_shltask('ShlT1T2')   -- call customizing .tp program

END custm_t1t2
-----------------------------------------------------------------------------
ROUTINE custm_abort
-- PURPOSE: this routine is put in to allow events to occur in the this
--          routine based on the ABORT event being sent by the system.
--          BE QUICK in the code dont go off executing a bunch of code that could fail
--          rather set a flag to allow something to spawn
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY: Abort condition handler in the GMATCSTM program
--
-----------------------------------------------------------------------------
BEGIN

  user_aborted = TRUE  --will trigger condition handler to call clnuprcvymnu

   -- THIS CURRENTLY DOES NOT WORK, NEED TO FIQURE OUT A WAY THROUGH SYSTEM
  run_shltask('ShlAbort')   -- call customizing .tp program

END custm_abort
---------------------------------------------------------------
ROUTINE custm_auto
-- customize routine run when auto is selected
---------------------------------------------------------------
BEGIN

-- below added by RK
  run_shltask('SHLAUTO')    -- Run customizing .tp program

END custm_auto
---------------------------------------------------------------
ROUTINE custpowerup
-- to initialize conditions.  Called every powerup.
---------------------------------------------------------------
VAR
  gm_status : INTEGER
  file_name  : STRING[8]
  file_index : INTEGER
  task_no    : INTEGER
  task_stat  : INTEGER
  value_str  : STRING[8]
  status     : INTEGER
  attribute  : INTEGER
  entry      : INTEGER
  result     : INTEGER

BEGIN

  set_std_cold --Run cold start configuration every power up

--  IF debug THEN
--    writeconsole('[atcustom] custpowerup routine called')
--  ENDIF

  IF UNINIT(Rcvry_Active) THEN
    Rcvry_Active = FALSE
  ENDIF
  IF UNINIT(user_aborted) THEN
    user_aborted = FALSE
  ENDIF
  IF UNINIT(ok_flag) THEN
    ok_flag = FALSE
  ENDIF
  IF UNINIT(yn_flag) THEN
    yn_flag = FALSE
  ENDIF
  IF UNINIT(lst_flag) THEN
    lst_flag = FALSE
  ENDIF

  IF UNINIT(doAdptOff_i[1]) THEN
    doAdptOff_i[1] = 1075
  ENDIF
  IF UNINIT(diAdaptCap_t[1]) THEN
    diAdaptCap_t[1] = 1
  ENDIF
  IF UNINIT(diAdaptCap_i[1]) THEN
    diAdaptCap_i[1] = 1077
  ENDIF

  IF UNINIT(doAdptOff_i[2]) THEN
    doAdptOff_i[2] = 1203
  ENDIF
  IF UNINIT(diAdaptCap_t[2]) THEN
    diAdaptCap_t[2] = 1
  ENDIF
  IF UNINIT(diAdaptCap_i[2]) THEN
    diAdaptCap_i[2] = 1205
  ENDIF

  IF UNINIT(di_adprun_p1) THEN
    di_adprun_p1 = 93
  ENDIF

  IF (hotstart = FALSE) THEN --cold start clean-up
    clnuprcvymnu --clean up custo*.pc flags
  ENDIF

  --V8.33P08 Multi-Group awareness schoensm  
  IF UNINIT(multiarm_jg) THEN
    multiarm_jg = FALSE
  ENDIF
  --V8.33P08 Multi-Group awareness schoensm    
  IF UNINIT(multiarm_r1) THEN
    multiarm_r1 = 'R1'
  ENDIF
  --V8.33P08 Multi-Group awareness schoensm    
  IF UNINIT(multiarm_r2) THEN
    multiarm_r2 = 'R2'
  ENDIF

  IF (proces_name[1] = '(SPOT1)') THEN
    CONDITION[CH_ADAP_ON]: WITH $SCAN_TIME = 200
      WHEN (DIN[diAdaptCap_i[1]] = ON) AND (DIN[di_adprun_p1] = ON) AND (DOUT[doAdptOff_i[1]] = OFF) AND
           ($MSKKEY = CE_AUTO_MODE) AND (NOT TPIN[tpi_enable]) AND (OPIN[sopi_remote]=ON) AND
           (allow_nostrk = FALSE) AND (skip_1more = FALSE) AND (cont_next = FALSE) DO
               AdptW1P1_ON
      WHEN (DIN[diAdaptCap_i[1]] = ON) AND (DIN[di_adprun_p1]-) AND (DOUT[doAdptOff_i[1]] = ON) AND
           ($MSKKEY = CE_AUTO_MODE) AND (NOT TPIN[tpi_enable]) AND (OPIN[sopi_remote]=ON) AND
           (allow_nostrk = FALSE) AND (skip_1more = FALSE) AND (cont_next = FALSE) DO
               AdptW1P1_OFF
    ENDCONDITION
    ENABLE CONDITION[CH_ADAP_ON]
  ENDIF

  IF UNINIT(di_adprun_p2) THEN
    di_adprun_p2 = 157
  ENDIF

  IF (proces_name[2] = '(SPOT1)') THEN
    CONDITION[CH_ADAP_ON_B]: WITH $SCAN_TIME = 200
      WHEN (DIN[diAdaptCap_i[1]] = ON) AND (DIN[di_adprun_p2] = ON) AND (DOUT[doAdptOff_i[1]] = OFF) AND
           ($MSKKEY = CE_AUTO_MODE) AND (NOT TPIN[tpi_enable]) AND (OPIN[sopi_remote]=ON) AND
           (allow_nostrk = FALSE) AND (skip_1more = FALSE) AND (cont_next = FALSE) DO
               AdptW1P2_ON
      WHEN (DIN[diAdaptCap_i[1]] = ON) AND (DIN[di_adprun_p2]-) AND (DOUT[doAdptOff_i[1]] = ON) AND
           ($MSKKEY = CE_AUTO_MODE) AND (NOT TPIN[tpi_enable]) AND (OPIN[sopi_remote]=ON) AND
           (allow_nostrk = FALSE) AND (skip_1more = FALSE) AND (cont_next = FALSE) DO
               AdptW1P2_OFF
      ENDCONDITION
      ENABLE CONDITION[CH_ADAP_ON_B]
  ENDIF

  IF (proces_name[2] = '(SPOT2)') THEN
    CONDITION[CH_ADAP_ON2]: WITH $SCAN_TIME = 200
      WHEN (DIN[diAdaptCap_i[2]] = ON) AND (DIN[di_adprun_p2] = ON) AND (DOUT[doAdptOff_i[2]] = OFF) AND
           ($MSKKEY = CE_AUTO_MODE) AND (NOT TPIN[tpi_enable]) AND (OPIN[sopi_remote]=ON) AND
           (allow_nostrk = FALSE) AND (skip_1more = FALSE) AND (cont_next = FALSE) DO
               AdptW2P2_ON
      WHEN (DIN[diAdaptCap_i[2]] = ON) AND (DIN[di_adprun_p2]-) AND (DOUT[doAdptOff_i[2]] = ON) AND
           ($MSKKEY = CE_AUTO_MODE) AND (NOT TPIN[tpi_enable]) AND (OPIN[sopi_remote]=ON) AND
           (allow_nostrk = FALSE) AND (skip_1more = FALSE) AND (cont_next = FALSE) DO
               AdptW2P2_OFF
    ENDCONDITION
    ENABLE CONDITION[CH_ADAP_ON2]
  ENDIF

-- RKosaski added below to monitor for User to set abort to be active
user_aborted = FALSE
 PURGE CONDITION[CH_UserAbort] -- Purge to clear condition uses same one in All CUSTO 3 programs
   CONDITION[CH_UserAbort]: -- 695
    WHEN (user_aborted = TRUE) DO --
      ClnUpRcvyMnu -- Will clean up the recovery that is active if Rcvry_Active
      ENABLE CONDITION[CH_UserAbort]
   ENDCONDITION --
   ENABLE CONDITION[CH_UserAbort]

-- Setup condition to monitor when user leaves screen with recovery active.
  PURGE CONDITION[CHWatchScrn]
  CONDITION[CHWatchScrn]: -- 696
    WHEN ($TP_INUSER=FALSE) AND (Rcvry_Active = TRUE) DO -- if off user screen
      UserRcvyActv -- Indicate to the user recovery is active in User pane currently not Displayed
  ENDCONDITION --
  ENABLE CONDITION[CHWatchScrn]

-- Setup condition handler for Reposting is triggered from UserRcvyActv routine after posting
-- to user they left the user screen, and how to return to it in TPERROR window
  IF UNINIT(RepostTime) THEN
    RepostTime = 5000
  ENDIF
  RepostTimer = 101  -- used as a timer to repost reset to return to user started in USERRCVYACTV routine
  PURGE CONDITION[CHWatchTimer]
  CONDITION[CHWatchTimer]: --697 -- this gets enabled in UserRcvyActive routine if CHWatchScrn Triggered
    WHEN (RepostTimer > RepostTime) AND (Rcvry_Active = TRUE) DO --
      UserRcvyActv -- Indicate to the user recovery is active in User pane currently not Displayed
    WHEN ($TP_INUSER=TRUE) AND (Rcvry_Active = TRUE) DO --
      UserRcvyActv -- In User pane again, clean message and enable CHWatchScrn
  ENDCONDITION --

    IF (proces_name[1] = '(SPR1)') THEN
      CONDITION[CH_SPRJOGGUN]: WITH $SCAN_TIME = 100
        WHEN TPIN[ky_uf_1_s]+ AND TPIN[tpi_enable] AND DOUT[sprctrl[1].spr_gun[1].do_cl_gun_i]=OFF DO
          SPR_GUN_ON
        WHEN TPIN[ky_uf_1_s]- AND TPIN[tpi_enable] AND DOUT[sprctrl[1].spr_gun[1].do_cl_gun_i]=ON DO
          SPR_GUN_OFF
        WHEN TPIN[ky_uf_1_s]=OFF AND TPIN[tpi_enable] AND DOUT[sprctrl[1].spr_gun[1].do_cl_gun_i]=ON DO
          SPR_GUN_OFF
        WHEN TPIN[ky_uf_2_s]+ AND TPIN[tpi_enable] AND DOUT[sprctrl[1].spr_gun[1].do_op_bu_i]=OFF DO
          SPR_GUN_ON2
        WHEN TPIN[ky_uf_2_s]- AND TPIN[tpi_enable] AND DOUT[sprctrl[1].spr_gun[1].do_op_bu_i]=ON DO
          SPR_GUN_OFF2
        WHEN TPIN[ky_uf_2_s]=OFF AND TPIN[tpi_enable] AND DOUT[sprctrl[1].spr_gun[1].do_op_bu_i]=ON DO
          SPR_GUN_OFF2
      ENDCONDITION
      ENABLE CONDITION[CH_SPRJOGGUN]
    ENDIF

    IF (proces_name[2] = '(SPR2)') THEN
      CONDITION[CH_SPRJOGGN2]: WITH $SCAN_TIME = 100
        WHEN TPIN[ky_uf_1_s]+ AND TPIN[tpi_enable] AND DOUT[sprctrl[2].spr_gun[1].do_cl_gun_i]=OFF DO
          SPR2_GUNON
        WHEN TPIN[ky_uf_1_s]- AND TPIN[tpi_enable] AND DOUT[sprctrl[2].spr_gun[1].do_cl_gun_i]=ON DO
          SPR2_GUNOFF
        WHEN TPIN[ky_uf_1_s]=OFF AND TPIN[tpi_enable] AND DOUT[sprctrl[2].spr_gun[1].do_cl_gun_i]=ON DO
          SPR2_GUNOFF
        WHEN TPIN[ky_uf_2_s]+ AND TPIN[tpi_enable] AND DOUT[sprctrl[2].spr_gun[1].do_op_bu_i]=OFF DO
          SPR2_GUNON2
        WHEN TPIN[ky_uf_2_s]- AND TPIN[tpi_enable] AND DOUT[sprctrl[2].spr_gun[1].do_op_bu_i]=ON DO
          SPR2_GUNOFF2
        WHEN TPIN[ky_uf_2_s]=OFF AND TPIN[tpi_enable] AND DOUT[sprctrl[2].spr_gun[1].do_op_bu_i]=ON DO
          SPR2_GUNOFF2
      ENDCONDITION
      ENABLE CONDITION[CH_SPRJOGGN2]
    ENDIF

    IF UNINIT(deadman_sw) THEN
      deadman_sw = FALSE
    ENDIF
    
    IF UNINIT(awa_prevgrp) THEN
      awa_prevgrp=0
    ENDIF    
    
    CONDITION[CH_T2PROMPT]: WITH $SCAN_TIME = 100
      WHEN (TPIN[tpi_enable]+) AND (deadman_sw = TRUE) AND (OPIN[8] = OFF) AND (NOT OPOUT[sopo_fault]) DO
          T2_PRMPT_BOX
      WHEN (TPIN[tpi_enable]) AND (deadman_sw = TRUE) AND (OPIN[8] = OFF) AND (OPOUT[sopo_fault]-) DO
          T2_PRMPT_BOX
      WHEN (TPIN[tpi_enable]) AND (deadman_sw = TRUE) AND (OPIN[8]-) AND (NOT OPOUT[sopo_fault]) DO
          T2_PRMPT_BOX
      WHEN (TPIN[tpi_enable]) AND (DOUT[2049]+) AND (OPIN[8] = OFF) AND (NOT OPOUT[sopo_fault]) DO
          T2_PRMPT_BOX
      ENDCONDITION
    ENABLE CONDITION[CH_T2PROMPT]
    
--***--	
	--GROUP AWARENESS PROMPTS
    CONDITION[CH_GRPPROMPT]: WITH $SCAN_TIME = 100
      WHEN (TPIN[tpi_enable]+) AND (deadman_sw = TRUE) AND (OPIN[8] = ON) AND (NOT OPOUT[sopo_fault]) AND (multiarm_jg = TRUE) DO
          GRP_AWARE_1
      WHEN (TPIN[tpi_enable]) AND (deadman_sw = TRUE) AND (OPIN[8] = ON) AND (OPOUT[sopo_fault]-) AND (multiarm_jg = TRUE) DO
          GRP_AWARE_1
      WHEN (TPIN[tpi_enable]) AND (DOUT[2049]+) AND (OPIN[8] = ON) AND (NOT OPOUT[sopo_fault]) AND(multiarm_jg = TRUE) DO
          GRP_AWARE_1
      ENDCONDITION
    ENABLE CONDITION[CH_GRPPROMPT]
	
    CONDITION[CH_GRPCHANGE]: WITH $SCAN_TIME = 500
      WHEN (TPIN[tpi_enable]) AND (deadman_sw = TRUE) AND (NOT OPOUT[sopo_fault]) AND (multiarm_jg = TRUE) DO
          GRP_AWARE_2
      ENDCONDITION
    ENABLE CONDITION[CH_GRPCHANGE]

  file_name = 'lptmtrem'
  attribute = TSK_STATUS
  GET_TSK_INFO(file_name,task_no,attribute,task_stat,value_str,status)
    IF UNINIT (task_stat) then -- program has never been run
      RUN_TASK(file_name, 1, FALSE, FALSE, 0, status)
        IF (status<>0) THEN
          POST_ERR(38000,file_name +' Failed to RUN from atcustom', status, 0) --
        ENDIF
    ELSE
      IF (task_stat <> PG_RUNNING) THEN  -- program has bas been run but aborted
        RUN_TASK(file_name, 1, FALSE, FALSE, 0, status)
        IF (status<>0) THEN
          POST_ERR(38000,file_name + ' Failed to RUN from atcustom', status, 0) --
        ENDIF
      ENDIF
    ENDIF

-- Check programs to run for Power up and should run based on the shop
   ChkPrgs2Run

-- below added by RK
  run_shltask('SHLINIT')

-- Run the configuration program attribute commenter
  CmntCnfgFile

-- if a WE robot model, verify the Purge monitoring did not get turned OFF
  IF Chk_Feature('H731') THEN -- If WE robot, ensure monitoring is enabled added 4-24-17
    ChkWERobot -- Routine to ensure purge monitoring is enabled
    IF WEChkifSim = TRUE THEN -- if setup to chk simulation inputs
      IF ChkSimulated(io_rdi,7) THEN -- call routine to chk if simulated
        POST_ERR(38000, 'RI[7] Purge Monitor SIMULATED', 0, 0) --
      ENDIF
      IF ChkSimulated(io_rdi,8) THEN -- call routine to chk if simulated
        POST_ERR(38000, 'RI[8] Purge Monitor SIMULATED', 0, 0) --
      ENDIF
    ENDIF
  ELSE -- not WE robot set all vars to FALSE
    WEChkReset = FALSE
    WEChkStart = FALSE
    WEChkifSim = FALSE
  ENDIF

  --Reset ZDT settings every power up
  zdt_var

  --Set dispense variables every power up
  dispense_var

  chkHomIOStup
  GET_VAR(entry, '*system*', '$dcs_piocnum', result, gm_status)
    IF (gm_status <> 0) THEN --couldn't read variable
      gmsafeioprot = FALSE
    ELSE  --succussful read
      IF (result < 0) THEN --write protection is being used
        gmsafeioprot = TRUE
      ELSE
        gmsafeioprot = FALSE
      ENDIF
    ENDIF
 
   CONDITION[CH_dcsioprot]: WITH $SCAN_TIME = 5000
     WHEN (gmsafeioprot = TRUE) DO
       hide_safeio
   ENDCONDITION
   ENABLE CONDITION[CH_dcsioprot]

  IF UNINIT(unhide_dcs) THEN
    unhide_dcs = FALSE
  ENDIF

  IF FRVRC THEN --only for FRVRC
    IF (unhide_dcs = TRUE) THEN
      unhidesafeio --turn off write protection adn unhide DCS I/O connect menu lines
      unhide_dcs = FALSE
    ENDIF --unhide DCS
  ENDIF --FRVRC

  --V8.33P09 schoensm added hook to call $FSAC routine, only post warnings at start-up.
  fsac_1
    
END custpowerup
---------------------------------------------------------------
ROUTINE custm_shpoll
-- Hook into shell polling if on Spot+
-- only called if shell polling is enabled.
---------------------------------------------------------------
BEGIN
--  IF debug THEN
--   writeconsole('[atcustom] custm_shpoll called')
--  ENDIF
END custm_shpoll
---------------------------------------------------------------
ROUTINE custm_prerun --(p_status)
-- before program is ran.
-- default is p_status must return as zero to continue running of program.
-- If your custo wants to prevent running of program based on
-- some custo checks, then return p_status as 1, and post a fault explaining why from your error dictionary,
---------------------------------------------------------------
-- below added by RK
VAR
  l_stat,
  psve,
  gm_status : INTEGER

  l_loaded   : BOOLEAN
  l_inited   : BOOLEAN
  l_entry    : INTEGER
  l_custName : STRING[12]
  l_defProg  : STRING[12]
  l_safety   : INTEGER
  l_status   : INTEGER
  l_dummy    : STRING[2]
  l_attr_out : INTEGER
  l_task_no  : INTEGER


BEGIN -- custm_prerun
--  IF debug THEN
--    writeconsole('[atcustom] custm_prerun called')
--  ENDIF

  IF UNINIT(SHELL_ERR_R) THEN -- set the error startup register
    SHELL_ERR_R = 470
  ENDIF

  IF UNINIT(doGunRstCk_i[1]) THEN
    doGunRstCk_i[1] = 0
  ENDIF
  IF UNINIT(doGunRstCk_i[2]) THEN
    doGunRstCk_i[2] = 0
  ENDIF

  IF (proces_name[1] = '(SPOT1)') THEN
    l_stat = IOValSet(2 + IGNOR_OFFLIN, doGunRstCk_i[1], 0)
  ENDIF
  IF (proces_name[2] = '(SPOT1)') THEN
    l_stat = IOValSet(2 + IGNOR_OFFLIN, doGunRstCk_i[1], 0)
  ENDIF
  IF (proces_name[2] = '(SPOT2)') THEN
    l_stat = IOValSet(2 + IGNOR_OFFLIN, doGunRstCk_i[2], 0)
  ENDIF

  IF ($ap_selap[2] = TRUE) OR ($ap_selap[6] = TRUE) THEN  -- Spot and Dispense
    SET_VAR(psve, '*system*', '$SVPRG_ENB', TRUE, gm_status)
  ELSE
    IF ( $ap_selap[4] = TRUE) THEN  --jja  R30iB
       -- MH
    ENDIF
  ENDIF

  p_status= 0

  IF (p_status=0) THEN  -- continue checking
    -- call TP program to get GOOD/BAD indicator and send back to shell
    LOAD_STATUS('shlsafe', l_loaded, l_inited)
    IF l_loaded THEN
      run_shltask('SHLSAFE')
      DELAY 1000 -- give tp program a chance to finish
      l_safety= 0  -- make sure initialized
      IF GetIntReg(SHELL_ERR_R, l_safety) THEN -- R[470]
        IF (l_safety<>0) THEN
          POST_ERR(38000, 'Prerun User check failed R['+int2str(SHELL_ERR_R)+']='+int2str(l_safety), 0, 0) --
          -- RK edited 2-24-17 POST_ERR(WARN_MSG, 'Prerun Safety check failed', 0, ER_WARN)
          p_status= 1  -- don't continue
        ENDIF
      ELSE
        p_status= 1  -- don't continue
      ENDIF
    ENDIF
  ENDIF

   ChkPrgs2Run -- make sure any shell programs that have been setup to run are running.

    IF (WEChkifSim = TRUE) AND (WEChkStart = TRUE) THEN -- if setup to chk simulation inputs
      IF ChkSimulated(io_rdi,7) THEN -- call routine to chk if simulated
        WRITE TPERROR(CHR(cc_clear_win),'RI[7] Purge Monitor SIMULATED')
        DELAY 100
      ENDIF
      IF ChkSimulated(io_rdi,8) THEN -- call routine to chk if simulated
        WRITE TPERROR(CHR(cc_clear_win),'RI[8] Purge Monitor SIMULATED')
      ENDIF
    ENDIF

  --V8.33P09 schoensm added hook to call $FSAC routine, all warnings are masked.
  fsac_2

END custm_prerun
---------------------------------------------------------------
ROUTINE custm_prersm --(p_status)
-- before program is resumed.
-- default is p_status must return as zero to continue resuming of program.
-- If your custo wants to prevent resuming of program based on
-- some custo checks, then return p_status as a 1 and post a fault explaining why from your error dictionary
---------------------------------------------------------------
VAR
  l_loaded   : BOOLEAN
  l_inited   : BOOLEAN
  l_entry    : INTEGER
  l_custName : STRING[12]
  l_defProg  : STRING[12]
  l_safety   : INTEGER
  l_status   : INTEGER
  l_dummy    : STRING[2]
  l_attr_out : INTEGER
  l_task_no  : INTEGER

BEGIN -- custm_prersm

  IF UNINIT(SHELL_ERR_R) THEN -- set the error startup register
    SHELL_ERR_R = 470
  ENDIF

--  IF debug THEN
--    writeconsole('[atcustom] custm_prersm called')
--  ENDIF

-- below added by RK
   -- call TP program and get GOOD/BAD indicator and send back to shell
  LOAD_STATUS('shlprere', l_loaded, l_inited)
  IF l_loaded THEN
    run_shltask('SHLPRERE')
    DELAY 1000 -- give tp program a chance to finish
    -- must wait until the shlprere program is aborted
    l_safety=0  -- make sure initialized
    IF GetIntReg(SHELL_ERR_R, l_safety) THEN -- R[470]
      IF (l_safety<>0) THEN
        POST_ERR(38000, 'Prerun User check failed R['+int2str(SHELL_ERR_R)+']='+int2str(l_safety), 0, 0) --
     -- RK edited 2-24-17  POST_ERR(WARN_MSG, 'Prerun Safety check failed', 0, ER_WARN)
        p_status= 1  -- don't continue
      ENDIF
    ELSE
      p_status= 1  -- don't continue
    ENDIF
  ENDIF

  IF debug THEN
    IF (p_status=0) THEN
      writeconsole('[atcustom]custm_PRERSM OK to run')
    ELSE
      writeconsole('[atcustom]custm_PRERSM NOT OK to run')
    ENDIF
  ENDIF

  IF (p_status=0) THEN
    run_shltask('SHLRESUM')
  ENDIF

END custm_prersm
---------------------------------------------------------------
ROUTINE custm_end
-- customize routine run when program ends (production or SOP started program)
---------------------------------------------------------------
BEGIN
--  IF debug THEN
--    writeconsole('[atcustom] custm_end called')
--  ENDIF
  ok_flag  = FALSE
  yn_flag  = FALSE
  lst_flag = FALSE

-- below added by RK

  run_shltask('SHLEXIT')

END custm_end
-----------------------------------------------------------------
ROUTINE custm_erhnds   -- At start of err handler
                       -- routine in swerrjob.
-----------------------------------------------------------------
BEGIN
--  IF debug THEN
--    writeconsole('[atcustom] custm_erhnds called')
--  ENDIF

-- below added by RK
  run_shltask('SHLERHNS')

END custm_erhnds
-----------------------------------------------------------------
ROUTINE custm_erhnde--(p_status:INTEGER)   -- At end of err handler routine in swerrjob
                                          -- just before program is ran.
                                          -- if you return non-zero p_status, then
                                          -- it will cancel resume of program via
                                          -- err_handler.
-----------------------------------------------------------------

BEGIN
IF UNINIT(last_error) THEN -- this should always be set in ATERRJOB, but incase
  last_error = 0
ENDIF

--  IF debug THEN
--    writeconsole('[atcustom] Custm_erhnde called')
--  ENDIF

--       Disable  Dsbl&Togl  Dsbl,Tgl,Cncl Dsbl&Cncl    retry     togle only  tgl&cancel cancel only
--CASE(GMMHD_OPTS,GMMHDT_OPTS,GMMHDTC_OPTS,GMMHD_C_OPTS,GMMH_OPTS,GMMHT_OPTS,GMMHTC_OPTS,GMMH_C_OPTS):

  SELECT (last_error) OF -- last error is from ATERRJOB used to react from choice user selected
    CASE (er_clampa,er_clampb):  -- programmed recovery for these alarms are common
      MH_Rcvy_Done(p_status)-- call routine to handle the recovery user selected
    CASE (er_prtpresf,er_noprtprsf,er_vacnoton,er_vacnotoff):  --
      MH_Rcvy_Done(p_status)-- call routine to handle the recovery user selected
  ELSE: --

  ENDSELECT --

-- below added by RK
  run_shltask('SHLERHNE')

END custm_erhnde
---------------------------------------------------------------
ROUTINE custm_pause
-- customize routine run when program pauses (production or SOP started program)
---------------------------------------------------------------
BEGIN
--  IF debug THEN
--    writeconsole('[atcustom] custm_pause called')
--  ENDIF

-- below added by RK

  run_shltask('SHLPAUSE')

END custm_pause
---------------------------------------------------------------
ROUTINE custm_prmpt
-- customize routine run when prompt box is about to be posted
---------------------------------------------------------------
BEGIN
--  IF debug THEN
--    writeconsole('[atcustom] custm_prmpt called')
--  ENDIF

-- below added by RK
   run_shltask('SHLPRMPT')

END custm_prmpt
---------------------------------------------------------------
BEGIN -- atcustom

 Cur_Revision = Revision

      -- this program will only be ran once during install to initialize debug var
--  IF UNINIT(debug) THEN
--    debug = FALSE
--  ENDIF
END ATCUSTOM
