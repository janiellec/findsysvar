-- -----------------------------------------------------------------------
--
--   MODULE:         HOMEUTIL.KL
--   TITLE:          HOMEUTIL PROGRAM
--
--
--   WRITTEN BY:     RANDY KOSASKI
--   REVISION DATE:  3/1/18
--
--   LANGUAGE:       KAREL 8.33/P05 R30iB
--   CONTROL GROUP:  BODY SHOP EXECUTION GROUP
--   STATUS:
--
--
--   ORDER NUMBER:   GMGLB4
--   PROJECT NAME:   GMPT Pontiac Team
--
--
--         FANUC Robotics retains rights in any and all Software
--         contained in the material attached hereto and said
--         Software may not be copied or reproduced without the
--         written permission of FANUC Robotics.
--
--         All Software, (C) Copyright FANUC Robotics Corporation, 2018
--         DESCRIPTION: Program routines used for the HOMEFIND program used to get the
--                      Robot to the HOME positon register #1.
--
--         HISTORY OF CHANGES:
--
--         REVISION   DATE       BY               COMMENTS
--         --------   ---------  ---------------  --------------------
--
--
--
--
--------------------------------------------------------------------------
PROGRAM HOMEUTIL

%COMMENT = 'HOMEUTIL Prog'

%ENVIRONMENT MULTI  -- used for PAUSE_TASK builtin
--%ENVIRONMENT PBCORE -- used for GET_TSK_INFO builtin
%environment SYSDEF
%ENVIRONMENT IOBLT  -- needed for IOVALRD
%ENVIRONMENT UIF    -- needed for read_dict_v
%ENVIRONMENT STRNG -- needed for cnv_real_str
%ENVIRONMENT MOTN   -- needed for RESET builtin
%ENVIRONMENT REGOPE -- needed for SET_JPOS_REG builtin
%ENVIRONMENT TPE  -- needed for TP_HEAD and other Tp related builtins
--%SYSTEM
--%INVISIBLE
                --*****************************************************************
--%NOABORT = ERROR + COMMAND-- *** REMOVE COMMENT FOR PRODUCTION NEED TO IGNORE ABORT
                --*****************************************************************
%NOPAUSE = ERROR + COMMAND + TPENABLE
%NOBUSYLAMP
%NOLOCKGROUP
%PRIORITY=100
%NOPAUSESHFT
%ALPHABETIZE
%COMMENT = 'GM Homing Data'
%INCLUDE klevksp  -- TPMM KAREL softpart loader. and the device_stat and tpdc_tp_c
%INCLUDE klevkmsk -- needed for KC_ITEM_CHNG
%INCLUDE KLEVCCDF -- Used for the TPERROR builtin
%INCLUDE FXMPNCEG -- has dictionary element constants
%INCLUDE gm_ch_id -- need for the condition handler constant declarations

TYPE

PerchInfo = STRUCTURE
  PR_RegNum   : INTEGER
  PR2CurPosDis: REAL
  PR_RegCmnt  : STRING[20]
  PR_PosRepTyp: INTEGER
  RefPosNumber: INTEGER
  PR_At_Pos_DO: INTEGER -- the digital output number from Refernce position
  PR_Enabled  : BOOLEAN -- Allows to be disabled if setup or user not wanting
  PR_Status   : INTEGER -- used to ensure is configure and useable data Untaught PR is problem
  PR_ToolUsed : POSITION --XYZWPR
  PR_FrameUsed: POSITION --XYZWPR
  PR_NumofAxis: INTEGER
  PR_JPos     : JOINTPOS IN GROUP[1]
  PR_LPos     : POSITION IN GROUP[1]
  PR_xyz: POSITION--XYZWPR
  PR_xyzext: XYZWPREXT

ENDSTRUCTURE

CONST

Version = '04/25/2018 R.K.' -- Please change version when you make an update

MaxPouncArry = 20 -- the maximum number of pounces avaialbe
MaxPouncChcs = 21 -- need an extra one for the choice menu
Joint = 1
Linear = 2
%INCLUDE kliouop -- needed for the uopi_hold
%INCLUDE kliotyps -- needed for the io_uopin

VAR
Current_Ver  IN SHADOW :STRING[32] -- Set equal to Version constant in initialization routine

cur_rbt_pos  : POSITION
cur_Mov2_pos  : POSITION -- the position the user wants to jog to in world
cur_rbtJpos  : JOINTPOS IN GROUP[1]
cur_JogJpos  : JOINTPOS IN GROUP[1]
lastPRString :STRING[20] -- used for reading String from the PR for displaying on the form

curgrpnum,
StrtPouncReg,  -- the starting pounce register def Reg 102
MaxPouncReg,
StrtPouncNum,  --  the value of pounce registers used should be 1 read from StrtPouncReg
MaxNumPounc,   -- The maximum number of pounces
UsrJogJntAmt, -- The Joint value when user is using JOG feature, what value will be set in PR for move
UsrJogXYZAmt, -- the XYZ value when a user is using the JOG feature what value will be set for PR MOVE

PRNum4JogINC, -- the position regsiter the used for INC jog command, used with PRNUM4NILPOS
PRNum4Offset, -- the position register to set the offsets into
PRnum4CurPos, -- the number the position register to set curpos to. Default is 21
PRnum4NilPos, -- the position register to store NILPOS (all Zeros)

BaseTFrmNum,
ax_lmtMsk,     -- used for the axis limit mask in the CURJPOS/CURPOS builtins
ot_Msk,        -- used for the overtravel mask in the CURJPOS/CURPOS builtins
BaseUfrmNum             IN SHADOW :INTEGER

JogDistance IN SHADOW : REAL -- Used for the amount the user is moving the robot

CurJogPos: ARRAY[9] of REAL
CurJntPos: ARRAY[9] of REAL

Dist2Pounce,       -- buffer for holding closest distance to robot current position from a pounce PR
real_value  : REAL -- Used for GET_REG builtin
rk_db,
exit,

tp_is_on,     -- Used to indicate teh programs to run in the group needed

MovPrgStartd,  -- used to inticate the TP file used to move the robot has launch succesfully
CoordChanged,  -- used to indicate the cordinate was changed as the user was on MOVE/Jog Form
all_done,   -- used to determine the form is all done and end the repeat loop
real_Flag  : BOOLEAN -- Used for GET_REG Builtin

MajorAxsOnly, -- IF TRUE only the major axis only
UsrCordAvail, -- If the user can change coordinates for jogging is avaialble
TP_Use_Only,  -- When TRUE the TP MUST BE ENABLED for use
UsePLC4Rcvy,  -- Used for determining if PLC HMI recovery is avialble. Default is NO.
AutoToClst,  -- The ability to have robot NOT propmt operator, then move home using it.(DEFAULT FALSE)
Move_Key,    -- USed for if user is requesting the move to be done to selected pounce
HMIMoveEnbld,-- used for if the HMI has the ability to jog using the  PLC_DoButton input
Jog_active,  -- used for if the user is wanting to jog the robot, or MOVE to pounce
Jog_Enabled IN SHADOW : BOOLEAN -- Used for if the user can use the Jog feature in home assist

atPosDist,    -- the amount for close enough to postion to be considered there
DefltJogType, -- the Default cordinate for the Jog Feature, do 1 time when form 1st posted
MaxDstAuto,   -- the maximum the robot can be away from the pounce when AutoToClst is ENABLED Default 500mm
ChoiceNum,    -- the indexer for what element in the array to place the CHOICE text
PncMovPRNum,  -- the actual position register from the PncToMoveTo[PncToMoveTo].PR_RegNum
PncToMoveTo,  -- The pounce position Array number the robot will move to
PncUserSlctd,  -- the pounce number the user selected to use to move to first
PncCurntlyAt,  -- the Pnc the robot is at
PncClsestTo IN SHADOW : INTEGER -- identifies the closest PR robot current position is

Cur_pnc_num FROM HOMEFIND :INTEGER

timer_var: INTEGER -- used for timing the fault reset timeout

CurElemntNum, -- used for the element in a positoin to be set
LastJogCord,-- used for last cordinate changed direction based on the user changing a direction
curformNum, -- hold value for which FORM to dispaly based on settings/ Jog/NO jog
entry,i,gm_status  : INTEGER -- Used for return value of the builtins

-- variable needed from AE
wjnt_cfg :CONFIG
ext_ang  :ARRAY[9] of REAL
  r1, r2, r3 : real  -- temp variables
  arystr : array[2] of string[40] -- used for the READ_DICT_V
  asst_arystr: array[2] of string[40] -- used for the READ_DICT_V
  title: array[1] of string[30]       -- used for the READ_DICT
  prompt: array[1] of string[120]     -- used for the READ_DICT/ DB_PROMPT
  response: integer
  lin_data   : array [20] of byte

  lin_len: integer -- used to determine how deep in array to read when creatinga TP file

userprogname IN SHADOW :STRING[16]-- the name of TP file we call to run
UsrJogDirStr IN SHADOW :ARRAY[18] OF STRING[3]-- Displaying of user direction
UserJogStr   IN SHADOW :ARRAY[5] OF STRING[8]      -- 1= Joint,2=JFrame,3=World,4=Tool,5=User Added 1 to system for displaying

HomePrcActDO, -- output active when home is in process.
HomeActPrcDI, -- input to trigger macrto table to run this program, maybe need internally???

UserJogDir,      -- This is the direction the JOG button will drive robot.1-2 (X/J1), (3,4 Y/J2)etc.
UserJogType,       -- 0= Joint,1=JFrame,2=World,3=Tool,4=User from system variables
UserMoType IN SHADOW :INTEGER -- 1= Joint,2=Linear
PLC_DoButton, -- the number for PLC
UserJntSpd, -- the speed the user wants to program to go when joint is the motion
UserLnrSpd,  -- The speed the user wants program to go when Linear is the motion
UserProgSpd IN SHADOW :INTEGER -- the speed the robot will be programmed to move to perch at

-- Items required for the form manager
tp_key, -- Used for indirecting the Jog or MOVE keys
tp_key_s, -- Used for the Indiecting of the SHFT and F3 or F4 for Jogging or Moving

prg_status, -- return value from GET_TSK_INFO
int_value,
term_mask,
term_char,
open_id    : INTEGER -- Used for routine in getting teach pendant positions
status     IN CMOS :INTEGER -- Status of built-in procedure call nice to see if power cycled because of issue can see cmos
prg_str,
jogCordStr, -- used for displaying the jog cordinate user is jogging
JogDirStr, -- Used for the direction the user is jogging
whiletext :STRING[40]

value_array: ARRAY [10] OF STRING [120]
inact_array: ARRAY [10] OF BOOLEAN
change_array: ARRAY[10] OF BOOLEAN
PR_ArrySlctd, -- used for the PR_ArrayIndex which will hold the data user selected
def_item: INTEGER

PR_Arrayindx :ARRAY[MaxPouncChcs] OF INTEGER -- Used in form manage to reference PR Choice to the actual PERCH data array
PR_Choices: ARRAY[MaxPouncChcs] OF STRING[40]-- used for CHOICE variable on form, need 1 extra 1st is blank
Perch_Data: ARRAY[MaxPouncArry] OF PerchInfo

ROUTINE GetUserPRNum FROM HOMEUTIL
ROUTINE clr_stnd_scr(status: INTEGER) FROM klutils
ROUTINE tp_enabled: BOOLEAN FROM klutlext

%INCLUDE gmrdutil
--** ----------------------------------------------------------------------
-- set_app_head: Set the application header for the TPE program
--       return: None
--** ----------------------------------------------------------------------
--
--  Borrowed DOBWDEXIT which borrowed from sngcus.kl
--
ROUTINE set_app_head(open_id: INTEGER)

VAR
  index_1 :  INTEGER
  index_2 :  INTEGER
  buf_size : INTEGER
  l_str_len : INTEGER
  l_loop : INTEGER
  ltr_string : STRING[1]
  Spin_way_var :INTEGER
  bool_var :INTEGER
  do_virtual : BOOLEAN
  vir_time   : INTEGER
  entry      : INTEGER
  head_buf : ARRAY[20] OF BYTE
  arc: boolean
  spt: boolean

BEGIN

  GET_VAR(entry, '*SYSTEM*','$VIRTUALTIME',vir_time,status)
  do_virtual = (status = 0)
  arc = false
  spt = false

  IF Chk_Feature('H541') OR Chk_Feature('H574') THEN -- ARC Tool
    arc = true
    FND_HEAD_TPE(open_id, 'ARCW',index_1, index_2, status)
--    write('writing ARCW stat:', status, cr)
    IF status <> 0 THEN
      head_buf[1] = ORD('A', 1)
      head_buf[2] = ORD('R', 1)
      head_buf[3] = ORD('C', 1)
      head_buf[4] = ORD('W', 1)
--      head_buf[5] = 1
      head_buf[5] = 0
      buf_size = 5

      index_2 = 0
      SET_HEAD_TPE(open_id, index_1, index_2, 0, buf_size, head_buf, status)
      IF status <> 0 THEN
        POST_ERR(status, '', 0, 0)
      ENDIF
    ENDIF
  ENDIF

  IF Chk_Feature('H590') THEN -- spot Tool
    spt = true
    FND_HEAD_TPE(open_id, 'SPOT',index_1,index_2, status)
--    write('writing SPOT stat:', status, cr)
    IF status <> 0 THEN
      head_buf[1] = ORD('S', 1)
      head_buf[2] = ORD('P', 1)
      head_buf[3] = ORD('O', 1)
      head_buf[4] = ORD('T', 1)
--      head_buf[5] = 1
      head_buf[5] = 0
      head_buf[6] = 0
      head_buf[7] = 0
      head_buf[8] = 0
      buf_size = 8

      index_2 = 0
      SET_HEAD_TPE(open_id, index_1, index_2, 0, buf_size, head_buf, status)
      IF status <> 0 THEN
        POST_ERR(status, '', 0, 0)
      ENDIF
    ELSE
      GET_HEAD_TPE(open_id, index_1, index_2, 20, head_buf, status)
      if status = 0 THEN
 --       write('spot header idx:', index_1, ', ', index_2, 'stat: ', status, CR)
 --       FOR l_loop = 1 TO 15 DO
 --         write(head_buf[l_loop])
 --       ENDFOR
 --       write(cr)
      ENDIF
    ENDIF
  ELSE
--    write('NOT SPOT ', cr)
  ENDIF

  IF Chk_Feature('J617') or spt THEN -- Multi Equipment
    FND_HEAD_TPE(open_id, 'MUAP',index_1, index_2, status)
--    write('writing MUAP stat:', status, cr)
    IF status <> 0 THEN
      head_buf[1] = ORD('M', 1)
      head_buf[2] = ORD('U', 1)
      head_buf[3] = ORD('A', 1)
      head_buf[4] = ORD('P', 1)
      head_buf[5] = 0
      head_buf[6] = 0
      head_buf[7] = 0
      head_buf[8] = 0
      head_buf[9] = 0 --  NONE
      head_buf[10] = 0 -- none
      head_buf[11] = 0 -- none
      head_buf[12] = 0 -- none
      IF FALSE THEN   -- ARC
        IF do_virtual THEN
          head_buf[5] = 1     -- For Virtual
        ELSE
          head_buf[8] = 1     -- For real controller
        ENDIF
      ENDIF
      IF FALSE THEN  -- spt
        IF do_virtual THEN
          head_buf[5] = 2     -- For Virtual
        ELSE
          head_buf[8] = 2     -- For real controller
        ENDIF
      ENDIF
      buf_size = 12

      -- Write to the header
      index_2 = 0
      SET_HEAD_TPE(open_id, index_1, index_2, 0, buf_size, head_buf, status)
      IF status <> 0 THEN
        POST_ERR(status, '', 0, 0)
      ENDIF
    ENDIF
  ELSE
 --   write('NOT MUAP ', cr)
  ENDIF

END set_app_head
-----------------------------------------------------------------------------
ROUTINE makemytpprog(pr_name: string;
                     grp_mask: integer;
                     pr_idx: integer;
                     motype: integer;
                     ttype: integer;
                     tval:  integer;
                     speed: integer;
                     mo_optn: integer)
-----------------------------------------------------------------------------
--
--  Create one line simple TP program for move Poince motion
--  PARTS OF THIS ROUTINE BORROWED FROM AE in case it is not loaded
--   the routine is avialble.
--  Bynary format
--
-- +----+----+----+----+----+----+----+----+----+----+----+
-- |254 |Mtyp|POS | pos idx |  Speed  |Styp|Ttyp|Tval|Optn|
-- +----+----+----+----+----+----+----+----+----+----+----+
--  |     |    |    |         |         |    |    |   |
--  |     |    |    |         |         |    |    |   option:    200 wrist joint
--  |     |    |    |         |         |    |    term_val   Cont value or zero for FINE
--  |     |    |    |         |         |    term_type  128: CNTxx   0: FINE
--  |     |    |    |         |        spd_type   0: percent  1: mm/sec
--  |     |    |    |        spd1, spd2      two bytes to show speed value
--  |     |    |    index1, index2   two bytes to show index
--  |     |   Pos  0: Position  1: Pos Register
--  |    motype   1: Joint, 2: Linear
--  254 : motion
--
-----------------------------------------------------------------------------

VAR
  status: integer
  int_value: integer
  string_value: string[6]
  lOpen_id: integer

BEGIN

  OPEN_TPE( pr_name, TPE_RWACC, TPE_NOREJ, lOpen_id, status)
    IF status <> 0 THEN
      CREATE_TPE( pr_name, PT_MNE_UNDEF, status)
      IF status <> 0 THEN
        POST_ERR(38000, 'Failed to Open '+pr_name, status, 2) -- Need to abort
        return
      ENDIF
      OPEN_TPE( pr_name, TPE_RWACC, TPE_NOREJ, lOpen_id, status)
    ENDIF
    IF status <> 0 THEN
      POST_ERR(38000, 'Open after Create Failed '+pr_name, status, 2);
      return
    ENDIF

  set_app_head(lOpen_id) -- set application header or will crap out when try to run

  --Delete all lines
  WHILE status = 0 DO
    DEL_INST_TPE(lOpen_id, 1, status)
  ENDWHILE

  -- Set group mask
  SET_ATTR_PRG( pr_name, AT_DEF_GROUP, grp_mask, string_value, status)
  IF status <> 0 THEN
    POST_ERR(38000, 'Set Grp Mask failed on '+pr_name, status, 2);
    return
  ENDIF

  -- Create one line instruction
  lin_data[1] = 254
  lin_data[2] = motype
  IF pr_idx = 0 THEN
    lin_data[3] = 0  -- Position
    lin_data[4] = 0  -- Use P[1] always
    lin_data[5] = 1  -- Use P[1] always
  ELSE
    lin_data[3] = 1  -- Pos register
    lin_data[4] = pr_idx DIV 256
    lin_data[5] = pr_idx MOD 256
  ENDIF
  lin_data[6] = speed DIV 256
  lin_data[7] = speed MOD 256
  IF motype = 1 THEN  -- joint
    lin_data[8] = 0   -- %
  ELSE
    lin_data[8] = 1   -- mm/sec
  ENDIF
  lin_data[9] = ttype
  IF ttype = 0 THEN  -- FINE
    lin_data[10] = 0
  ELSE
    lin_data[10] = tval
  ENDIF

-- Now get into optional setup based on how robot is moving
  IF mo_optn <> 0 THEN
    lin_data[11] = mo_optn -- wstjnt
--  ELSE
--    lin_data[11] = 255 -- END of line
--    lin_len = 10
  ENDIF

IF (Jog_Active = FALSE) THEN -- Based on MOVE command set end of line
  lin_data[12] = 255  -- End of Line command
  lin_len = 11
ELSE -- Jogging is either OFFSET or Tool OFFSET
  GET_VAR(entry, '*SYSTEM*' , '$JCR_GRP[1].$JOG_COORD', UserJogType, gm_status)
    IF status <> 0 THEN
      POST_ERR(38000, '[*SYSTEM*].$JCR_GRP[1].$JOG_COORD FAILED', gm_status, 0) --
      UserJogType = 2 -- world
    ENDIF
    IF UserJogType = 3 THEN -- Is User
      lin_data[12] = 219 -- Tool Offset
    ELSE
      lin_data[12] = 205 -- Offset used in world or incremental
    ENDIF

  lin_data[13] = 4
  lin_data[14] = 2
  lin_data[15] = 0
  lin_data[16] = PRNum4Offset -- Position register offset will be place

  IF UserJogType = 0 THEN --Joint
    lin_data[12] = 255 -- END of Line
    lin_len = 12
  ELSE -- If not Joint, dont need INC cmd
    lin_data[17] = 255 -- END of Line
    lin_len = 17
  ENDIF

ENDIF

  -- Set one line instruction
  SET_INST_TPE(lOpen_id, 1, 1, lin_data, lin_len, status)
  IF status <> 0 THEN
    POST_ERR(38000, 'Set Instruction Failed '+pr_name, status, 2)
    return
  ENDIF

  CLOSE_TPE( lOpen_id, status)
  IF status <> 0 THEN
    POST_ERR(38000, 'Close TP ' +pr_name+ ' Failed', status, 2);
    return
  ENDIF

END makemytpprog
-----------------------------------------------------------------------------
ROUTINE MakeTPProg
-- PURPOSE: to create a TP file, is smal routine because may have to call many time
--          if a user is changing the data as moving, i.e. joint to linear etc.
--
----------------------------------------------------------------------------

BEGIN

-- Make program with the user confiqured move type
  SELECT (UserMotype) OF --
    CASE (JOINT):  --
      UserProgSpd = UserJntSpd
    CASE (LINEAR):  --
      UserProgSpd = UserLnrSpd
    ELSE: --
      UserProgSpd = 25
  ENDSELECT --

IF MOVE_KEY THEN
                                               --1: Joint, 2: Linear
         -- ProgName, GrpMask,PR Pos_index,motype,termval,speed,mo_optn: integer
 makemytpprog(userprogname,curgrpnum,PncToMoveTo,UserMotype,0,0,UserProgSpd,200) --200 for Wjnt

ELSE -- user is wanting to jog

  IF UNINIT(UserJogType) THEN
    IF UsrCordAvail THEN
      GET_VAR(entry, '*SYSTEM*' , '$JCR_GRP[1].$JOG_COORD', UserJogType, gm_status)
        IF status <> 0 THEN
          POST_ERR(38000, '[*SYSTEM*].$JCR_GRP[1].$JOG_COORD FAILED', gm_status, 0) --
          UserJogType = 3 -- make Tool if unknown
        ENDIF
    ELSE
      UserJogType = DefltJogType
    ENDIF
  ENDIF

  SELECT (UserJogType) OF --
    CASE (0):  -- Joint, put nilpos Pr[100] with incremental move in pr[99]
            -- ProgName, GrpMask,PR Pos_index,motype,termval,speed,mo_optn: integer
            makemytpprog(userprogname,curgrpnum,PRNum4JogINC,UserMotype,0,0,UserProgSpd,210)
    CASE (1):  -- JFram
            makemytpprog(userprogname,curgrpnum,PRNum4CurPos,UserMotype,0,0,UserProgSpd,200)
    CASE (2):  -- World, put offset in PR[99], set Uframe to Zero
            makemytpprog(userprogname,curgrpnum,PRNum4Offset,UserMotype,0,0,UserProgSpd,210)
    CASE (3):  -- Tool   put curpos PR[21] with Tool offset in PR[99]
            makemytpprog(userprogname,curgrpnum,PRNum4CurPos,UserMotype,0,0,UserProgSpd,200)
    CASE (4):  -- User   put curpos PR[21] with offset in PR[99]
            makemytpprog(userprogname,curgrpnum,PRNum4CurPos,UserMotype,0,0,UserProgSpd,200)
    ELSE: --
      POST_ERR(38000, 'Unknown JOG type '+int2str(UserJogType), gm_status, 0) --
  ENDSELECT --

ENDIF

END MakeTPProg
-----------------------------------------------------------------------------
ROUTINE SetJogDirInf
-- PURPOSE: set the information associated with the Jog feature for displaying
--          the user comments on the form,
--
-- CALLED BY: when the user changes the Cordinate or Direction Keys
--
-----------------------------------------------------------------------------
BEGIN

IF UsrCordAvail THEN
  -- Determine the Cordinate to know settings.
  GET_VAR(entry, '*SYSTEM*' , '$JCR_GRP[1].$JOG_COORD', UserJogType, gm_status)
    IF gm_status <> 0 THEN
      POST_ERR(38000, '[*SYSTEM*].$JCR_GRP[1].$JOG_COORD FAILED', gm_status, 0) --
    ENDIF
ELSE
  UserJogType = DefltJogType
ENDIF
IF MajorAxsOnly THEN
  FOR i = 1 TO 7 DO -- Limit to 7 so other are unint, and choice menu will not have extra windows
    UsrJogDirStr[i]= ' '
  ENDFOR --
ELSE
  FOR i = 1 TO (ARRAY_LEN(UsrJogDirStr)) DO -- Limit to 7 so other are unint, and choice menu will not have extra windows
    UsrJogDirStr[i]= ' '
  ENDFOR --
ENDIF

  SELECT (UserJogType) OF --
    CASE (0):  -- Joint,
      UsrJogDirStr[2]  = 'J1-' --
      UsrJogDirStr[3]  = 'J1+' --
      UsrJogDirStr[4]  = 'J2-' --
      UsrJogDirStr[5]  = 'J2+' --
      UsrJogDirStr[6]  = 'J3-' --
      UsrJogDirStr[7]  = 'J3+' --
    IF MajorAxsOnly = FALSE THEN
      UsrJogDirStr[8]  = 'J4-' --
      UsrJogDirStr[9]  = 'J4+' --
      UsrJogDirStr[10] = 'J5-' --
      UsrJogDirStr[11] = 'J5+' --
      UsrJogDirStr[12] = 'J6-' --
      UsrJogDirStr[13] = 'J6+' --
      UsrJogDirStr[14] = 'J7-' --
      UsrJogDirStr[15] = 'J7+' --
      UsrJogDirStr[16] = 'J8-' --
      UsrJogDirStr[17] = 'J8+' --
    ENDIF

    CASE (1,2,3,4):  -- JFram,World,Tool, User
      UsrJogDirStr[2]  = 'X-' --
      UsrJogDirStr[3]  = 'X+' --
      UsrJogDirStr[4]  = 'Y-' --
      UsrJogDirStr[5]  = 'Y+' --
      UsrJogDirStr[6]  = 'Z-' --
      UsrJogDirStr[7]  = 'Z+' --

    IF MajorAxsOnly = FALSE THEN
      UsrJogDirStr[8]  = 'W-'  --
      UsrJogDirStr[9]  = 'W+'  --
      UsrJogDirStr[10] = 'P-'  --
      UsrJogDirStr[11] = 'P+'  --
      UsrJogDirStr[12] = 'R-'  --
      UsrJogDirStr[13] = 'R+'  --
      UsrJogDirStr[14] = 'J7-' --
      UsrJogDirStr[15] = 'J7+' --
      UsrJogDirStr[16] = 'J8-' --
      UsrJogDirStr[17] = 'J8+' --
    ENDIF

    ELSE: --
      POST_ERR(38000, 'Unknown JOG type '+int2str(UserJogType), gm_status, 0) --
  ENDSELECT --

  IF (CoordChanged = TRUE) OR (UsrCordAvail=FALSE)THEN -- need to set a sensiable default direction
    SELECT (UserJogType) OF --
      CASE (0,1,2,4,5):-- Joint, JFram ,World , , User
  --      IF LastJogCord = 3 THEN -- Only change if was Tool before
          UserJogDir = 6
  --      ENDIF
      CASE (3):-- if in Tool, the user jog direct should be Z- to start
  --      IF LastJogCord <> 3 THEN -- Only change if was Tool before
          UserJogDir = 5
  --      ENDIF
    ELSE: --
    ENDSELECT --
    LastJogCord = UserJogType
  ENDIF

 CoordChanged = FALSE --reset the cordinate chaged so above doesnt keep reseting the direction bits

END SetJogDirInf
-----------------------------------------------------------------------------
ROUTINE ReadPRCmnt(p_pr_num:INTEGER):STRING
-- PURPOSE: to read the position register Comment
--
-- INPUT:  the Position Number required to be read
--            -
-- OUTPUT: the String read from the position register comment used for displaying
--         the text for the user
--            -
-----------------------------------------------------------------------------
BEGIN

  GET_PREG_CMT(p_pr_num, lastPRString, gm_status)
    IF gm_status<>0 THEN
      lastPRString = 'PR['+int2str(p_pr_num)+'] Cmnt FAILED'
      POST_ERR(38000, lastPRString, gm_status, 0) --
    ENDIF

  RETURN(lastPRString)

END ReadPRCmnt
-----------------------------------------------------------------------------
ROUTINE InitHomedata
-- PURPOSE:
--
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(StrtPouncReg) THEN
  StrtPouncReg = 102
ENDIF
GET_REG(StrtPouncReg, real_flag, StrtPouncNum, real_value, gm_status)
  IF (gm_status <>0) OR (real_flag = TRUE) THEN
    POST_ERR(38000, 'GET_REG on R['+int2str(StrtPouncReg), gm_status, 0) --
    StrtPouncNum = 1
  ENDIF

IF UNINIT(MaxPouncReg) THEN
  MaxPouncReg = 105
ENDIF
GET_REG(MaxPouncReg, real_flag, MaxNumPounc, real_value, gm_status)
  IF (gm_status <>0) OR (real_flag = TRUE) THEN
    POST_ERR(38000, 'GET_REG on R['+int2str(MaxPouncReg), gm_status, 0) --
    MaxNumPounc = 0
  ENDIF
IF (MaxNumPounc > ARRAY_LEN(Perch_Data)) THEN
  POST_ERR(38000, 'R['+int2str(MaxPouncReg)+':Max # Pounce Pos]='+int2str(MaxNumPounc)+',Max is '+int2str(ARRAY_LEN(Perch_Data)), 0, 0) --
  ABORT
ENDIF
IF UNINIT(rk_db) THEN
  rk_db = FALSE
ENDIF

IF UNINIT(curgrpnum) THEN
  curgrpnum = 1
ENDIF
IF UNINIT(BaseTFrmNum) THEN
  BaseTFrmNum = 1
ENDIF
IF UNINIT(BaseUFrmNum) THEN
  BaseUFrmNum = 0
ENDIF

FOR i = 1 TO ARRAY_LEN(Perch_Data) DO
  USING Perch_Data[i] DO --
    IF UNINIT(PR_RegNum) THEN
      PR_RegNum = 0 -- set to zero to disable
    ENDIF
    IF UNINIT(PR2CurPosDis) THEN
      PR2CurPosDis = -10000.0
    ENDIF
    IF UNINIT(PR_RegCmnt) THEN
      PR_RegCmnt = ''
    ENDIF
    IF UNINIT(PR_ToolUsed) THEN
      GET_VAR(entry, '*SYSTEM*' , '$MOR_GRP[1].$NILPOS', PR_ToolUsed, gm_status)
        IF gm_status <> 0 THEN
          POST_ERR(38000, '[*SYSTEM*].$MOR_GRP[1].$NILPOS Variable FAILED', gm_status, 0) --
        ENDIF
    ENDIF
    IF UNINIT(PR_FrameUsed) THEN
      GET_VAR(entry, '*SYSTEM*' , '$MOR_GRP[1].$NILPOS', PR_FrameUsed, gm_status)
        IF gm_status <> 0 THEN
          POST_ERR(38000, '[*SYSTEM*].$MOR_GRP[1].$NILPOS Variable FAILED', gm_status, 0) --
        ENDIF
    ENDIF
    IF UNINIT(PR_LPos) THEN
      GET_VAR(entry, '*SYSTEM*' , '$MOR_GRP[1].$NILPOS', PR_LPos, gm_status)
        IF gm_status <> 0 THEN
          POST_ERR(38000, '[*SYSTEM*].$MOR_GRP[1].$NILPOS Variable FAILED', gm_status, 0) --
        ENDIF
    ENDIF
    IF UNINIT(PR_PosRepTyp) THEN
      PR_PosRepTyp = 0
    ENDIF
    IF UNINIT(PR_At_Pos_DO) THEN
      PR_At_Pos_DO = 0
    ENDIF
    IF UNINIT(PR_NumofAxis) THEN
      PR_NumofAxis = 0
    ENDIF
    IF UNINIT(PR_Status) THEN
      PR_Status = -1
    ENDIF
    IF UNINIT(RefPosNumber) THEN
      RefPosNumber = i
    ENDIF
    IF UNINIT(PR_Enabled) THEN
      PR_Enabled = TRUE
    ENDIF
  ENDUSING -- End of PERCH_DATA initialization
ENDFOR --

-- go setup the range of PR to be used
-- Everything is currently setup based on start point being 1
    FOR i = StrtPouncNum TO ((StrtPouncNum-1)+MaxNumPounc) DO -- setup all the pounces and their data
      USING Perch_Data[i] DO --
        IF (PR_RegNum  = 0) THEN -- setup which PR registers will be used
          PR_RegNum  = i
        ENDIF
        IF (PR_RegNum  > 0) THEN
          PR_RegCmnt = ReadPRCmnt(PR_RegNum)
        ENDIF
      ENDUSING --
    ENDFOR --

IF UNINIT(userprogname) THEN -- set name of to home program name
  userprogname = 'HOME_ASSIST'
ENDIF
IF UNINIT(UserMotype) THEN
  UserMotype = LINEAR -- joint =1 Linear =2
ENDIF

IF UNINIT(UserJntSpd) THEN
  UserJntSpd = 10
ENDIF

IF UNINIT(UserLnrSpd) THEN
  UserLnrSpd = 200
ENDIF

IF UNINIT(UserProgSpd) THEN
  SELECT (UserMotype) OF --
  CASE (JOINT):  --
    UserProgSpd = UserJntSpd
  CASE (LINEAR):  --
    UserProgSpd = UserLnrSpd
  ELSE: --
  ENDSELECT --
ENDIF

FOR i = 1 TO ARRAY_LEN(UserJogStr) DO
  IF UNINIT(UserJogStr[i]) THEN
    SELECT (i) OF --
    CASE (1):  --
      UserJogStr[i] ='Joint'
    CASE (2):  --
      UserJogStr[i] ='JogFrame'
    CASE (3):  --
      UserJogStr[i] ='World'
    CASE (4):  --
      UserJogStr[i] ='Tool'
    CASE (5):  --
      UserJogStr[i] ='User'
    ELSE: --
    ENDSELECT --
  ENDIF
ENDFOR --

IF UNINIT(PRNum4JogINC) THEN
  PRNum4JogINC = 98
ENDIF
IF UNINIT(PRNum4Offset) THEN -- Offset PR for JOG feature
  PRNum4Offset = 99
ENDIF
IF UNINIT(PRNum4NILPOS) THEN
  PRNum4NILPOS = 100
ENDIF
IF UNINIT(PRNum4CurPos) THEN -- Offset PR for current position
  PRNum4CurPos = 21
ENDIF
IF UNINIT(UserJogType) THEN
  UserJogType = 0
ENDIF
IF UNINIT(Jog_Enabled) THEN -- wether user can use the JOG feature that is avialble
  Jog_Enabled = TRUE
ENDIF
IF UNINIT(Jog_active) THEN  -- the user is trying to jog an axis not MOVE to the Pounce
  Jog_active = FALSE
ENDIF
IF UNINIT(CoordChanged) THEN
  CoordChanged = FALSE
ENDIF
IF UNINIT(DefltJogType) THEN
  DefltJogType = 3 -- Tool is default Jog, user can change jog dir w/COORD keys
ENDIF
IF UNINIT(LastJogCord) THEN
  LastJogCord = 0
ENDIF
IF UNINIT(UsrJogJntAmt) THEN
  UsrJogJntAmt = 10
ENDIF
IF UNINIT(UsrJogXYZAmt) THEN
  UsrJogXYZAmt = 150
ENDIF
IF UNINIT(AutoToClst) THEN
  AutoToClst = FALSE
ENDIF
IF UNINIT(MaxDstAuto) THEN
  MaxDstAuto = 500
ENDIF

FOR i = 1 TO ARRAY_LEN(PR_Arrayindx) DO
  PR_Arrayindx[i] = 0
ENDFOR --

  PR_ArrySlctd = 0

UserJogDir = 6 -- Always make Z+ at start of program for user

IF UNINIT(HomePrcActDO) THEN
  HomePrcActDO = 642
ENDIF

IF UNINIT(HomeActPrcDI) THEN -- used to launch Process in Macro Table
  HomeActPrcDI = 642
ENDIF

IF UNINIT(HMIMoveEnbld) THEN
  HMIMoveEnbld = FALSE
ENDIF

IF UNINIT(PLC_DoButton) THEN
  PLC_DoButton = 643
ENDIF

IF UNINIT(UsePLC4Rcvy) THEN -- if PLC recovery is needed
  UsePLC4Rcvy = FALSE
ENDIF

IF UNINIT(atPosDist) THEN
  atPosDist = 5
ENDIF

IF UNINIT(TP_Use_Only) THEN
  TP_Use_Only = TRUE
ENDIF

IF UNINIT(UsrCordAvail) THEN -- if user jog direction can be done by changing COORD key
  UsrCordAvail = FALSE
ENDIF

IF UNINIT(MajorAxsOnly) THEN
  MajorAxsOnly = TRUE
ENDIF

IF UNINIT(Cur_pnc_num) THEN
  Cur_pnc_num = 0
ENDIF

SetJogDirInf -- setup the text for the form initial display based on current Coordinate System

END InitHomedata
-----------------------------------------------------------------------------
ROUTINE chk_TP_only
-- PURPOSE: to determine if the use of this homing function is only avilable
--          when the teach penand is turned ON
--
--
--
-----------------------------------------------------------------------------

BEGIN

  IF TP_Use_Only THEN
    IF (TP_ENABLED) THEN -- Call builtin to determine if TP is enabled
      RETURN
    ELSE
      POST_ERR(38000, 'HOME Assist Configd TP ONLY', 0, 0) --
      ABORT
    ENDIF
  ENDIF

END chk_TP_only
-----------------------------------------------------------------------------
ROUTINE FndPRAryIndx
-- PURPOSE: to go through the PERCH DATA structure and determine where in the array
-- the user selected. this routine is needed because uses HOMEUTIL routine requires

-----------------------------------------------------------------------------

BEGIN

FOR i = 1 TO ARRAY_LEN(PR_Arrayindx) DO -- clean the array
  PR_Arrayindx[i] = 0
ENDFOR --

FOR i = 1 TO ARRAY_LEN(PR_Choices) DO -- need to clean array from last display
  IF NOT UNINIT(PR_Choices[i]) THEN -- if it has data clean it, if not & leave it
    PR_Choices[i] = ''              -- form manager finds first UNINIT and considers
  ENDIF                             -- last to display, otherwise get empty extra
ENDFOR --                           -- sub windows to cover array length..Ugh

 PR_Choices[1]='' -- first one is empty for FORM manager
 ChoiceNum = 2 -- set so choices will start at 2 in SUBwindow because 1st is blank
 FOR i = 1 TO MaxNumPounc DO -- go through th entire configured list
   USING Perch_Data[i] DO --
     IF ((PR_RegNum >0) AND (PR_Status = 0) AND (PR2CurPosDis<>(-10000.0))) THEN -- enabled and good number, zero is not good
        PR_Choices[ChoiceNum]='PR['+int2str(PR_RegNum)+':'+PR_RegCmnt +']'
        PR_Arrayindx[(ChoiceNum - 1)]= i -- Need to set array number to index of Variables
        ChoiceNum = ChoiceNum +1         -- because choices are not in sequnceial order do to
     ENDIF                               -- PR enabled but not taught i.e.(PR_Status <> 0)
   ENDUSING --                           -- so need lookup table for where in Perch_Data is Reg Num
 ENDFOR --
                         -- this is needed after the user does [CHOICE]
PR_ArrySlctd = 0
FOR i = 1 TO ARRAY_LEN(PR_Arrayindx) DO -- need to lookup which pounce element has closest
  IF PR_Arrayindx[i] = cur_pnc_num THEN
    PR_ArrySlctd = i
  ENDIF
ENDFOR --

END FndPRAryIndx

-----------------------------------------------------------------------------
ROUTINE SetPRAryIndx
-- PURPOSE: to go through the PERCH DATA structure and determine which in the array
--  are avaiable for use, not all confiqured can be used. I.E not taught can be used

-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------

BEGIN

FOR i = 1 TO ARRAY_LEN(PR_Arrayindx) DO -- clean the array
  PR_Arrayindx[i] = 0
ENDFOR --

FOR i = 1 TO ARRAY_LEN(PR_Choices) DO -- need to clean array from last display
  IF NOT UNINIT(PR_Choices[i]) THEN -- if it has data clean it, if not & leave it
    PR_Choices[i] = ''              -- form manager finds first UNINIT and considers
  ENDIF                             -- last to display, otherwise get empty extra
ENDFOR --                           -- sub windows to cover array length..Ugh

 PR_Choices[1]='' -- first one is empty for FORM manager
 ChoiceNum = 2 -- set so choices will start at 2 in SUBwindow because 1st is blank
 FOR i = 1 TO MaxNumPounc DO -- go through th entire configured list
   USING Perch_Data[i] DO --
     IF ((PR_RegNum >0) AND (PR_Status = 0) AND (PR2CurPosDis<>(-10000.0))) THEN -- enabled and good number, zero is not good
        PR_Choices[ChoiceNum]='PR['+int2str(PR_RegNum)+':'+PR_RegCmnt +']'
        PR_Arrayindx[(ChoiceNum - 1)]= i -- Need to set array number to index of Variables
        ChoiceNum = ChoiceNum +1         -- because choices are not in sequnceial order do to
     ENDIF                               -- PR enabled but not taught i.e.(PR_Status <> 0)
   ENDUSING --                           -- so need lookup table for where in Perch_Data is Reg Num
 ENDFOR --                               -- this is needed after the user does [CHOICE]

FOR i = 1 TO ARRAY_LEN(PR_Arrayindx) DO -- need to lookup which pounce element has closest
  IF PR_Arrayindx[i] = PncClsestTo THEN
    PR_ArrySlctd = i
  ENDIF
ENDFOR --

END SetPRAryIndx
-----------------------------------------------------------------------------
ROUTINE UpdtDisttoPR(p_data_num:INTEGER)
-- PURPOSE: to update the distance of the past array number
--
-----------------------------------------------------------------------------

BEGIN

   USING Perch_Data[p_data_num] DO --

     -- Get current physical robot position into "cur_pos"
     cur_rbtJpos = curjpos(0, 0,curgrpnum)    -- current position
     -- convert CurJpos to Cartesian representation
     JOINT2POS(cur_rbtJpos, PR_FrameUsed, PR_ToolUsed,HALF_SOLN, cur_rbt_pos, wjnt_cfg, ext_ang, gm_status)
       IF gm_status <> 0 THEN
         POST_ERR(38000, 'Joint2POS CURPOS failed PERCHDATA '+int2str(i)+'PR['+int2str(PR_RegNum)+']', gm_status, 0) --
       ENDIF

     IF PR_Status = 0 THEN  -- the data is good to be used
     -- See how far apart the robot is from the last recorded position
       r1 = cur_rbt_pos.location.x - PR_LPos.location.x
       r2 = cur_rbt_pos.location.y - PR_LPos.location.y
       r3 = cur_rbt_pos.location.z - PR_LPos.location.z
       PR2CurPosDis = SQRT(r1*r1 + r2*r2 + r3*r3)
       PR2CurPosDis = ABS(PR2CurPosDis)
     ENDIF
   ENDUSING --

END UpdtDisttoPR
-----------------------------------------------------------------------------
ROUTINE UpdtPncData
-- PURPOSE: to reset the array for the perch positions.
--
-----------------------------------------------------------------------------

BEGIN
 --  $SCR_GRP[1].$MCH_ANG[6]
 --               .$MCH_POS_X

FOR i = 1 TO MaxNumPounc DO
  USING Perch_Data[i] DO --
    IF PR_RegNum >0 THEN
      PR_RegCmnt = ReadPRCmnt(PR_RegNum)-- go get the comment from the PR
      -- Current Spec requires Base Tool Frame is one
      GET_VAR(entry, '*SYSTEM*' , '$MNUTOOL['+int2str(curgrpnum)+','+int2str(BaseTFrmNum)+']', PR_ToolUsed, gm_status)
        IF gm_status <> 0 THEN
          POST_ERR(38000, '[*SYSTEM*].$MNUTOOL['+int2str(curgrpnum)+','+int2str(BaseTFrmNum)+'] Variable FAILED', gm_status, 0) --
        ENDIF

      IF BaseUFrmNum > 0 THEN
        -- Current Spec requires Base User Frame is one
        GET_VAR(entry, '*SYSTEM*' , '$MNUFRAME['+int2str(curgrpnum)+','+int2str(BaseUFrmNum)+']', PR_FrameUsed, gm_status)
          IF gm_status <> 0 THEN
            POST_ERR(38000, '[*SYSTEM*].$MNUFRAME[$MNUFRAME['+int2str(curgrpnum)+','+int2str(BaseUFrmNum)+'] Variable FAILED', gm_status, 0) --
          ENDIF
      ELSE -- Base frame being 0 is NILPOS
        GET_VAR(entry, '*SYSTEM*' , '$MOR_GRP[1].$NILPOS', PR_FrameUsed, gm_status)
          IF gm_status <> 0 THEN
            POST_ERR(38000, '[*SYSTEM*].$MOR_GRP[1].$NILPOS Variable FAILED', gm_status, 0) --
          ENDIF
      ENDIF

      POS_REG_TYPE(PR_RegNum,curgrpnum,PR_PosRepTyp,PR_NumofAxis,gm_status)
      IF gm_status<>0 THEN
        POST_ERR(38000, 'POS_REG_TYPE Failed PR['+int2str(PR_RegNum)+ ']', gm_status, 0) --
      ENDIF

      SELECT (PR_PosRepTyp) OF --
        CASE (1):  --POSITION Returned
          --   POS2JOINT (ref_jnt, in_pos, PR_FrameUsed, PR_ToolUsed, HALF_SOLN, wjnt_cfg, ext_ang, PR_JPos, gm_status).

        CASE (2):  --XYZWPR position returned
            PR_xyz = GET_POS_REG(PR_RegNum, gm_status,curgrpnum)
                IF gm_status <>0 THEN
                  POST_ERR(38000, 'GETPOSREG PR['+int2str(PR_RegNum)+'] Failed', gm_status, 0) --
                ENDIF
                PR_Status = 2
              IF UNINIT(PR_XYZ) THEN
                IF PR_Enabled THEN
                  POST_ERR(38000, 'PR['+int2str(PR_RegNum)+':'+PR_RegCmnt+'] NOT SETUP for use', gm_status, 0) --
                ENDIF
                PR_Status = (-2)
              ELSE
                PR_LPos = PR_xyz
                PR_Status = 0
              ENDIF
        CASE (6):  --XYZWPREXT position returned , check Num_Axis for ext # axis
            PR_xyzext = GET_POS_REG(PR_RegNum, gm_status,curgrpnum)
              IF gm_status <>0 THEN
                  POST_ERR(38000, 'GETPOSREG PR['+int2str(PR_RegNum)+'] Failed', gm_status, 0) --
                ENDIF
                PR_Status = 6
              IF UNINIT(PR_xyzext) THEN
                IF PR_Enabled THEN
                  POST_ERR(38000, 'PR['+int2str(PR_RegNum)+':'+PR_RegCmnt+'] NOT SETUP for use', gm_status, 0) --
                ENDIF
                PR_Status = (-6)
              ELSE
                PR_LPos = PR_xyzext
                PR_Status = 0
              ENDIF
        CASE (9):  --JOINT position returned check Num_Axis for total axis
            PR_JPos = GET_JPOS_REG(PR_RegNum, gm_status ,curgrpnum)
              IF gm_status <>0 THEN
                POST_ERR(38000, 'GETJPOS PR['+int2str(PR_RegNum)+'] Failed', gm_status, 0) --
              ENDIF
              IF UNINIT(PR_JPos) THEN
                IF PR_Enabled THEN
                  POST_ERR(38000, 'PR['+int2str(PR_RegNum)+':'+PR_RegCmnt+'] NOT TAUGHT', 0, 0) --
                ENDIF
                PR_Status = (-9)
              ELSE

                PR_Status = 9
              ENDIF
            -- convert Position register values to Cartesian representation
            JOINT2POS(PR_JPos, PR_FrameUsed, PR_ToolUsed,HALF_SOLN, PR_LPos, wjnt_cfg, ext_ang, gm_status)
              IF gm_status <> 0 THEN
                POST_ERR(38000, 'Joint2POS PRJPOS failed PERCHDATA '+int2str(i)+'PR['+int2str(PR_RegNum)+']', gm_status, 0) --
              ELSE -- Set status data recieved as expected in Joint Representation
                  PR_Status = 0
              ENDIF
      ELSE: --
        POST_ERR(38000, 'PR['+int2str(PR_RegNum)+'] PosType returned ='+int2str(PR_PosRepTyp)+'??', 0, 0) --
         PR_Status = -1
      ENDSELECT --

      PR2CurPosDis = -10000.0 -- Reset the distance

      IF UNINIT(PR_LPos) THEN
        GET_VAR(entry, '*SYSTEM*' , '$MOR_GRP[1].$NILPOS', PR_LPos, gm_status)
          IF gm_status <> 0 THEN
            POST_ERR(38000, '[*SYSTEM*].$MOR_GRP[1].$NILPOS FAILED', gm_status, 0) --
          ENDIF
      ENDIF
      IF UNINIT(PR_PosRepTyp) THEN
        PR_PosRepTyp = 0
      ENDIF

      -- this section gets robot current position, and compares to the position registers
      -- values so it can calculate the distance each useable PR is away from cur pos.
      -- BORROWED from AE code so if broke here needs fixing there also....

      -- Get current physical robot position into "cur_pos"
      cur_rbtJpos = curjpos(0, 0,curgrpnum)    -- current position
      -- convert CurJpos to Cartesian representation
      JOINT2POS(cur_rbtJpos, PR_FrameUsed, PR_ToolUsed,HALF_SOLN, cur_rbt_pos, wjnt_cfg, ext_ang, gm_status)
        IF gm_status <> 0 THEN
          POST_ERR(38000, 'Joint2POS CURPOS failed PERCHDATA '+int2str(i)+'PR['+int2str(PR_RegNum)+']', gm_status, 0) --
        ENDIF

      IF PR_Status = 0 THEN  -- the data is good to be used
      -- See how far apart the robot is from the last recorded position
        r1 = cur_rbt_pos.location.x - PR_LPos.location.x
        r2 = cur_rbt_pos.location.y - PR_LPos.location.y
        r3 = cur_rbt_pos.location.z - PR_LPos.location.z
        PR2CurPosDis = SQRT(r1*r1 + r2*r2 + r3*r3)
        PR2CurPosDis = ABS(PR2CurPosDis)
        IF rk_db THEN WRITE (CR,'Dist to PR',PR_RegNum,'=', PR2CurPosDis, CR); ENDIF --debug
        IF rk_db THEN WRITE ('X=', r1, ' Y=', r2, ' Z=', r3,CR); ENDIF --debug
      ELSE
        IF PR_Enabled THEN
          POST_ERR(38000, 'DISABLED PR['+int2str(PR_RegNum)+'] Status='+int2str(PR_Status), 0, 0) --
          PR_Enabled = FALSE
        ENDIF
        IF rk_db THEN WRITE ('PR[',PR_RegNum,'] Status=', PR_Status, CR); ENDIF --debug
      ENDIF

    ENDIF -- endif for PR_RegNum >0
  ENDUSING -- End of PERCH_DATA
ENDFOR --

END UpdtPncData
-----------------------------------------------------------------------------
ROUTINE CanRbtMove:BOOLEAN
-- PURPOSE: to verify robot can move
--
--
-- INPUT:
--            -
-- OUTPUT:  True if NOT held and NOT fault
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
 VAR

l_reset : BOOLEAN
l_status : INTEGER
l_strt_typ : INTEGER
l_sig_s     : INTEGER   --status of signalBEGIN

BEGIN

IF ($OPWORK.$UOP_DISABLE =0) THEN  -- if uop is enabled, check not being held
  l_status = IOVALRD(io_uopin, uopi_hold, l_sig_s)-- read the uop hold input
    IF ((l_sig_s = 0) OR (l_status <>0)) THEN -- hold is OFF
      POST_ERR(38000, 'HOMEUTIL needs HOLD input ON', 24034, 0) -- SYST-034 Hold Signal Lost
      RETURN(FALSE)
    ENDIF
ENDIF

 RESET(l_reset)
    IF l_reset THEN  --
      timer_var = 0
      CONNECT TIMER TO timer_var
      -- make sure servos are up and fault light is off
      WAIT FOR ($MOR_GRP[1].$SERVO_READY = TRUE) OR (timer_var > 4000)
      DISCONNECT TIMER timer_var
      IF $MOR_GRP[1].$SERVO_READY THEN
        RETURN(TRUE)
      ELSE --IF $MOR_GRP[1].$SERVO_READY
        --WRITE_DICT(prmp_file, uif_dict, gm_resu_fail, status)
        WRITE TPPROMPT(CR, 'ROBOT Fault needs to be clear')
      ENDIF --IF $MOR_GRP[1].$SERVO_READY
    ELSE --IF l_reset
        WRITE TPPROMPT(CR, 'ROBOT Fault needs to be clear')
      --WRITE_DICT(prmp_file, uif_dict, gm_res_fail, status)
    ENDIF --IF l_reset

RETURN(FALSE)

END CanRbtMove
-----------------------------------------------------------------------------
ROUTINE Set_Pr_JPos(p_posreg_num:integer;p_jposition: JOINTPOS IN GROUP[1])
-- PURPOSE:
--
-----------------------------------------------------------------------------
BEGIN

 SET_JPOS_REG(p_posreg_num,p_jposition,gm_status,1)
   IF (gm_status<>0) THEN
     POST_ERR(38000, 'Failed to set JOINT PR['+int2str(p_posreg_num)+'] Failed', gm_status, 0) --
   ENDIF

END Set_Pr_JPos
-----------------------------------------------------------------------------
ROUTINE Set_Pr_Pos(p_posreg_num:integer;p_position:position)
-- PURPOSE:
--
-----------------------------------------------------------------------------
BEGIN

 SET_POS_REG(p_posreg_num,p_position,status,1)
   IF (gm_status<>0) THEN
     POST_ERR(38000, 'Failed to set PR['+int2str(p_posreg_num)+'] Failed', gm_status, 0) --
   ENDIF

END Set_Pr_Pos
-----------------------------------------------------------------------------
ROUTINE Jog_it
-- PURPOSE: to launch the auto jogging
--
--
-----------------------------------------------------------------------------

BEGIN

-- Set the data based on user requested move type
-- Set Position registers based on the move type
-- Joint uses INC move, all others use CurPos with either offset or tool offset

-- Set NIPLOS to all zero using $MOR_GRP[x].$Nilpos

   Set_Pr_Pos(PRNum4JogINC,($MOR_GRP[CurGrpNum].$Nilpos))
   Set_Pr_JPos(PRNum4CurPos,cur_rbtJpos)
-- clear all registers so when writing only goes in the desired location
   Set_Pr_Pos(PRNum4Offset,($MOR_GRP[CurGrpNum].$Nilpos))
   Set_Pr_Pos(PRNum4NILPOS,($MOR_GRP[CurGrpNum].$Nilpos))

GET_VAR(entry, '*SYSTEM*' , '$MOR_GRP['+int2str(CurGrpNum)+'].$NILPOS', cur_Mov2_pos, gm_status)
   IF gm_status <> 0 THEN
     POST_ERR(38000, '[*SYSTEM*].$MOR_GRP['+int2str(CurGrpNum)+'].$NILPOS FAILED', gm_status, 0) --
   ENDIF

-- Set the move distance based on the coordinate of move

IF UserJogType = 0 THEN -- select user distance based on move
  JogDistance = UsrJogJntAmt
ELSE -- set world amount
  JogDistance = UsrJogXYZAmt
ENDIF

IF ((UserJogDir MOD 2)>0) THEN  -- Check if need to invert value
  JogDistance = JogDistance *(-1)
ENDIF

FOR i = 1 TO ARRAY_LEN(CurJntPos) DO -- reset to all zeros
  CurJntPos[i] = 0
ENDFOR --

CurElemntNum = (UserJogDir DIV 2)+(UserJogDir MOD 2) -- Set current pos location

  SELECT (UserJogType) OF --
    CASE (0):  -- Joint,
      CurJntPos[CurElemntNum] = JogDistance -- set distance in array
      CNV_REL_JPOS(CurJntPos,Cur_JogJpos,gm_status)-- make the position
        IF status = 0  THEN
          Set_Pr_JPos(PRNum4JogINC,Cur_JogJpos)
        ELSE
          POST_ERR(38000, 'Convert CurJntPos to Cur_JogJpos Failed', gm_status, 0) --
          RETURN
        ENDIF
    CASE (1,2,3,4):  -- JFram,World,Tool, User

       SELECT (CurElemntNum) OF --
         CASE (1):  -- X
           cur_Mov2_pos.location.x = JogDistance
         CASE (2):  -- Y
           cur_Mov2_pos.location.y = JogDistance
         CASE (3):  -- Z
           cur_Mov2_pos.location.z = JogDistance
         CASE (4):  -- W
  --         cur_Mov2_pos.Rotation.w = JogDistance oreintation
         CASE (5):  -- P
  --         cur_Mov2_pos.Rotation.p = JogDistance
         CASE (6):  -- R
  --        cur_Mov2_pos.Rotation.r = JogDistance
         CASE (7):  -- EXT1
           --cur_Mov2_pos.location.x = JogDistance
         CASE (8):  --
           --cur_Mov2_pos.location.x = JogDistance
         ELSE: --
       ENDSELECT --
       Set_Pr_Pos(PRNum4Offset,cur_Mov2_pos)
    ELSE: --
      POST_ERR(38000, 'Unknown JOG type '+int2str(UserJogType), gm_status, 0) --
  ENDSELECT --

  RETURN

END Jog_it
-----------------------------------------------------------------------------
ROUTINE Fnd_Clst_Pnc
-- PURPOSE: This routine will find the closest pounce and return the pounce structure
--
--
-----------------------------------------------------------------------------

BEGIN

UpdtPncData       -- call the routine to set all the pounce data to be checked

  PncClsestTo = 0
  Dist2Pounce = 100000 -- set distance so first examnine will set to start
  FOR i = 1 TO MaxNumPounc DO
    USING Perch_Data[i] DO --
      IF ((PR_RegNum >0) AND (PR2CurPosDis<>(-10000.0))) THEN -- enabled and good number, zero is not good
        IF PR2CurPosDis < Dist2Pounce THEN
          Dist2Pounce = PR2CurPosDis -- Set to new number for comparing
          PncClsestTo = i -- set as closest pounce arrary Number
        ENDIF
      ENDIF
    ENDUSING -- end using for Perch_Data
  ENDFOR

  IF (PncClsestTo = 0) THEN
    POST_ERR(38000, 'No Pounce was FOUND ??', 0, 0) --
    ABORT
  ENDIF

 IF rk_db THEN --debug
   WRITE ('Closest Pounce is PR[', Perch_Data[PncClsestTo].PR_RegNum,':',Perch_Data[PncClsestTo].PR_RegCmnt,']', CR)
 ENDIF

SetPRAryIndx -- setup the choices for selections

END Fnd_Clst_Pnc
-----------------------------------------------------------------------------
ROUTINE CnfrmMovHome
-- PURPOSE: To prompt the operator and ensure they want to move to the home position
-----------------------------------------------------------------------------
VAR

read_failed : BOOLEAN-- used of the dictioanr couldnt be read

BEGIN
   read_failed = FALSE

   IF (PncClsestTo = 0) OR (PncClsestTo > (ARRAY_LEN(Perch_Data))) THEN
     POST_ERR(38000, 'Closest Pounce is'+int2str(PncClsestTo)+' but INVALID', 0, 0) --
     ABORT
   ENDIF

   arystr[1] = int2str(Perch_Data[PR_Arrayindx[PR_ArrySlctd]].PR_RegNum) -- +':'+Perch_Data[PncClsestTo].PR_RegCmnt
   arystr[2] = Perch_Data[PR_Arrayindx[PR_ArrySlctd]].PR_RegCmnt
  -- read in prompt text and insert distance string
   asst_arystr[1] = 'arystr[1]'
   asst_arystr[2] = 'arystr[2]'

   -- read the string from dictionary so string can be added to the prompt feild
   read_dict_v('MPNC', asst_toHome, asst_arystr, prompt, gm_status)
   IF gm_status<>0 THEN
     POST_ERR(38000, 'ReadDICTV for MPNC failed '+int2str(asst_toHome)+' element', gm_status, 0) --
     read_failed = TRUE
   ENDIF

   IF (read_failed = FALSE) THEN
     read_dict('MPNC', asst_title, title, 1, 0, gm_status)-- read in title text
     IF gm_status<>0 THEN
       POST_ERR(38000, 'Readdict for MPNC failed '+int2str(asst_title)+' element', gm_status, 0) --
       read_failed = TRUE
     ENDIF
   ENDIF

   IF (read_failed = FALSE) THEN
     response = db_prompt(db_ps_yesno, title[1], prompt[1], db_rc_yes)
   ENDIF

  IF UNINIT(response) THEN
    response = db_rc_yes
  ENDIF

   IF (response <> db_rc_yes) OR (read_failed = TRUE) THEN -- need to prompt user if they want to finish move to home.
     POST_ERR(38000, 'User by-passed final move HOME', 0, 0) --
     ABORT
   ELSE -- yes or read failed
     POST_ERR(38000, 'User confirmed final move to HOME', 0, 0) --
  --   IF (Chk_loaded('HOMEROBOT')) THEN -- verify program is loaded to be able to call routine
  --     CALL_PROG('HOMEROBOT',0) -- tell to move to HOME using pounce paths
  --   ELSE
  --     POST_ERR(38000, 'HOMEROBOT program is NOT LOADED', 0, 0) --
  --   ENDIF
     RETURN -- all code is called from HOMEROBOT, so returning calls MOV_POUNCE(1,2)
   ENDIF

END CnfrmMovHome
-----------------------------------------------------------------------------
ROUTINE CnfrmPncNum
-- PURPOSE: To prompt the operator and ensure they want to move to the closest pounce
--          set by the FND_CLST_PNC routine.
-----------------------------------------------------------------------------
VAR

read_failed : BOOLEAN-- used of the dictioanr couldnt be read

BEGIN
   read_failed = FALSE

   IF (PncClsestTo = 0) OR (PncClsestTo > (ARRAY_LEN(Perch_Data))) THEN
     POST_ERR(38000, 'Closest Pounce is'+int2str(PncClsestTo)+' but INVALID', 0, 0) --
     ABORT
   ENDIF

   CNV_REAL_STR(Perch_Data[PncClsestTo].PR2CurPosDis,2,2,arystr[1])
   --arystr[1] = Real2Str(Perch_Data[PncClsestTo].PR2CurPosDis)
   arystr[2] = int2str(Perch_Data[PncClsestTo].PR_RegNum)+':'+Perch_Data[PncClsestTo].PR_RegCmnt
  -- read in prompt text and insert distance string
   asst_arystr[1] = 'arystr[1]'
   asst_arystr[2] = 'arystr[2]'

   -- read the string from dictionary so string can be added to the prompt feild
   read_dict_v('MPNC', asst_mess, asst_arystr, prompt, gm_status)
   IF gm_status<>0 THEN
     POST_ERR(38000, 'ReadDICTV for MPNC failed '+int2str(asst_mess)+' element', gm_status, 0) --
     read_failed = TRUE
   ENDIF

   IF (read_failed = FALSE) THEN
     read_dict('MPNC', asst_title, title, 1, 0, gm_status)-- read in title text
     IF gm_status<>0 THEN
       POST_ERR(38000, 'Readdict for MPNC failed '+int2str(asst_title)+' element', gm_status, 0) --
       read_failed = TRUE
     ENDIF
   ENDIF
   WRITE TPERROR(CHR(cc_clear_win))-- clear the error window from AE or other messages
   IF (read_failed = FALSE) THEN
     response = db_prompt(db_ps_yesno, title[1], prompt[1], db_rc_yes)
   ENDIF

  IF UNINIT(response) THEN
    response = db_rc_no
  ENDIF

   IF (response <> db_rc_yes) OR (read_failed = TRUE) THEN -- need to prompt user for which pounce they want.
     getuserPRNum
   ELSE
     PncToMoveTo = PncClsestTo -- Set the move to base on YES answer
   ENDIF

  WRITE TPERROR(CHR(cc_clear_win),'Move to PR[',Perch_Data[PncToMoveTo].PR_RegNum,'] is ',real2str(Perch_Data[PncToMoveTo].PR2CurPosDis),' mm away')

  RETURN  --by the time returns ready to move

END CnfrmPncNum
-----------------------------------------------------------------------------
ROUTINE GetUserPRNum
-- PURPOSE: to prompt the operator and ask them the available pounce to use
--          on the way to get in cycle.
--
-----------------------------------------------------------------------------

BEGIN

SetPRAryIndx -- setup the choices for selections

-- Choices are setup, now prompt the operator for selection
PncUserSlctd = PncClsestTo -- make default the one the user passed on

FORCE_SPMENU(tp_panel,SPI_TPUSER2,1) -- force the user 2 screen to display forms

ENABLE CONDITION[CH_SHFT_F4]

REPEAT --

IF ((PR_ArrySlctd = 0) OR (PR_ArrySlctd > ARRAY_LEN(PR_Arrayindx))) THEN
  POST_ERR(38000, 'PR_ArrySlctd is ' +int2str(PR_ArrySlctd)+' ???', 0, 0) --
  ABORT
ENDIF

Value_array[1]= 'PncUserSlctd' -- used to display the current PR # displaying
Value_array[2]= 'Perch_Data['+int2str(PR_Arrayindx[(PR_ArrySlctd)])+'].PR2CurPosDis' -- display the distance to robot --was PncUserSlctd
Value_array[3]= 'Perch_Data['+int2str(PR_Arrayindx[(PR_ArrySlctd)])+'].PR_RegNum' -- display PR number for use --was PncUserSlctd

all_done = FALSE
-- kc_f1_type to handle the TYPE key processing with custommenu[x].$option = 31 will have TYPE work No FORCE USER!
term_mask =  kc_item_chng + kc_f1_type + kc_func_key-- kc_f1_type + kc_func_key  --kc_other
term_char = -1

ENABLE CONDITION[CH_SHFT_F4]

  DISCTRL_FORM('MPNC', select_MPNC, value_array, inact_array, change_array, term_mask, def_item, term_char, status)

 DISABLE CONDITION[CH_SHFT_F4]

    IF status<>0 THEN
      all_done = TRUE
      POST_ERR(38000, 'HOMEUTIL SELECT_DATA Display Failed', status, 2) --
    ENDIF

  SELECT (term_char) OF -- select how the form was ended or which key Cell
    CASE(ky_new_menu):

    CASE(ky_f1): --

    CASE(ky_f2,ky_f2_s):  -- DONE was selected
       all_done = TRUE
    CASE(ky_f3,ky_f3_s): -- Include SHIFT in Case user is teaching -- Selected EXEC.

    CASE(ky_f4,ky_f4_s):

    CASE(ky_undef):
    ELSE: --
  ENDSELECT   --det_term_chr OF

 PR_ArrySlctd = PncUserSlctd

UNTIL ((term_char = ky_new_menu) OR (status <>0) OR (all_done = TRUE)) -- New Screen selected


 PncToMoveTo = PR_Arrayindx[PR_ArrySlctd] -- look into array, because not in sequncial order
                                          -- Not all configured pounces maybe taught for instance
-- log the users input for the record
  IF UNINIT(PR_Choices[PncUserSlctd]) THEN
    PR_Choices[PncUserSlctd] = 'UNKNOWN??'
  ENDIF
                 -- add one because PR_Choices array is one off
  POST_ERR(38000,PR_Choices[PncUserSlctd+1]+ ' selected by User for Move', 0, 0) --
  DELAY 100 -- delay so TPERR can display correctly when routine ends

END GetUserPRNum
-----------------------------------------------------------------------------
ROUTINE MoveToPounc
-- PURPOSE: to move to the pounce position as the operator holds a button,or NOT.
--
-----------------------------------------------------------------------------

BEGIN


IF (Jog_Enabled) AND NOT (tp_enabled) THEN -- Set so Default direction is initial direction for jog feature
  Set_I_sVar('$JCR_GRP[1].$JOG_COORD',DefltJogType)
  IF DefltJogType=3 THEN -- if the default is TOOL set direction to Z-
    UserJogDir = 5
  ELSE -- Else Make Z+ or J3+ for all others
    UserJogDir = 6
  ENDIF
ENDIF

RESTART::

 FOR i = 1 TO ARRAY_LEN(inact_array) DO -- Initialize all to use
 inact_array[i]=FALSE
ENDFOR --

Jog_active = FALSE -- turn off Jog feature, even if disabled, code read this to make TP
Move_key   = FALSE -- Turn off the move is to the destination pounce

-- Check if configured to move without confirmation
IF (AutoToClst = FALSE) OR (Perch_data[(PR_Arrayindx[PR_ArrySlctd])].PR2CurPosDis > MaxDstAuto)  THEN

  REPEAT --  if the user is involved
 IF UsrCordAvail THEN  -- if user can change cordinate type
  GET_VAR(entry, '*SYSTEM*' , '$JCR_GRP[1].$JOG_COORD', UserJogType, gm_status)
    IF gm_status <> 0 THEN
      POST_ERR(38000, '[*SYSTEM*].$JCR_GRP[1].$JOG_COORD FAILED', gm_status, 0) --
    ENDIF
    ENABLE CONDITION[CH_CORDUPDT]
 ELSE
   UserJogType = DefltJogType
    IF UserJogType=3 THEN
      UserJogDir = 5
    ELSE
      UserJogDir = 6
    ENDIF
   inact_array[2] = TRUE -- If cant jog dont let them CHange the Direction
 ENDIF

  UserJogType = UserJogType+1-- need to add one so array displayed reflects varaible

    IF Jog_Enabled AND NOT (tp_enabled) THEN -- if jog feature avaiable, Not Jog in TP, do it yourself
      Value_array[1]= 'Perch_Data['+int2str(PR_Arrayindx[(PR_ArrySlctd)])+'].PR2CurPosDis' -- display the distance to robot --was PncUserSlctd
      Value_array[2]= 'PncToMoveTo' -- display PR number for use
      Value_array[3]= 'Perch_Data['+int2str(PR_Arrayindx[(PR_ArrySlctd)])+'].PR_RegCmnt' -- used to display the current program to start
      Value_array[4]= 'UserMoType'
      Value_array[5]= 'PncToMoveTo' -- display PR number for use
      Value_array[6]= 'Perch_Data['+int2str(PR_Arrayindx[(PR_ArrySlctd)])+'].PR_RegCmnt' -- used to display the current program to start
      Value_array[7]= 'PncToMoveTo' -- display PR number for use
      Value_array[8]= 'Perch_Data['+int2str(PR_Arrayindx[(PR_ArrySlctd)])+'].PR_RegCmnt' -- used to display the current program to start
      Value_array[9]= 'UserJogStr['+int2str(UserJogType)+']' -- display the Cordinate to jog in
      Value_array[10]= 'UserJogDir' -- display the Direction to jog in
      IF HMIMoveEnbld THEN
        curformNum = user_JPNCwD -- user selection has DO button description
      ELSE
        curformNum = user_JPNC
      ENDIF
      SetJogDirInf -- set the choices up for user to select direction
      def_item = 1 --make default item #1 so user can see [CHOICE] instead of MOVE
  -- enable handler for Key changing changing    UsrJogDirStr
    ELSE -- Jog Feature is Disabled
      Value_array[1]= 'Perch_Data['+int2str(PR_Arrayindx[(PR_ArrySlctd)])+'].PR2CurPosDis' -- display the distance to robot --was PncUserSlctd
      Value_array[2]= 'PncToMoveTo' -- display PR number for use
      Value_array[3]= 'Perch_Data['+int2str(PR_Arrayindx[(PR_ArrySlctd)])+'].PR_RegCmnt' -- used to display the current program to start
      Value_array[4]= 'UserMoType'
      Value_array[5]= 'PncToMoveTo' -- display PR number for use
      Value_array[6]= 'Perch_Data['+int2str(PR_Arrayindx[(PR_ArrySlctd)])+'].PR_RegCmnt' -- used to display the current program to start
      Value_array[7]= 'PncToMoveTo' -- display PR number for use
      Value_array[8]= 'Perch_Data['+int2str(PR_Arrayindx[(PR_ArrySlctd)])+'].PR_RegCmnt' -- used to display the current program to start
      IF HMIMoveEnbld THEN
        curformNum = user_MPNCwD -- user selection has DO button description
      ELSE
        curformNum = user_MPNC
      ENDIF
    ENDIF

    IF (UsePLC4Rcvy) THEN -- if not enabled dont use
      ENABLE CONDITION[CH_DO_BUTTON] -- Monitor for DO to trigger moving
    ENDIF

    all_done = FALSE
    -- kc_f1_type to handle the TYPE key processing with custommenu[x].$option = 31 will have TYPE work No FORCE USER!
    term_mask =  kc_item_chng  + kc_f1_type + kc_func_key + ky_prev -- kc_f1_type + kc_func_key  --kc_other
    term_char = -1
    FORCE_SPMENU(tp_panel,SPI_TPUSER2,1) -- force the user screen to display forms
    DISCTRL_FORM('MPNC',curformNum, value_array, inact_array, change_array, term_mask, def_item, term_char, status)
      IF status<>0 THEN
        all_done = TRUE
        POST_ERR(38000, 'HOMEUTIL user_mpnc Display Failed', status, 2) --
      ENDIF

    DISABLE CONDITION[CH_CORDUPDT]

    IF (UsePLC4Rcvy) THEN -- if not enabled dont use
      DISABLE CONDITION[CH_DO_BUTTON]
    ENDIF
  -- form has ended

    SELECT (term_char) OF -- select how the form was ended or which key Cell
      CASE(ky_prev, ky_prev_s):
          UpdtDisttoPR(PncClsestTo) -- UpdtPncData incase user moved robot
          GetUserPRNum -- go back to allow user to select differant pounce
          GOTO RESTART -- need to diplays form again
      CASE(ky_new_menu):
          WRITE TPERROR(CHR(cc_clear_win),'New Menu exit HOMEUTIL')
          ABORT
      CASE(ky_f1): -- [TYPE] functioning

      CASE(ky_f2,ky_f2_s):  -- DONE was selected

      CASE(ky_f3,ky_f3_s): -- Include SHIFT in Case user is teaching -- Selected MOVE.
        Jog_active = FALSE -- turn off Jog feature, even if disabled, code read this to make TP
        Move_key = TRUE -- Turn on the move is to the destination pounce
        all_done = TRUE
      CASE(ky_f4,ky_f4_s):
        Jog_active = TRUE -- turn on Jog feature, even if disabled, code read this to make TP
        Move_key =  FALSE -- Turn off the move is to the destination pounce
        all_done = TRUE
      CASE(ky_undef):
      ELSE: --
    ENDSELECT   --det_term_chr OF

  UNTIL ((term_char = ky_new_menu) OR (status <>0) OR (all_done = TRUE)) -- New Screen selected
ENDIF -- endif for autotoclst indicating the robot should move without Operator assisting

IF (AutoToClst = TRUE) THEN -- Need to set so correct TP instruction used
  Move_Key  = TRUE
ENDIF

  -- need to set Tool Frame and Uframe to Defaults so PR is correct.
   Set_I_sVar('$MNUFRAMENUM[1]',baseUFrmNum)
   Set_I_sVar('$MNUTOOLNUM[1]',baseTfrmNum)

MakeTPProg -- make TP program for Jog or Move to PR

  -- Need to ensure can run...ie NOT FAULTED state
IF NOT(CanRbtMove) THEN
  GOTO RESTART -- cant start return for next
ELSE
  WRITE TPERROR(CHR(cc_clear_win),'All clear to use robot')
ENDIF

IF Jog_Active THEN
  jog_it
--  GOTO RESTART -- jog done return for next
  tp_key = ky_f4
  tp_key_s = ky_f4_s
ELSE -- set to watch MOVE F3 for motion
  tp_key = ky_f3
  tp_key_s = ky_f3_s
ENDIF

  MovPrgStartd = FALSE

   IF (TP_ENABLED) THEN -- call builtin to pass correct param
     tp_is_on = TRUE
   ELSE
     tp_is_on = FALSE
   ENDIF

  RUN_TASK(userprogname,0,FALSE,tp_is_on,curgrpnum,gm_status)

    IF gm_status <>0 THEN
      POST_ERR(38000, 'Running '+userprogname+' Failed to Start', gm_status, 0) --
      GOTO RESTART -- cant start return for next
    ELSE
      WRITE TPERROR(CHR(cc_clear_win),'Robot running ',userprogname)
      GET_TSK_INFO(userprogname,0,TSK_STATUS,prg_status,prg_str,gm_status)
        IF Status =0 THEN
          SELECT (prg_status) OF --
          CASE (PG_RunAccept,PG_RUNNING):  --
                MovPrgStartd = TRUE
          ELSE: --
          ENDSELECT --
        ELSE
          POST_ERR(38000, 'Failed to get task Status'+userprogname, gm_status, 0) --
        ENDIF
    ENDIF
    FORCE_SPMENU(tp_panel,SPI_TPUSER,1)
    clr_stnd_scr(gm_status)

    IF (tp_key = ky_f3) THEN
      WRITE (CR,CR, 'Moving Robot, Release F3 to Stop')
    ELSE
      WRITE (CR,CR, 'Jogging Robot, Release F4 to Stop')
    ENDIF
-- check if pendant enabled oitherwise TP cant start without evaluation
      exit=FALSE
       WHILE (((AutoToClst = TRUE) OR (DIN[PLC_DoButton] AND UsePLC4Rcvy = TRUE) OR (TPIN[tp_key]) OR (TPIN[tp_key_s])) AND (exit=FALSE)) DO --
         whiletext = (real2str(Perch_data[(PR_Arrayindx[PR_ArrySlctd])].PR2CurPosDis))+' mm to get to PR['+(int2str(Perch_data[(PR_Arrayindx[PR_ArrySlctd])].PR_RegNum))+']'
             WRITE TPERROR(CHR(cc_clear_win),whiletext)
             UpdtDisttoPR(PR_Arrayindx[PR_ArrySlctd]) -- UpdtPncData update the distance for display
           DELAY 100
           GET_TSK_INFO(userprogname,0,TSK_STATUS,prg_status,prg_str,gm_status)
           IF gm_status = 0 THEN
             exit=FALSE
             SELECT (prg_status) OF --
               CASE (PG_ABORTED):  -- check if at the reference position now
                 WRITE TPERROR(CHR(cc_clear_win),'PR[',int2str(PncToMoveTo),':',Perch_data[(PR_Arrayindx[PR_ArrySlctd])].PR_RegCmnt,'] Move DONE')
                 exit = TRUE
               CASE (PG_PAUSED):  --
                 exit = TRUE -- set so gets out of loop
                 GOTO RESTART -- need to diplays form again
               ELSE: --
             ENDSELECT --
           ENDIF

       ENDWHILE --

       IF exit = FALSE THEN
         --was paused,have to abort so SHFT FWD doesnt start it
         ABORT_TASK(userprogname,TRUE,TRUE,gm_status)
           IF gm_status<>0 THEN
             POST_ERR(38000, 'Failed to ABORT' +userprogname, gm_status, 0) --
           ENDIF
       ENDIF

       UpdtDisttoPR(PR_Arrayindx[PR_ArrySlctd]) -- UpdtPncData update the distance

       IF Perch_data[(PR_Arrayindx[PR_ArrySlctd])].PR2CurPosDis <= atPosDist THEN
         WRITE TPERROR(CHR(cc_clear_win),'Robot Completed Move to PR[',PncToMoveTo,']')
         DELAY 1000
       ELSE
         WRITE TPERROR(CHR(cc_clear_win),'User CANCELED PR[',PncToMoveTo,':',Perch_data[(PR_Arrayindx[PR_ArrySlctd])].PR_RegCmnt,'] Move')
         clr_stnd_scr(gm_status)
         GOTO RESTART -- done return for next
       ENDIF

END MoveToPounc
-----------------------------------------------------------------------------
ROUTINE PLC_Do_Move
-- PURPOSE: form manager currectly doesnt support SHFT F4 for choice selection
-- CALLED BY: Condition handler
-----------------------------------------------------------------------------
BEGIN

   SIM_KEY('TPKB',ky_f3)

-- do below to get the code to execute the move portion after exiting the DISCTRL FORM
        Jog_active = FALSE -- turn off Jog feature, even if disabled, code read this to make TP
        Move_key = TRUE -- Turn on the move is to the destination pounce
        all_done = TRUE

END PLC_Do_Move
-----------------------------------------------------------------------------
ROUTINE chk_shifted
-- PURPOSE: form manager currectly doesnt support SHFT F4 for choice selection
-- CALLED BY: Condition handler
-----------------------------------------------------------------------------
BEGIN

   SIM_KEY('TPKB',ky_f4)
--WRITE TPERROR(CHR(cc_clear_win),'SIMED KY_F4 function')

END chk_shifted
-----------------------------------------------------------------------------
ROUTINE chk_coordnt
-- PURPOSE: Check if the coordinates changed by user
--
-----------------------------------------------------------------------------
BEGIN
 CoordChanged = TRUE
 SIM_KEY('TPKB',ky_f6) -- force key so screen refreshes to reflect change coordinate
 ENABLE CONDITION[CH_CORDUPDT]
END chk_coordnt
-----------------------------------------------------------------------------
ROUTINE CleanupIO
-- PURPOSE: To clean up the I/O set and needs to be reset on an abort
--
--
-----------------------------------------------------------------------------

BEGIN

  IF (UsePLC4Rcvy = TRUE) THEN
    gm_status = iovalset(io_dout, HomePrcActDO, 0)
    Set_B_sVar('$PRMPDSPON',FALSE)
  ENDIF

  clr_stnd_scr(gm_status)
  WRITE TPERROR(CHR(cc_clear_win),'')
  SIM_KEY('TPKB',ky_new_menu)-- kills any forms running?
  WRITE TPPROMPT(CHR(cc_clear_win))

END CleanupIO
--************************************************************************
--                 Main Body of Program
--************************************************************************

BEGIN
Current_Ver = Version -- Set the version for reference

InitHomedata -- Initialize vars

-- this is required in case user is pressing the shift key and F4 [CHOICE]
 PURGE CONDITION[CH_SHFT_F4] -- form manager currectly doesnt support SHFT F4 for choice selection
 CONDITION[CH_SHFT_F4]: --
 WHEN (TPIN[ky_f4_s]+) DO --
   chk_shifted
 ENDCONDITION --

 PURGE CONDITION[CH_CORDUPDT] -- watch for user to update the jog type
 CONDITION[CH_CORDUPDT]: --
 WHEN (TPIN[202]+) DO -- tpi_coord_s=202
  ENABLE CONDITION[CH_CORDCHNGD]
  WHEN (TPIN[187]+) DO --
    chk_coordnt
 ENDCONDITION --

PURGE CONDITION[CH_CORDCHNGD]
CONDITION[CH_CORDCHNGD]: -- Watch for user entry
WHEN (TPIN[ky_f1]+) OR (TPIN[ky_f2]+) OR (TPIN[ky_f3]+) OR (TPIN[ky_f4]+) DO --
  chk_coordnt
WHEN (TPIN[ky_f1_s]+) OR (TPIN[ky_f2_s]+) OR (TPIN[ky_f3_s]+) OR (TPIN[ky_f4_s]+) DO --
  chk_coordnt
WHEN (TPIN[ky_prev]+) OR (TPIN[ky_prev_s]+) OR (TPIN[ky_enter]+) DO --
  ENABLE CONDITION[CH_CORDUPDT]
ENDCONDITION --

PURGE CONDITION[CH_DO_BUTTON]
CONDITION[CH_DO_BUTTON]: --
  WHEN (DIN[PLC_DoButton]+) DO --
   PLC_Do_Move
ENDCONDITION --

PURGE CONDITION[CH_PROGABORT]
CONDITION[CH_PROGABORT]: --
WHEN (ABORT) DO --
   NOABORT
 --  UNPAUSE
   CleanupIO
  -- ABORT
ENDCONDITION --

chk_TP_only -- Go verify we can run, IF TP only and not in that state, will abort.

ENABLE CONDITION[CH_PROGABORT]

IF (UsePLC4Rcvy = TRUE) THEN
  gm_status = iovalset(io_dout , HomePrcActDO, 1)
  IF gm_status <>0 THEN
    POST_ERR(38000, 'Failed to set DO['+int2str(HomePrcActDO)+']=ON', gm_status, 0) --
  ENDIF
  Set_B_sVar('$PRMPDSPON',TRUE)
ENDIF

Fnd_Clst_Pnc -- Set Closest pounce position relative to current position

-- Check if configured to move without confirmation or distance is more than the maximum without promting
-- Prompt User to confirm this is PR they want to move to.
IF (AutoToClst = FALSE) OR (Perch_data[PncClsestTo].PR2CurPosDis > MaxDstAuto)  THEN   --PncToMoveTo
  CnfrmPncNum  -- Prompt operator for findings
ENDIF

MoveToPounc -- Number should be known, move there using operator input.

IF (Perch_Data[PR_Arrayindx[PR_ArrySlctd]].PR_RegNum>1) THEN -- If not at home
  CnfrmMovHome -- Confirm user wants to move to home
ELSE
  WRITE TPERROR(CHR(cc_clear_win),'Robot is at HOME position')
ENDIF

  DISABLE CONDITION[CH_PROGABORT]

   IF (UsePLC4Rcvy = TRUE) THEN
    -- DOUT[HomePrcActDO] = OFF
     gm_status = iovalset(io_dout, HomePrcActDO, 0)
     Set_B_sVar('$PRMPDSPON',FALSE)
   ENDIF

  clr_stnd_scr(gm_status)

END HOMEUTIL

