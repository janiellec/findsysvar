--          
--    This material is the joint property of Fanuc Robotics Corporation  and
--    FANUC  LTD  Japan,  and  must  be  returned  to  either Fanuc Robotics
--    Corporation or FANUC LTD Japan immediately upon` request.  This  GET_PORT_VAL
--    and   the  information  illustrated  or  contained  herein  may  not  be
--    reproduced, copied, used, or transmitted in whole or in part in any  way
--    without the prior written consent of both Fanuc Robotics and FANUC.
--
--             All Rights Reserved
--             Copyright (C)   2003
--             Fanuc Robotics Corporation
--             FANUC LTD Japan
--
--             Karel is a registered trademark of
--             Fanuc Robotics Corporation
--    +
--    Program: temptask - Sealing Application Temperature Related Task
--
--    Description:
--      This program was designed as an interface for temperature 
--      control and monitoring functions.
--      This program is started by the shell on powerup.
--
--    Language: KAREL
--
--    Source File:   
--
--    Author: David R. Friedeman
--            Fanuc Robotics Corporation
--            3900 West Hamlin Road
--            Rochester Hills, Michigan    48309-3253
--
--    Modification history:

--    11-JAN-18 FRIEDEMAN V8.33/01 Created a neutered version of this file for
--                        SCA Anti-Chip at Arlington.
--

------------------------------------------------------------------
PROGRAM tcu_task
------------------------------------------------------------------
%PRIORITY = 75
--%SYSTEM
--%INVISIBLE
%COMMENT='TCU_TASK V833/01'
%NOBUSYLAMP
%NOLOCKGROUP
%STACKSIZE = 5000
%RWACCESS
%NOPAUSE = ERROR + COMMAND + TPENABLE
%NOABORT = ERROR + COMMAND
%CMOSVARS

-- Softpart built-ins
%ENVIRONMENT IOBLT    -- iovalset and iovalrd
%ENVIRONMENT IOSETUP  -- get_port_val
--%ENVIRONMENT SLCLDEF  -- $slcellio
%ENVIRONMENT SLDEF    -- $sliomap and $slsetup
--%ENVIRONMENT CELLDEF  -- common application shell cell vars $cellio
%ENVIRONMENT SYSDEF   -- general system variables
%ENVIRONMENT REGOPE   -- set_real_reg and set_int_reg
--%ENVIRONMENT IPSDEF   -- $IPS_WORK sysvars
--%ENVIRONMENT ISDEF    -- $IS_MOR sysvars
%ENVIRONMENT STRNG
--%ENVIRONMENT SLISDEF
--%ENVIRONMENT TIM

--%INCLUDE slevshll     -- Shell environment constants
--%INCLUDE sliscons
%include kliotyps
%INCLUDE kliouop      -- UOP I/O constants
%INCLUDE klevkeys     -- TP I/O constants
%INCLUDE etdccust       -- Custom Error Codes

CONST

  TURN_ON    = 1
  TURN_OFF   = 0
  
  SUCCESS    = 0

  ER_WARN      =  0
  UPDATE_TIME  = 10   -- TCU updates the command approx. every 10 seconds.
  CH_FLT_RESET = 803  -- Condition Handler owned by TCU_TASK
  CH_TCU_FAULT = 805  -- Monitors to enusure the HEAT/CHILL are not ON
                      -- at the same time.

  CMD_HEAT     = 1
  CMD_CHILL    = 2
  CMD_DISABLED = 3
  CMD_ERROR    = 4
  CMD_IDLE     = 5

  MODE_DSBL    = 1
  MODE_SETPNT  = 2
  MODE_VISC    = 3
  MODE_ABORT   = 4
  
  MAX_TCU_ZONE = 12

  IGN_OFFLN    = 128 -- Stop "Offline" errors for IOVALSET
  
TYPE

  TCU_T FROM TCU_TASK = STRUCTURE  

    tcu_zon_name : ARRAY [MAX_TCU_ZONE] OF STRING[24]
  
    do_tcuheat_t : ARRAY [MAX_TCU_ZONE] OF INTEGER -- TCU Heater Output
    do_tcuheat_i : ARRAY [MAX_TCU_ZONE] OF INTEGER -- TCU Heater Output
    do_tcucold_t : ARRAY [MAX_TCU_ZONE] OF INTEGER -- TCU Chiller Output
    do_tcucold_i : ARRAY [MAX_TCU_ZONE] OF INTEGER -- TCU Chiller Output
    do_tcufan_t  : ARRAY [MAX_TCU_ZONE] OF INTEGER -- TCU Fan Output
    do_tcufan_i  : ARRAY [MAX_TCU_ZONE] OF INTEGER -- TCU Fan Output

    di_tcurdy_t  : INTEGER -- TCU Ready
    di_tcurdy_i  : INTEGER -- TCU Ready
    di_lo_wtrf_t : INTEGER -- Low Water Fault
    di_lo_wtrf_i : INTEGER -- Low Water Fault
    di_hi_tmpf_t : INTEGER -- High Temperature Fault
    di_hi_tmpf_i : INTEGER -- High Temperature Fault

    ai_temp_t : ARRAY [MAX_TCU_ZONE] OF INTEGER -- Temperature Sensor
    ai_temp_i : ARRAY [MAX_TCU_ZONE] OF INTEGER -- Temperature Sensor 

    -- Output to indicate that the TCU is DISABLED
    do_tcudsbl_t : INTEGER -- TCU Disabled
    do_tcudsbl_i : INTEGER -- TCU Disabled
	do_pwrecho_t : INTEGER -- Water TCU OFF Echo To PLC
	do_pwrecho_i : INTEGER -- Water TCU OFF Echo To PLC
	
	-- TCU Hardware Protection
	do_tempsok_t : INTEGER -- All Temperatures In Range
	do_tempsok_i : INTEGER -- All Temperatures In Range
	
    tcu_fan_ok   : ARRAY [MAX_TCU_ZONE] OF INTEGER
    tcu_heat_ok  : ARRAY [MAX_TCU_ZONE] OF INTEGER
    tcu_cold_ok  : ARRAY [MAX_TCU_ZONE] OF INTEGER
   
    a_p_gain     : ARRAY [MAX_TCU_ZONE] OF REAL-- User-defined 'P-Gain' component
    a_i_gain     : ARRAY [MAX_TCU_ZONE] OF REAL-- User-defined 'I-Gain' component
    bias_temp    : ARRAY [MAX_TCU_ZONE] OF REAL -- User-defined temperature bias
	t_xdcr_bias  : ARRAY [MAX_TCU_ZONE] OF INTEGER -- Transducer Tick Bias @ 4mA
	t_xdcr_scale : ARRAY [MAX_TCU_ZONE] OF REAL -- Transducer "Degrees per Tick"

    tcu_exists   : BOOLEAN -- 
	num_zones    : INTEGER -- Number of zones for this TCU
	last_num_zon : INTEGER
	
	cur_sel_zon  : INTEGER -- Currently Selected TCU Zone
	last_sel_zon : INTEGER -- Previously Selected Zone
	
    tcu_enable   : ARRAY [MAX_TCU_ZONE] OF BOOLEAN
    tcu_error    : ARRAY [MAX_TCU_ZONE] OF BOOLEAN
    tcu_setpoint : ARRAY [MAX_TCU_ZONE] OF REAL      -- Current TCU Setpoint

    t_lo_temp_f  : ARRAY [MAX_TCU_ZONE] OF REAL      -- Gun Low temp fault threshold
    t_lo_temp_w  : ARRAY [MAX_TCU_ZONE] OF REAL      -- Gun Low temp warning threshold
    t_hi_temp_w  : ARRAY [MAX_TCU_ZONE] OF REAL      -- Gun High temp warning threshold
    t_hi_temp_f  : ARRAY [MAX_TCU_ZONE] OF REAL      -- Gun High temp fault threshold

    i_accumulatr : ARRAY [MAX_TCU_ZONE] OF REAL      -- accumulates the 'I' gain component over time
    status       : INTEGER
    prop_calc    : ARRAY [MAX_TCU_ZONE] OF REAL
    integ_calc   : ARRAY [MAX_TCU_ZONE] OF REAL
    tcu_cmd_calc : ARRAY [MAX_TCU_ZONE] OF INTEGER
    tcu_cmd_typ  : ARRAY [MAX_TCU_ZONE] OF INTEGER
    tcu_cmd_pct  : ARRAY [MAX_TCU_ZONE] OF INTEGER
    tcu_cur_temp : ARRAY [MAX_TCU_ZONE] OF REAL
	tcu_mode_str : ARRAY [MAX_TCU_ZONE] OF STRING[12]
    tcu_ctl_mode : INTEGER

    tcu_diag_enb : BOOLEAN
    c_dbg_str    : STRING[10]
    t_dbg_str    : STRING[10]
    p_dbg_str    : STRING[10]
    i_dbg_str    : STRING[10]

    ep_tcu_t_inv : ARRAY [MAX_TCU_ZONE] OF BOOLEAN
    ep_tcuio_inv : ARRAY [MAX_TCU_ZONE] OF BOOLEAN
    ep_tlo_tmp_f : ARRAY [MAX_TCU_ZONE] OF BOOLEAN
    ep_tlo_tmp_w : ARRAY [MAX_TCU_ZONE] OF BOOLEAN
    ep_thi_tmp_w : ARRAY [MAX_TCU_ZONE] OF BOOLEAN
    ep_thi_tmp_f : ARRAY [MAX_TCU_ZONE] OF BOOLEAN
    ep_tcufaninv : ARRAY [MAX_TCU_ZONE] OF BOOLEAN
    ep_tcunotrdy : ARRAY [MAX_TCU_ZONE] OF BOOLEAN
    ep_txdcrdsco : ARRAY [MAX_TCU_ZONE] OF BOOLEAN
    ep_setpntlim : ARRAY [MAX_TCU_ZONE] OF BOOLEAN

    ep_viscparam : BOOLEAN
    ep_gunpioinv : BOOLEAN
    ep_gpxdcdsco : BOOLEAN
    ep_viscerr_h : BOOLEAN
    ep_viscerr_l : BOOLEAN
  
    ep_wtcunorun : BOOLEAN
    ep_wtculowtr : BOOLEAN
    ep_wtcuhitmp : BOOLEAN

    --------------------------------------------------------------------------
    -- Variables for Temperature/Viscosity Control
    --------------------------------------------------------------------------
 
    fan_error    :BOOLEAN
    prev_io_stat :INTEGER -- Previous I/O State for Heating/Cooling
 
    -- Heating Adjustment for when Heating/Cooling occur at different rates
    cmd_heat_adj :REAL
    any_zone_dsb :BOOLEAN
	all_temps_ok :BOOLEAN
	inrange_tol  :ARRAY [MAX_TCU_ZONE] OF REAL
	temp_inrange :ARRAY [MAX_TCU_ZONE] OF BOOLEAN
  ENDSTRUCTURE

  
VAR
  %INCLUDE gmcfgpnt
  %INCLUDE gmpntvar
  
  tcu : ARRAY[5] OF TCU_T

  tcu_num      : INTEGER  
  zone_num     : INTEGER  
  disp_app_num : INTEGER -- Location of the Dispense Application Plug-In
  last_eq_num  : INTEGER

  vol_units    : STRING[3]
  use_met_temp : BOOLEAN
  use_met_vol  : BOOLEAN
  
  abs_max_temp : INTEGER
  abs_min_temp : INTEGER
  max_gp_scale : REAL
  min_gp_scale : REAL
  max_gp_bias  : INTEGER
  min_gp_bias  : INTEGER

  tcu_loop_num : INTEGER
  tcu_hfo      : BOOLEAN
  init_var_enb : BOOLEAN
  init_met_deg : BOOLEAN -- Set temperature parameters for Degrees Celsius
  init_met_vol : BOOLEAN -- Set volume parameters for LPM
  init_eng_deg : BOOLEAN -- Set temperature parameters for Degrees Fahrenheit
  init_eng_vol : BOOLEAN -- Set volume parameters for GPM

  force_update : BOOLEAN -- Force menu updates
  
  dummy_int    : INTEGER  
  loop         : INTEGER
  status       : INTEGER

  tcu_ele_used : BOOLEAN
  tcu_wtr_used : BOOLEAN  
  


------------------------------------------------------------------------
-- ROUTINE int_to_strg(int:integer) :STRING
-- Converts an integer (range 0 to +/-999999) to an ascii string
--
-- Input:
--   INTEGER  - int      - Integer to be converted to a string
-- Output:
--   STRING   - returned - CHAR equivalent to the integer parameter
-- Called by:
--   style_name and some POST_ERR calls
------------------------------------------------------------------------
ROUTINE int_to_strg(int:INTEGER):STRING
VAR
  l_text: STRING[6]

BEGIN
  l_text = ''                                 --Start with nothing
  CNV_INT_STR(int,STR_LEN(l_text),0,l_text)   --Convert int to string
  l_text = SUB_STR(l_text,2,STR_LEN(l_text))  --Remove leading blank
  RETURN (l_text)                             --Return new string
END int_to_strg

------------------------------------------------------------------------------
ROUTINE clr_flt_flag -- Clears the 'Fault Posted' flag when the user presses
                     -- the reset button
------------------------------------------------------------------------------
VAR
  l_tcu_num     : INTEGER
  l_zon_num     : INTEGER
  
BEGIN

FOR l_tcu_num = 1 TO $SLEQNUM DO

  USING tcu[l_tcu_num] DO
    FOR l_zon_num = 1 TO MAX_TCU_ZONE DO
 	  ep_tcu_t_inv[l_zon_num] = FALSE
      ep_tcuio_inv[l_zon_num] = FALSE
      ep_tlo_tmp_f[l_zon_num] = FALSE
      ep_tlo_tmp_w[l_zon_num] = FALSE
      ep_thi_tmp_w[l_zon_num] = FALSE
      ep_thi_tmp_f[l_zon_num] = FALSE
      ep_tcufaninv[l_zon_num] = FALSE
      ep_tcunotrdy[l_zon_num] = FALSE
      ep_txdcrdsco[l_zon_num] = FALSE
      ep_setpntlim[l_zon_num] = FALSE
    ENDFOR
	
    ep_viscparam = FALSE
    ep_gunpioinv = FALSE
    ep_gpxdcdsco = FALSE
    ep_viscerr_h = FALSE
    ep_viscerr_l = FALSE

    ep_wtcunorun = FALSE
    ep_wtculowtr = FALSE
    ep_wtcuhitmp = FALSE

  ENDUSING

ENDFOR
  -- Someone pressed RESET, so there was probably an error.

  ENABLE CONDITION[CH_FLT_RESET]
END clr_flt_flag

------------------------------------------------------------------------------
ROUTINE get_cur_temp(l_tcu_num : INTEGER; l_zon_num : INTEGER) -- Reads the analog temperature transducers and 
--                   -- saves the data to the registers.
------------------------------------------------------------------------------
VAR
  l_status    : INTEGER
  l_io_value  : INTEGER
  l_io_value2 : INTEGER  
  l_real      : REAL
  
BEGIN

USING tcu[l_tcu_num] DO

  -- Get the temperature for this zone
  GET_PORT_VAL(ai_temp_t[l_zon_num], ai_temp_i[l_zon_num], l_io_value, l_status)
  IF (l_status = SUCCESS) THEN

    -- Check the tick value.  Less than 5 ticks means the transducer is
    -- disconnected. Don't post an error if the TCU is disabled.
    IF (l_io_value < 5) AND (tcu_enable[l_zon_num] = TRUE) THEN
      -- post "Meter Temp Transducer Disconnected" (~0 ticks = disconnected)
      IF (ep_txdcrdsco[l_zon_num] = FALSE) AND NOT (TPIN[tpi_enable]) THEN
        POST_ERR(ER_TXDCRDSCO,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)
        --POST_ERR(ER_TXDCRDSCO,'',0,ER_WARN)
        ep_txdcrdsco[l_zon_num] = TRUE
      ENDIF
      -- Don't let TCU adjust the temperature if the transducer is bad
      tcu_error[l_zon_num] = TRUE
    ENDIF

    -- Calculate degrees (Celsius) using the transducer spec. sheet
    -- There is a 200 tick 'bias', and 10 ticks per degree after that.
--    l_real = (l_io_value - 200) / 10
--    IF (use_met_temp = TRUE) THEN
--       tcu_cur_temp[l_zon_num] = l_real + bias_temp[l_zon_num]		--Celsius
--    ELSE
--       tcu_cur_temp[l_zon_num] = (l_real * 1.8) + 32 + bias_temp[l_zon_num]	-- Calculate degrees Fahrenheit. 
--    ENDIF
    IF (use_met_temp = TRUE) THEN
	  -- SMC Scaling... 4mA = 228 ticks.  20mA = 3868 ticks.  Transducer = 0 - 80 Degrees Celsius.
	  -- Scaling = .021978 degrees C per tick, .03956 degrees F per tick.
      tcu_cur_temp[l_zon_num] = ((l_io_value - t_xdcr_bias[l_zon_num]) * t_xdcr_scale[l_zon_num]) + bias_temp[l_zon_num]		--Celsius
    ELSE
      tcu_cur_temp[l_zon_num] = ((l_io_value - t_xdcr_bias[l_zon_num]) * t_xdcr_scale[l_zon_num]) + 32 + bias_temp[l_zon_num]	-- Calculate degrees Fahrenheit. 
	ENDIF
  ELSE
    tcu_cur_temp[l_zon_num] = 0 -- Make sure this gets initialized.
    IF (tcu_enable[l_zon_num] = TRUE) THEN
      -- post error "Meter Temp I/O Invalid"
      IF (ep_tcuio_inv[l_zon_num] = FALSE) AND NOT (TPIN[tpi_enable]) THEN
        POST_ERR(ER_TCUIO_INV,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)
	    --POST_ERR(ER_TCUIO_INV,'',0,ER_WARN)
        ep_tcuio_inv[l_zon_num] = TRUE
      ENDIF
      tcu_error[l_zon_num] = TRUE
    ENDIF
  ENDIF

  IF (tcu_cur_temp[l_zon_num] > (tcu_setpoint[l_zon_num] - inrange_tol[l_zon_num])) AND
     (tcu_cur_temp[l_zon_num] < (tcu_setpoint[l_zon_num] + inrange_tol[l_zon_num])) THEN
	temp_inrange[l_zon_num] = TRUE
  ELSE
    temp_inrange[l_zon_num] = FALSE
  ENDIF
  
  IF (tcu_ele_used = TRUE) THEN
    IF (di_tcurdy_i <> 0) THEN -- Do this if the PSU Ready signal is mapped.
      GET_PORT_VAL(di_tcurdy_t, di_tcurdy_i, l_io_value, l_status)
      IF (l_io_value = 0) AND (tcu_enable[l_zon_num] = TRUE) THEN
       -- Post a "TCU Command Fault" error
       IF (ep_tcunotrdy[l_zon_num] = FALSE) AND NOT(TPIN[tpi_enable]) THEN
          POST_ERR(ER_TCUNOTRDY,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)
          --POST_ERR(ER_TCUNOTRDY,'',0,ER_WARN)
          ep_tcunotrdy[l_zon_num] = TRUE
        ENDIF
        tcu_error[l_zon_num] = TRUE -- Turn off I/O if the TCU sends an error.
      ENDIF
	ENDIF
  ENDIF

  -- Do the following ONLY if we are looking at Zone #1 of the TCU.  We don't need
  -- to do these steps 10 times if there are 10 zones in the TCU.
  IF (l_zon_num = 1) THEN
    IF (tcu_wtr_used = TRUE) THEN
      GET_PORT_VAL(di_tcurdy_t, di_tcurdy_i, l_io_value, l_status)
      IF (l_io_value = 0) THEN 
        status = IOVALSET(do_pwrecho_t + IGN_OFFLN, do_pwrecho_i, TURN_ON) -- Power Disabled
 	    IF (tcu_enable[l_zon_num] = TRUE) THEN
          -- Post a "Water TCU Not Running" error
          IF (ep_wtcunorun = FALSE) AND NOT(TPIN[tpi_enable]) THEN
            POST_ERR(ER_WTCUNORUN,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)
            ep_wtcunorun = TRUE
          ENDIF
          tcu_error[l_zon_num] = TRUE -- Turn off I/O if the TCU sends an error.
        ENDIF
	  ELSE	
        status = IOVALSET(do_pwrecho_t + IGN_OFFLN, do_pwrecho_i, TURN_OFF) -- Power Enabled
	  ENDIF

      GET_PORT_VAL(di_lo_wtrf_t, di_lo_wtrf_i, l_io_value, l_status)
      IF (l_io_value = 1) AND (tcu_enable[l_zon_num] = TRUE) THEN
        -- Post a "Water TCU Low Water Fault" error
        IF (ep_wtculowtr = FALSE) AND NOT(TPIN[tpi_enable]) THEN
          POST_ERR(ER_WTCULOWTR,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)
          ep_wtculowtr = TRUE
        ENDIF
        tcu_error[l_zon_num] = TRUE -- Turn off I/O if the TCU sends an error.
      ENDIF

      GET_PORT_VAL(di_hi_tmpf_t, di_hi_tmpf_i, l_io_value, l_status) -- NOT a High Temp Fault
	  -- Stupid water TCU doesn't turn on the "Temp Okay" unless it is supposed to be on.
      GET_PORT_VAL(do_tcufan_t[l_zon_num], do_tcufan_i[l_zon_num], l_io_value2, l_status)
      IF (l_io_value = 0) AND (l_io_value2 = 1) AND (tcu_enable[l_zon_num] = TRUE) THEN
        -- Post a "Water TCU High Temp Fault" error
        IF (ep_wtcuhitmp = FALSE) AND NOT(TPIN[tpi_enable]) THEN
          POST_ERR(ER_WTCUHITMP,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)
          ep_wtcuhitmp = TRUE
        ENDIF
        tcu_error[l_zon_num] = TRUE -- Turn off I/O if the TCU sends an error.
      ENDIF
    ENDIF
  
    -- GM G4 Anti-Chip requires a stand-alone Gun Temperature sensor on the EOAT.
	-- Hijack TCU[12] variables for this transducer.  They'll never use 12 Heat/Cool zones anyway,
	-- and this allows us to use pre-existing variables.
    -- Get the temperature for this zone
    GET_PORT_VAL(ai_temp_t[12], ai_temp_i[12], l_io_value, l_status)
    IF (l_status = SUCCESS) THEN

      -- Check the tick value.  Less than 5 ticks means the transducer is
      -- disconnected. Don't post an error if the TCU is disabled.
      IF (l_io_value < 5) THEN
        -- post "Meter Temp Transducer Disconnected" (~0 ticks = disconnected)
        IF (ep_txdcrdsco[12] = FALSE) AND NOT (TPIN[tpi_enable]) THEN
          POST_ERR(ER_TXDCRDSCO,'TCU ' + int_to_strg(1)+' Zone ' + int_to_strg(12),0,ER_WARN)
          --POST_ERR(ER_TXDCRDSCO,'',0,ER_WARN)
          ep_txdcrdsco[12] = TRUE
        ENDIF
      ENDIF	

	  IF (use_met_temp = TRUE) THEN
	    -- SMC Scaling... 4mA = 228 ticks.  20mA = 3868 ticks.  Transducer = 0 - 80 Degrees Celsius.
	    -- Scaling = .021978 degrees C per tick, .03956 degrees F per tick.
        tcu_cur_temp[12] = ((l_io_value - t_xdcr_bias[12]) * t_xdcr_scale[12]) + bias_temp[12] --Celsius
      ELSE
        tcu_cur_temp[12] = ((l_io_value - t_xdcr_bias[12]) * t_xdcr_scale[12]) + 32 + bias_temp[12]-- Fahrenheit. 
	  ENDIF
	ENDIF
  ENDIF  -- Special checks for TCU Zone #1 
ENDUSING 
  
END get_cur_temp



------------------------------------------------------------------------------
ROUTINE chk_settings(l_tcu_num : INTEGER; l_zon_num : INTEGER)  -- Reads TCU-related settings & verifies
--                   -- that the data makes 'sense'.
------------------------------------------------------------------------------
VAR
  l_status     : INTEGER
  l_dummy      : INTEGER
  l_io_value   : INTEGER
  l_time       : INTEGER
  l_loop       : INTEGER
  
BEGIN

USING tcu[l_tcu_num] DO

  IF (tcu_enable[l_zon_num] = FALSE) THEN  --(TCU Enable is no longer global)
    RETURN -- Skip everything else if the TCU is disabled.
  ENDIF

  -- Adjust bias values so that they are no greater than +/-10
  IF (bias_temp[l_zon_num] > 10) OR (bias_temp[l_zon_num] < -10) THEN
    IF (bias_temp[l_zon_num] > 10) THEN
      bias_temp[l_zon_num] = 10
    ELSE
      bias_temp[l_zon_num] = -10
    ENDIF
    -- post a warning that we exceeded the bias limit
    POST_ERR(ER_TBIAS_LIM,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)  -- TCU Temp Bias Limit Imposed
  ENDIF
	
  -- No matter what, don't let anyone modify
  -- the TCU setpoint outside of the 'warning' boundary limits!  If it is
  -- outside the boundary limits, set it back to the boundary value.
  
  IF (tcu_setpoint[l_zon_num] < t_lo_temp_w[l_zon_num]) THEN
    tcu_setpoint[l_zon_num] = t_lo_temp_w[l_zon_num]
    IF (ep_setpntlim[l_zon_num] = FALSE) THEN
      POST_ERR(ER_SETPNTLIM,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)	
      --POST_ERR(ER_SETPNTLIM,'',0,ER_WARN)  -- TCU Set Point Limit Imposed
      ep_setpntlim[l_zon_num] = TRUE
    ENDIF
  ENDIF

  IF (tcu_setpoint[l_zon_num] > t_hi_temp_w[l_zon_num]) THEN
    tcu_setpoint[l_zon_num] = t_hi_temp_w[l_zon_num]
    IF (ep_setpntlim[l_zon_num] = FALSE) THEN
      POST_ERR(ER_SETPNTLIM,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)	
      --POST_ERR(ER_SETPNTLIM,'',0,ER_WARN)  -- TCU Set Point Limit Imposed
      ep_setpntlim[l_zon_num] = TRUE
    ENDIF
  ENDIF

  -- Form limits had to be expanded for Fahrenheit/Celsius.  Don't rely on form limits to
  -- limit errors in operator input.
  -- Make sure the threshold values aren't excessive.  
  IF (t_lo_temp_f[l_zon_num] < abs_min_temp) THEN
    t_lo_temp_f[l_zon_num] = abs_min_temp
  ENDIF

  IF (t_hi_temp_f[l_zon_num] > abs_max_temp) THEN
    t_hi_temp_f[l_zon_num] = abs_max_temp
  ENDIF
  
 -- Parameter checking for tcu warning and fault limits
 IF(t_lo_temp_f[l_zon_num] <= t_lo_temp_w[l_zon_num]) AND
    (t_lo_temp_w[l_zon_num] <= t_hi_temp_w[l_zon_num]) AND
    (t_hi_temp_w[l_zon_num] <= t_hi_temp_f[l_zon_num]) THEN
    IF (NOT UNINIT(tcu_cur_temp[l_zon_num])) AND (tcu_cur_temp[l_zon_num] <> 0) THEN
	  -- (tcu_cur_temp = 0 if the Analog Input is not mapped to a valid AIN)
      IF (tcu_cur_temp[l_zon_num] < t_lo_temp_f[l_zon_num]) THEN
        IF (ep_tlo_tmp_f[l_zon_num] = FALSE) AND NOT (TPIN[tpi_enable]) THEN
          POST_ERR(ER_TLO_TMP_F,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)
          ep_tlo_tmp_f[l_zon_num] = TRUE
        ENDIF
        tcu_error[l_zon_num] = TRUE
      ELSE
        IF (tcu_cur_temp[l_zon_num] < t_lo_temp_w[l_zon_num]) THEN
          IF (ep_tlo_tmp_w[l_zon_num] = FALSE) THEN
            POST_ERR(ER_TLO_TMP_W,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)		  
            --POST_ERR(ER_TLO_TMP_W,'',0,ER_WARN)
            ep_tlo_tmp_w[l_zon_num] = TRUE
          ENDIF
        ENDIF
      ENDIF

      IF (tcu_cur_temp[l_zon_num] > t_hi_temp_f[l_zon_num]) THEN 
        IF (ep_thi_tmp_f[l_zon_num] = FALSE) AND NOT (TPIN[tpi_enable]) THEN
          --POST_ERR(ER_THI_TMP_F,'',0,ER_WARN)
          POST_ERR(ER_THI_TMP_F,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)
          ep_thi_tmp_f[l_zon_num] = TRUE
        ENDIF
        tcu_error[l_zon_num] = TRUE
      ELSE
        IF (tcu_cur_temp[l_zon_num] > t_hi_temp_w[l_zon_num]) THEN
          IF (ep_thi_tmp_w[l_zon_num] = FALSE) THEN
          POST_ERR(ER_THI_TMP_W,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)
		  --POST_ERR(ER_THI_TMP_W,'',0,ER_WARN)
            ep_thi_tmp_w[l_zon_num] = TRUE
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ELSE
    -- post "Temp Threshold Invalid"  ER_TCU_T_INV
    IF (ep_tcu_t_inv[l_zon_num] = FALSE) AND NOT (TPIN[tpi_enable]) THEN
      POST_ERR(ER_TCU_T_INV,'TCU ' + int_to_strg(l_tcu_num)+' Zone ' + int_to_strg(l_zon_num),0,ER_WARN)	
      --POST_ERR(ER_TCU_T_INV,'',0,ER_WARN)
      ep_tcu_t_inv[l_zon_num] = TRUE
    ENDIF
    tcu_error[l_zon_num] = TRUE
  ENDIF
  
  --get_cur_temp  -- Read the current temperature transducer values.

ENDUSING

END chk_settings



--------------------------------------------------------------------------
BEGIN  -- temptask main code
--------------------------------------------------------------------------


--  -- Don't run this program if we're not an ISD w/TCU.  This keeps
--  -- the opener robots from posting errors...
--  IF (tcu_ele_used = FALSE) AND (tcu_wtr_used = FALSE) THEN
--    ABORT
--  ENDIF

  -- Don't let the program run if we're not using the PVC Tool.
  IF (appl_type = 2) THEN -- PVC
    tcu_wtr_used = TRUE
	tcu_ele_used = FALSE
  ELSE
    ABORT
  ENDIF	


  tcu_hfo      = FALSE

  IF UNINIT(init_var_enb) THEN -- Use Metric Settings by default
    init_var_enb = TRUE
    init_met_deg = TRUE -- Set temperature parameters for Degrees Celsius
    init_met_vol = TRUE -- Set volume parameters for LPM
    init_eng_deg = FALSE -- Set temperature parameters for Degrees Fahrenheit
    init_eng_vol = FALSE -- Set volume parameters for GPM
  ENDIF

  FOR tcu_num = 1 TO 5 DO -- Do for maximum possible number of equipments
    USING tcu[tcu_num] DO
      tcu_diag_enb = FALSE

      -- Indicate on the status screen that the program is not running (yet).
      tcu_ctl_mode = MODE_ABORT
  
      IF (init_var_enb = TRUE) THEN
		tcu_exists = TRUE -- Enable by default
        num_zones = 1
		cur_sel_zon = 1
		
        cmd_heat_adj = 1

        -- Initialize I/O to safe values
        di_tcurdy_t     = 1; di_tcurdy_i     =  0 --1

        do_tcudsbl_t = 2; do_tcudsbl_i =  0 
		do_tempsok_t = 2; do_tempsok_i =  0
		do_pwrecho_t = 2; do_pwrecho_i =  0
        di_lo_wtrf_t = 1; di_lo_wtrf_i =  0 
        di_hi_tmpf_t = 1; di_hi_tmpf_i =  0 

	    FOR zone_num = 1 TO MAX_TCU_ZONE DO
		  tcu_zon_name[zone_num] = ' '
		  tcu_enable[zone_num] = FALSE
          i_accumulatr[zone_num] = 1 
          a_p_gain[zone_num] = 50
          a_i_gain[zone_num] =  5
          bias_temp[zone_num] = 0
		  t_xdcr_bias[zone_num] = 228 -- SMC Default
          do_tcufan_t[zone_num]  = 2; do_tcufan_i[zone_num]  =  0 
          do_tcuheat_t[zone_num] = 2; do_tcuheat_i[zone_num] =  0 
          do_tcucold_t[zone_num] = 2; do_tcucold_i[zone_num] =  0 
          ai_temp_t[zone_num] = 3; ai_temp_i[zone_num] =  0 
		  tcu_cur_temp[zone_num] = 0
		  inrange_tol[zone_num] = 3
    	ENDFOR
      ENDIF

      IF (init_met_deg = TRUE) THEN -- Initialize for Degrees Celsius
        -- Default Temperature Settings
		FOR zone_num = 1 TO MAX_TCU_ZONE DO
       	  t_lo_temp_f[zone_num]  = 15; t_lo_temp_w[zone_num] = 18; t_hi_temp_w[zone_num] = 32; t_hi_temp_f[zone_num] = 35
          tcu_setpoint[zone_num] = 22; t_xdcr_scale[zone_num] = .021978 -- SMC Scaling
		ENDFOR
      ENDIF
 
      IF (init_eng_deg = TRUE) THEN -- Initialize for Degrees Fahrenheit
        -- Default Temperature Settings
		FOR zone_num = 1 TO MAX_TCU_ZONE DO
    	  t_lo_temp_f[zone_num]  = 60; t_lo_temp_w[zone_num] = 65; t_hi_temp_w[zone_num] = 90; t_hi_temp_f[zone_num] = 95
          tcu_setpoint[zone_num] = 72; t_xdcr_scale[zone_num] = .03956 -- SMC Scaling
		ENDFOR
      ENDIF

    ENDUSING
  ENDFOR	

  init_var_enb = FALSE
  
  IF (init_met_deg = TRUE) THEN -- Initialize for Degrees Celsius
	-- Absolute Maximum/Minimum temperature.  We cannot simply rely on the form to limit user input,
	-- since the shared form must accept both Metric and English limits.
	abs_max_temp = 40
	abs_min_temp = 10

	use_met_temp = TRUE
    init_met_deg = FALSE
  ENDIF	
  
  IF (init_met_vol = TRUE) THEN -- Initialize for Liters Per Minute
  	--Set strings for dictionary
	vol_units    = 'lpm' 

	use_met_vol  = TRUE
    init_met_vol = FALSE
  ENDIF	
  
  IF (init_eng_deg = TRUE) THEN -- Initialize for Degrees Fahrenheit
	-- Absolute Maximum/Minimum temperature.  We cannot simply rely on the form to limit user input,
	-- since the shared form must accept both Metric and English limits.
	abs_max_temp = 120
	abs_min_temp = 40
  
    use_met_temp = FALSE
	init_eng_deg = FALSE
  ENDIF
  
  IF (init_eng_vol = TRUE) THEN -- Initialize for Gallons Per Minute
  	--Set strings for dictionary
	vol_units    = 'gpm' 

	use_met_vol  = FALSE
    init_eng_vol = FALSE
  ENDIF	

  -- Set variables for GM Water TCU
  IF (TCU[1].AI_TEMP_I[1] = 0) THEN
    USING TCU[1] DO
      TCU_ZON_NAME[1] = 'Water TCU'
	  DO_TCUHEAT_I[1] = 1573
  	  DO_TCUCOLD_I[1] = 1572
	  DO_TCUFAN_I[1]  = 1571
	  DI_TCURDY_I = 1569
	  DI_LO_WTRF_I = 1570
	  DI_HI_TMPF_I = 1572
	  AI_TEMP_I[1] = 4
    ENDUSING
  ENDIF	  
  -- Search for the Dispense Plug-In index.
  FOR loop = 1 TO 32 DO
    IF ($AP_CUREQ[loop].$SCREEN_NAME = 'Dispense') THEN
	  disp_app_num = loop
	ENDIF
  ENDFOR	

  last_eq_num = $AP_CUREQ[disp_app_num].$CUR_EQNO
  
  -- Identify the initial number of TCU zones for each TCU
  FOR loop = 1 TO 5 DO
    tcu[loop].last_num_zon = tcu[loop].num_zones
    tcu[loop].cur_sel_zon = 1
	tcu[loop].last_sel_zon = 1
  ENDFOR
  
  CONDITION[CH_FLT_RESET]: WITH $SCAN_TIME = 256 -- Wait for reset
    WHEN ERROR[0] DO
      clr_flt_flag
  ENDCONDITION
  ENABLE CONDITION[CH_FLT_RESET]

  clr_flt_flag -- Initialize fault flags

  REPEAT -- Forever
  
    -- For All Dispense Equipments
	FOR tcu_num = 1 TO $SLEQNUM DO
      USING tcu[tcu_num] DO

        -- For ALL TCUs Within This Equipment
        FOR zone_num = 1 TO num_zones DO
          tcu_error[zone_num] = FALSE -- Start out optomistic.		
          chk_settings(tcu_num, zone_num) -- Sanity check for settings
		
          fan_error = FALSE

          -- Calculate the next Heat/Cold command using the METER temperature
          -- Get the current temperature values
          -- The TCU setpoint was already read by chk_settings...
          get_cur_temp(tcu_num, zone_num)
		
          IF (tcu_enable[zone_num]) THEN
            GET_PORT_VAL(do_tcuheat_t[zone_num],  do_tcuheat_i[zone_num], status, tcu_heat_ok[zone_num])
            GET_PORT_VAL(do_tcucold_t[zone_num],  do_tcucold_i[zone_num], status, tcu_cold_ok[zone_num])		
            GET_PORT_VAL(do_tcufan_t[zone_num],  do_tcufan_i[zone_num], status, tcu_fan_ok[zone_num])
            IF (tcu_fan_ok[zone_num] <>  SUCCESS) AND (do_tcuheat_i[zone_num] <> 0) AND (do_tcucold_i[zone_num] <> 0) THEN
             fan_error = TRUE
            ENDIF
 	      ENDIF

          IF (fan_error = TRUE) THEN
            -- Post 'TCU Fan Output Invalid' Error
--            IF (ep_tcufaninv[zone_num] = FALSE) AND NOT (TPIN[tpi_enable])  THEN
            POST_ERR(ER_TCUFANINV,'TCU ' + int_to_strg(tcu_num)+' Zone ' + int_to_strg(zone_num),0,ER_WARN)
		    --POST_ERR(ER_TCUFANINV,'',0,ER_WARN)
              ep_tcufaninv[zone_num] = TRUE
 --           ENDIF
            -- Don't let the TCU run without the cooling fan...
           TCU_HFO = TRUE
          ENDIF
		
          IF (tcu_enable[zone_num] = TRUE) AND (tcu_error[zone_num] = FALSE) THEN
            status = IOVALSET(do_tcufan_t[zone_num] + IGN_OFFLN, do_tcufan_i[zone_num], TURN_ON)
            -- 1. The proportional gain is calculated by multiplying the P-Gain
            --    times the difference between the setpoint and actual temperature.
            -- 2. The integral gain is calculated by multiplying the I-Gain times
            --    the accumulated difference in temperatures, times a small number.
            -- 3. The temperature command is calculated by subtracting the I-Gain
            --    calculation from the P-Gain calculation.
            -- 4. A positive result will be 'Heat', and a negative one will be 'cold'.
            --
            -- Assuming no 'I' component, the 'P' component of 10 will provide 100%
            -- conditioning if there is a temperature difference of 10 degrees.
            --
            -- a_p_gain is typically between 
            --
            prop_calc[zone_num]  = a_p_gain[zone_num] * (tcu_setpoint[zone_num] - tcu_cur_temp[zone_num]) 
            integ_calc[zone_num] = a_i_gain[zone_num] * (.1 * (i_accumulatr[zone_num]/UPDATE_TIME))
	  
            tcu_cmd_calc[zone_num] = TRUNC(prop_calc[zone_num] + integ_calc[zone_num])
            IF (tcu_cmd_calc[zone_num] > 1) THEN
              -- Heating and cooling may occur at different rates, particularly with a  
		      -- water TCU.  Use a scaling factor to adjust the amount of heating so 
		      -- that this evens out.
  		      tcu_cmd_calc[zone_num] = TRUNC(tcu_cmd_calc[zone_num] * cmd_heat_adj)
		    ENDIF
            IF (tcu_cmd_calc[zone_num] > 100) THEN
	  	      tcu_cmd_calc[zone_num] = 100
            ELSE
              IF (tcu_cmd_calc[zone_num] < -100) THEN
                tcu_cmd_calc[zone_num] = -100
              ENDIF
            ENDIF
      
            IF (tcu_diag_enb = TRUE) THEN
              write(cr,cr,'TCU Num = ',tcu_num,'  Zone Num = ',zone_num)		  
              write(cr, 'TCU ',tcu_cur_temp[zone_num],' Data')
              CNV_REAL_STR((tcu_setpoint[zone_num] - tcu_cur_temp[zone_num]),6,2,t_dbg_str)
              CNV_REAL_STR(prop_calc[zone_num],6,2,p_dbg_str)
              CNV_REAL_STR(integ_calc[zone_num],6,2,i_dbg_str)
              write(cr,'Temp Difference = ',t_dbg_str, ' Degrees')
              write(cr,'Prop Percentage = ',p_dbg_str)
              write(cr,'Int  Percentage = ',i_dbg_str)
            ENDIF
		
            IF (tcu_cmd_calc[zone_num] > 0) THEN
              -- Make sure the cold is off before we turn on the heat.
              GET_PORT_VAL(do_tcucold_t[zone_num],  do_tcucold_i[zone_num], prev_io_stat, status)
              status = IOVALSET(do_tcucold_t[zone_num] + IGN_OFFLN, do_tcucold_i[zone_num], TURN_OFF)

              -- If the Chill signal was previously ON, it was chilling at 100%.
              -- Don't do anything this scan.  This prevents a possible timing
              -- conflict between the Heat and Chill signals.
              IF (prev_io_stat = 0) THEN
                IF (tcu_heat_ok[zone_num] = 0) THEN
    	  	      IF (tcu_cur_temp[zone_num] < t_hi_temp_w[zone_num]) THEN
  
                    IF (tcu_diag_enb = TRUE) THEN
                     write(cr,'Heating         = ', tcu_cmd_calc[zone_num], '%')
                    ENDIF

                    IF (tcu_cmd_calc[zone_num] > 100) THEN
		  		      tcu_cmd_calc[zone_num] = 100
				    ENDIF	
 	 			    -- Always pulse the output, so it will automatically turn itself
				    -- off if TCU_TASK crashes for some reason. This protects the hardware.
                    PULSE DOUT[do_tcuheat_i[zone_num]] FOR (tcu_cmd_calc[zone_num] * 100) NOWAIT
                    tcu_cmd_typ[zone_num] = CMD_HEAT
 				    tcu_mode_str[zone_num] = 'Heating'
                    tcu_cmd_pct[zone_num] = tcu_cmd_calc[zone_num]

                  ELSE -- Don't heat - meter temperature too high
                    tcu_cmd_typ[zone_num] = CMD_ERROR
				    tcu_mode_str[zone_num] = 'Error'
                    tcu_cmd_pct[zone_num] = 0
                    DOUT[do_tcuheat_i[zone_num]] = OFF -- Force OFF
                  ENDIF
                ELSE -- Heat isn't mapped
                  tcu_cmd_typ[zone_num] = CMD_IDLE
			      tcu_mode_str[zone_num] = 'Idle'
                  tcu_cmd_pct[zone_num] = 0
			    ENDIF  
	          ENDIF
            ELSE
              -- Make sure the heat is off before we turn on the cold.
              GET_PORT_VAL(do_tcuheat_t[zone_num],  do_tcuheat_i[zone_num], prev_io_stat, status)
              status = IOVALSET(do_tcuheat_t[zone_num] + IGN_OFFLN, do_tcuheat_i[zone_num], TURN_OFF)
       
              IF (prev_io_stat = 0) THEN
		        IF (tcu_cold_ok[zone_num] = 0) THEN
                  IF (tcu_cur_temp[zone_num] > t_lo_temp_w[zone_num]) THEN
                    IF (tcu_diag_enb = TRUE) THEN
                      write(cr,'Cooling         = ',ABS(tcu_cmd_calc[zone_num]), '%')
                    ENDIF
                    IF (ABS(tcu_cmd_calc[zone_num]) > 100) THEN
				      tcu_cmd_calc[zone_num] = 100
   				    ENDIF	
 				    -- Always pulse the output, so it will automatically turn itself
				    -- off if TCU_TASK crashes for some reason. This protects the hardware.
                    PULSE DOUT[do_tcucold_i[zone_num]] FOR (ABS(tcu_cmd_calc[zone_num]) * 100) NOWAIT
				    tcu_cmd_typ[zone_num] = CMD_CHILL
				    tcu_mode_str[zone_num] = 'Cooling'
                    tcu_cmd_pct[zone_num] = ABS(tcu_cmd_calc[zone_num])
                  ELSE -- Don't Cool - meter temperature too low
                    tcu_cmd_typ[zone_num] = CMD_ERROR
				    tcu_mode_str[zone_num] = 'Error'
                    tcu_cmd_pct[zone_num] = 0
                   DOUT[do_tcucold_i[zone_num]] = OFF -- Force OFF
                  ENDIF
                ELSE
                  tcu_cmd_typ[zone_num] = CMD_IDLE
				  tcu_mode_str[zone_num] = 'Idle'
                  tcu_cmd_pct[zone_num] = 0
			    ENDIF
		      ENDIF
            ENDIF
 		  ELSE  -- TCU is Disabled
            -- We are not heating or cooling
            IF (tcu_enable[zone_num] = FALSE) THEN
              tcu_cmd_typ[zone_num] = CMD_DISABLED
			  tcu_mode_str[zone_num] = 'Disabled'
			  status = IOVALSET(do_tcufan_t[zone_num] + IGN_OFFLN, do_tcufan_i[zone_num], TURN_OFF)
            ELSE
              tcu_cmd_typ[zone_num] = CMD_ERROR
			  tcu_mode_str[zone_num] = 'Error'
            ENDIF

            tcu_cmd_pct[zone_num] = 0

            -- Make sure to turn these off, so we don't blow anything up.
--			status = IOVALSET(do_tcufan_t[zone_num] + IGN_OFFLN, do_tcufan_i[zone_num], TURN_OFF)
            status = IOVALSET(do_tcuheat_t[zone_num] + IGN_OFFLN, do_tcuheat_i[zone_num], TURN_OFF)
            status = IOVALSET(do_tcucold_t[zone_num] + IGN_OFFLN, do_tcucold_i[zone_num], TURN_OFF)
		  
		  ENDIF -- If this TCU is Enabled  
		
          -- Update variable for Status page
          IF (tcu_enable[zone_num] = TRUE) THEN
            tcu_ctl_mode = MODE_SETPNT
          ELSE
            tcu_ctl_mode = MODE_DSBL
          ENDIF
          i_accumulatr[zone_num] = 0  -- Start accumulating the integral error again.		
        ENDFOR  -- For All TCUs in this Equipment
        any_zone_dsb = FALSE
		all_temps_ok = TRUE
		FOR zone_num = 1 TO num_zones DO
		  IF (tcu_enable[zone_num] = FALSE) THEN
		    any_zone_dsb = TRUE
          ELSE -- Check to see if the temperature is okay.
		    IF (temp_inrange[zone_num] = FALSE) THEN
			  all_temps_ok = FALSE
			ENDIF  
		  ENDIF
  	    ENDFOR
        IF (any_zone_dsb = TRUE) THEN
    	  status = IOVALSET(do_tcudsbl_t + IGN_OFFLN, do_tcudsbl_i, TURN_ON) -- To PLC		
		ELSE
    	  status = IOVALSET(do_tcudsbl_t + IGN_OFFLN, do_tcudsbl_i, TURN_OFF) -- To PLC		
        ENDIF		  
        IF (all_temps_ok = TRUE) THEN
    	  status = IOVALSET(do_tempsok_t + IGN_OFFLN, do_tempsok_i, TURN_ON) -- To PLC		
		ELSE
    	  status = IOVALSET(do_tempsok_t + IGN_OFFLN, do_tempsok_i, TURN_OFF) -- To PLC		
        ENDIF		  
  	  ENDUSING  --
    ENDFOR	  -- For All Dispense Equipments
  
    DELAY 1000 

  
    -- The Heat/Chill commands have been set.  Now wait for 10 seconds while checking the
    -- I-Gain every second  
	  
    tcu_loop_num = 0  -- Reset loop counter
    REPEAT
      FOR tcu_num = 1 TO $SLEQNUM DO
        USING tcu[tcu_num] DO
        -- For ALL TCUs Within This Equipment
          FOR zone_num = 1 TO num_zones DO	
            -- Read & display the current temperature values
            get_cur_temp(tcu_num,zone_num)

            -- To calculate the 'I' portion of a P-I control, we must integrate
            -- the variance between the actual temperature and the setpoint over
            -- time.  
            i_accumulatr[zone_num] = i_accumulatr[zone_num] + (tcu_setpoint[zone_num] - tcu_cur_temp[zone_num])
          ENDFOR
	    ENDUSING
      ENDFOR	  

      -- Monitor the current equipment and the number of TCU zones so that we can
      -- trigger a screen update of the Sealer conditioning forms.

      force_update = FALSE   

      IF ($AP_CUREQ[disp_app_num].$CUR_EQNO <> last_eq_num) THEN
        force_update = TRUE
      ENDIF
      last_eq_num = $AP_CUREQ[disp_app_num].$CUR_EQNO

	  -- Identify the initial number of TCU zones for each TCU
  	  FOR loop = 1 TO 5 DO
	    IF (tcu[loop].last_num_zon <> tcu[loop].num_zones) THEN
		  force_update = TRUE
  	  ENDIF 

	    -- Don't set an invalid zone.
	    IF (tcu[loop].cur_sel_zon < 1) THEN 
		  tcu[loop].cur_sel_zon = 1
 	    ELSE
		  IF (tcu[loop].cur_sel_zon > tcu[loop].num_zones) THEN
		    tcu[loop].cur_sel_zon = tcu[loop].num_zones
		  ENDIF
	    ENDIF
	  
	    IF (tcu[loop].last_sel_zon <> tcu[loop].cur_sel_zon) THEN
		  force_update = TRUE
	    ENDIF
	  
	    tcu[loop].last_num_zon = tcu[loop].num_zones
	    tcu[loop].last_sel_zon = tcu[loop].cur_sel_zon
	  ENDFOR

	  IF (force_update = TRUE) THEN
	    SET_VAR(dummy_int,'SCNDIOIF','update_reqst',1,status) 
	    SET_VAR(dummy_int,'SCNDSTAT','update_reqst',1,status)
	    SET_VAR(dummy_int,'SCNDSTUP','update_reqst',1,status)
	  ENDIF

      DELAY 1050
      tcu_loop_num = tcu_loop_num + 1
    UNTIL(tcu_loop_num >= UPDATE_TIME)

  UNTIL (tcu_hfo = TRUE)
  
  FOR tcu_num = 1 TO $SLEQNUM DO
    USING tcu[tcu_num] DO
    -- For ALL TCUs Within This Equipment
      FOR zone_num = 1 TO num_zones DO		  
        -- Make sure to turn these off, so we don't blow anything up.
        status = IOVALSET(do_tcuheat_t[zone_num] + IGN_OFFLN, do_tcuheat_i[zone_num], TURN_OFF)
        status = IOVALSET(do_tcucold_t[zone_num] + IGN_OFFLN, do_tcucold_i[zone_num], TURN_OFF)
        status = IOVALSET(do_tcufan_t[zone_num] + IGN_OFFLN, do_tcufan_i[zone_num], TURN_OFF)
		tcu_mode_str[zone_num] = 'Aborted'
		tcu_ctl_mode = MODE_ABORT
		status = IOVALSET(do_tcudsbl_t + IGN_OFFLN, do_tcudsbl_i, TURN_ON)
      ENDFOR
    ENDUSING
  ENDFOR 
   	
END tcu_task
