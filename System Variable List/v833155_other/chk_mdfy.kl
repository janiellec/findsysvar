-- -----------------------------------------------------------------------
--
--   MODULE:         CHK_MDFY.KL
--   TITLE:          Check Modified date PROGRAM
--
--
--   WRITTEN BY:     RANDY KOSASKI
--   REVISION DATE:  4/01/00
--
--   LANGUAGE:       KAREL
--   CONTROL GROUP:  None
--   STATUS:
--
--
--   ORDER NUMBER:   000000
--   PROJECT NAME:   GOOD CUSTOMER
--
--
--         FANUC Robotics retains rights in any and all Software
--         contained in the material attached hereto and said
--         Software may not be copied or reproduced without the
--         written permission of FANUC Robotics.
--
--         All Software, (C) Copyright FANUC Robotics Corporation, 2000
--         DESCRIPTION: ROBOT MAIN PROGRAM
--
--         HISTORY OF CHANGES:
--
--         REVISION   DATE       BY               COMMENTS
--         --------   ---------  ---------------  --------------------
--
--
--
--
--------------------------------------------------------------------------
PROGRAM CHK_MDFY

%COMMENT = 'Chk Prgs Modify'
%NOABORT = ERROR + COMMAND-- *** REMOVE COMMENT FOR PRODUCTION NEED TO IGNORE ABORT
                --*****************************************************************
%NOPAUSE = ERROR + COMMAND + TPENABLE
%NOBUSYLAMP
%NOLOCKGROUP
%INCLUDE KLEVCCDF

-- Save time and date changed, save when it was caught, save original date
-- save the user tools and user frames at the time also
-- need to save the time the mastering was completed
-- need to have proirity of how servear a change is Frame changed you may not
-- want to run at all where the program change could run
-- Do they want to be able to Write the NEW mastered date to the orignal program

TYPE

   history_data FROM MDFYSTUP = STRUCTURE
     history_name: STRING[28] -- the name of the program matches dictionary size
     Masteredint : INTEGER -- the master data history
     Modifiedint : INTEGER -- the Modified history
     Masteredstr : STRING[16] -- the Modified history
     Modifiedstr : STRING[16] -- the Mastered history
   ENDSTRUCTURE

   prog_data  FROM  MDFYSTUP = STRUCTURE
     program_name : STRING[28] -- the name of the program
     program_cmnt : STRING[16] -- the comment from the program
     MasteredTime : INTEGER    -- the timestamp when the modified program found
     ModFndTime   : INTEGER    -- the timestamp when the modified program found
     LstmastrInt  : INTEGER    -- the last mastered integer from the read of builtin
     CurmodInt    : INTEGER    -- the last read integer from the read of builtin
     LastMastered : STRING[16] -- the last time mastered (when told to master)
     LastModified : STRING[16] -- Current modified date
     MasterTimStr : STRING[20] -- time and date when mastered date
     Modified_do  : INTEGER    -- THis is the output to turn ON if program has been modified
     historicdata : ARRAY[10] OF history_data -- track the historical data
     mod_found    : BOOLEAN -- this used for finding the modification was caught
     enable_montr : BOOLEAN
   ENDSTRUCTURE

VAR

MasterProgs IN CMOS FROM MDFYSTUP :ARRAY[32] OF prog_data

-- Below used for the mastering procedure of the schedule driven by teh PLC in CHK_MDFY
MasterFltRst,                  -- Used for DIN to Indicate the PLC has acknowledged the Master Fault and reset the outputs
MasterReqFlt,                  -- Used for DOUT to indicate Mastering FAULT occured and could not be completed
Master_Cmplt,                  -- Used for DOUT to indicate the Mastering was completed succesfully
InitMaster,                    -- Used for DIN number to initiate a master of the current schedule# Master_Req
MastrFltCode,                  -- Used for the GOUT to PLC indicating a code to PLC WHY could not master
Master_Cnfrm,                  -- Used for the GOUT to PLC confirming the GIN sent on Master_Req
Master_Req   IN CMOS FROM MDFYSTUP: INTEGER -- Used for GIN the PLC will send for requesting Mastering of Schedule#
CommentNum   IN CMOS FROM MDFYSTUP: ARRAY[7] OF STRING[26] -- used for the comment of the above DI/DO

MastrConFigd IN CMOS FROM MDFYSTUP : BOOLEAN -- Used for indicating the mastering data is configured

master_done :BOOLEAN -- set the master incomplete for return

LockMstrProg,
end_mod_chk,
initialized,
real_flag,
loaded  : BOOLEAN -- Used for return value for Loaded status builtin
task_Name IN CMOS : STRING[12] -- Used for the Get_var for what program to get var
string_value : STRING[128]

Prg_Comment,
DO_Comment FROM MDFYSTUP: STRING[26]


TimeModified : STRING[16] -- the time modified for the post error message
NumPrgsChkd, -- total number of program checked out of the array.
NumPrgsModfd, -- used for counting how many programs were modified
MstrCausCode, -- used to send fault cause for NOT being able to master to PLC
i,
f_index   : INTEGER -- Used for

ReqMastrSchl :INTEGER
entry,
status :INTEGER -- Status of built-in procedure call
ROUTINE save_history(Schdl_num:INTEGER) FROM MDFYSTUP
------------------------------------------------------------------------------
-- ROUTINE Trim
-- Remove leading and trailing spaces
-------------------------------------------------------------------------------
ROUTINE Trim (strText : STRING) : STRING

VAR
  strChar      : STRING[1]
  strTemp      : STRING[128]
  intFront     : INTEGER
  intBack      : INTEGER
  intIndex     : INTEGER
  intLength    : INTEGER

BEGIN

  strChar = ''
  strTemp = ''

IF UNINIT(strText) THEN
  strText = 'UNINT'
  POST_ERR(38000, 'String Not Initialized??', 0, 0) --
ENDIF


  intLength = STR_LEN(strText)

  IF intLength = 0 THEN RETURN(strText) ; ENDIF

  intIndex = 1
  intFront = intIndex

  --find the front of the string
  strChar = SUB_STR(strText, intIndex, 1)
  WHILE strChar = ' ' DO
    intIndex = IntIndex + 1
    IF intIndex <= intLength THEN
      strChar = SUB_STR(strText, intIndex, 1)
      intFront = intIndex
    ELSE
      strChar = ''
    ENDIF

  ENDWHILE

  intIndex = STR_LEN(strText)
  intBack = intIndex

  --find the back of the string
  strChar = SUB_STR(strText, intIndex, 1)
  WHILE strChar = ' ' DO
    intIndex = IntIndex - 1
    IF intIndex >= 1 THEN
      strChar = SUB_STR(strText, intIndex, 1)
      intBack = intIndex
    ELSE
      strChar = ''
    ENDIF
  ENDWHILE

  -- using SUB_STR to extract the string between front and back doesn't work - so we do it the hard way
  FOR intIndex=intFront TO intBack DO
    strChar = SUB_STR(strText, intIndex, 1)
    strTemp = strTemp + strChar
  ENDFOR

  RETURN(strTemp)

END Trim
-------------------------------------------------------------------------------
-- ROUTINE Int2Str
-- Converts integer number to string.
-------------------------------------------------------------------------------
ROUTINE Int2Str (intVal : INTEGER) : STRING

VAR
  strOut : STRING[15]

BEGIN

  CNV_INT_STR(intVal, 15, 0, strOut)
  strOut = Trim(strOut)

  RETURN (strOut)

END Int2Str
-----------------------------------------------------------------------------
ROUTINE masterprog :BOOLEAN
-- PURPOSE: master the date for the current program
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------

BEGIN
IF UNINIT(LockMstrProg) THEN
  LockMstrProg = TRUE
ENDIF

master_done = FALSE -- set the master incomplete for return
MstrCausCode = 0  -- Set the master cause code to zero

   -- need to check if initialized
 IF UNINIT(MasterProgs[ReqMastrSchl].program_name) THEN
   POST_ERR(38000, 'Program Modify '+int2str(ReqMastrSchl)+' name not setup', 0, 0) --
   MstrCausCode = 1
   RETURN(master_done)
 ELSE    -- check is loaded
   LOAD_STATUS(MasterProgs[ReqMastrSchl].program_name,loaded, initialized)
    IF NOT loaded THEN -- its loaded, get the modified attribute
      POST_ERR(38000,MasterProgs[ReqMastrSchl].program_name + ' is not loaded on Robot', 0, 0) --
      MstrCausCode = 2
      MasterProgs[ReqMastrSchl].enable_montr = FALSE
      MasterProgs[ReqMastrSchl].program_cmnt = 'File NOT Found'
      RETURN(master_done)
    ENDIF

    -- check if program output is NOT setup but enabling is TRUE fault and set to FALSE
    IF UNINIT(MasterProgs[ReqMastrSchl].Modified_do) THEN
      POST_ERR(38000,MasterProgs[ReqMastrSchl].program_name + ' Fault Output NOT setup', 0, 0) --
      MstrCausCode = 5
      MasterProgs[ReqMastrSchl].enable_montr = FALSE
      RETURN(master_done)
    ENDIF

     IF (MasterProgs[ReqMastrSchl].Modified_do =0) THEN
       POST_ERR(38000,MasterProgs[ReqMastrSchl].program_name + ' Fault Output NOT setup', 0, 0) --
       MstrCausCode = 5
       MasterProgs[ReqMastrSchl].enable_montr = FALSE
       RETURN(master_done)
     ENDIF
-- Need to check it is required
    IF UNINIT(MasterProgs[ReqMastrSchl].CurmodInt) THEN -- needed if program CHK_MDFY program not running to update
     -- get the attribute and save as the last mastered so will be good on compare
      GET_ATTR_PRG(MasterProgs[ReqMastrSchl].program_name, AT_MDFY_TIME, MasterProgs[ReqMastrSchl].CurmodInt, string_value, status)
      IF status<> 0 THEN
        POST_ERR(38000, 'Failed to get '+ MasterProgs[ReqMastrSchl].program_name +' Modified Time', status, 0) --
        Prg_Comment = ''
        MstrCausCode = 3
        RETURN(master_done)
      ELSE -- set the modified date
        CNV_TIME_STR(MasterProgs[ReqMastrSchl].CurmodInt,MasterProgs[ReqMastrSchl].LastModified)
      ENDIF
    ENDIF

-- check if ever mastered
    IF NOT UNINIT(MasterProgs[ReqMastrSchl].LstmastrInt) THEN
      IF (MasterProgs[ReqMastrSchl].CurmodInt = MasterProgs[ReqMastrSchl].LstmastrInt) THEN -- if last mod is <> Last Mastered
        WRITE TPERROR(CHR(cc_clear_win),MasterProgs[ReqMastrSchl].program_name,' Mastering not required')
        MstrCausCode = 4
        RETURN(master_done)
      ENDIF
    ELSE -- set it equal to original modifed date because it is 1st time mastered
      MasterProgs[ReqMastrSchl].LstmastrInt = MasterProgs[ReqMastrSchl].CurmodInt
    ENDIF

   -- save the Current Date for the history
   save_history(ReqMastrSchl)

   MasterProgs[ReqMastrSchl].historicdata[1].history_name = MasterProgs[ReqMastrSchl].program_name
   -- Convert to date
   IF NOT UNINIT(MasterProgs[ReqMastrSchl].LstmastrInt) THEN
     IF (MasterProgs[ReqMastrSchl].LstmastrInt>0) THEN -- zero,faults INTP-103 Program error,ROUT-035 Value out range
       CNV_TIME_STR(MasterProgs[ReqMastrSchl].LstmastrInt,MasterProgs[ReqMastrSchl].historicdata[1].Masteredstr)
     ENDIF
     MasterProgs[ReqMastrSchl].historicdata[1].Masteredint = MasterProgs[ReqMastrSchl].LstmastrInt
   ENDIF

   IF NOT UNINIT(MasterProgs[ReqMastrSchl].CurmodInt) THEN
     IF (MasterProgs[ReqMastrSchl].CurmodInt >0) THEN -- zero,faults INTP-103 Program error,ROUT-035 Value out range
       CNV_TIME_STR(MasterProgs[ReqMastrSchl].CurmodInt,MasterProgs[ReqMastrSchl].historicdata[1].Modifiedstr)
     ENDIF
     MasterProgs[ReqMastrSchl].historicdata[1].Modifiedint = MasterProgs[ReqMastrSchl].CurmodInt
   ENDIF

       -- get the attribute and save as the last mastered so will be good on compare
   GET_ATTR_PRG(MasterProgs[ReqMastrSchl].program_name, AT_MDFY_TIME, MasterProgs[ReqMastrSchl].LstmastrInt, string_value, status)
   IF status<> 0 THEN
     POST_ERR(38000, 'Failed to get '+ MasterProgs[ReqMastrSchl].program_name +' Modified Time', status, 0) --
     Prg_Comment = ''
     MstrCausCode = 3
     RETURN(master_done)
   ELSE -- set the modified date
   --  DOUT[MasterProgs[ReqMastrSchl].Modified_do] = ON -- + OFFLINE
     CNV_TIME_STR(MasterProgs[ReqMastrSchl].LstmastrInt,MasterProgs[ReqMastrSchl].LastMastered)
   ENDIF

   MasterProgs[ReqMastrSchl].mod_found = FALSE -- reset the found variable
   -- save the mastered time stamp
   GET_TIME(MasterProgs[ReqMastrSchl].MasteredTime)
   CNV_TIME_STR(MasterProgs[ReqMastrSchl].MasteredTime,MasterProgs[ReqMastrSchl].MasterTimStr)
   POST_ERR(38000,MasterProgs[ReqMastrSchl].program_name+ ' Modified Mastering Reset', 0, 0) --

   IF LockMstrProg THEN -- set the write protect so program cannot be modified unless someone unprotects
    SET_ATTR_PRG(MasterProgs[ReqMastrSchl].program_name, AT_PROTECT, 2, string_value, status)
      IF (status<>0) THEN
        POST_ERR(38000, MasterProgs[ReqMastrSchl].program_name+' Set Write Protect ON failed', status, 0) --
      ENDIF
   ENDIF
   master_done = TRUE
 ENDIF

 RETURN(master_done)

END masterprog
-----------------------------------------------------------------------------
ROUTINE Master_Sched
-- PURPOSE: to reset the time and date
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------

BEGIN

IF MastrConfigd THEN -- check mastering data GI/GO &DI/DO is configured properly

  IF GIN[Master_Req] >0 THEN
    ReqMastrSchl = GIN[Master_Req] -- save the number
    IF (GIN[Master_Req] > ARRAY_LEN(MasterProgs)) THEN
      -- this should not ever occur because the calling routine should not call it
      POST_ERR(38000, 'Master ' + Int2Str(ReqMastrSchl)+' is not VALID', 0, 0) --
    ELSE -- is valid range
      GOUT[Master_Cnfrm] = ReqMastrSchl -- echo the schedule number back to
      IF DIN[InitMaster] THEN
        MasterProgs[ReqMastrSchl].enable_montr = TRUE -- enable the monitor when mastering
        IF masterProg THEN -- call routine to master
          DOUT[Master_Cmplt] = ON
          -- Need to turn ON output until routine ends Output will be OFF
          DOUT[MasterProgs[ReqMastrSchl].Modified_do]=ON
        ELSE -- Fault occured
          DOUT[MasterReqFlt] = ON
        ENDIF
        GOUT[MastrFltCode] = MstrCausCode -- set in masterProg routine
      ENDIF
    ENDIF
  ENDIF

ELSE
  POST_ERR(38000, 'GI/GO Not Configured ', 0, 0) --
  GOUT[MastrFltCode] = 7 -- set in masterProg routine
  DOUT[MasterReqFlt] = ON
ENDIF

  WAIT FOR (GIN[Master_Req]<>ReqMastrSchl) OR (DIN[InitMaster]=OFF) OR (DIN[MasterFltRst]) --

-- Reset all outputs                            --
  GOUT[Master_Cnfrm] = 0
  GOUT[MastrFltCode] = 0
  DOUT[MasterReqFlt] = OFF
  DOUT[Master_Cmplt] = OFF

END Master_Sched
-----------------------------------------------------------------------------
ROUTINE Turn_it_off
-- PURPOSE:
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(MasterProgs[i].Modified_do) THEN

ELSE -- is setup need to turn OFF
  DOUT[MasterProgs[i].Modified_do] = OFF -- + OFFLINE
ENDIF

END Turn_it_off
-----------------------------------------------------------------------------
ROUTINE all_setup:BOOLEAN
-- PURPOSE: to check all parameters are set to validate if program is changed
--
--
-- INPUT:
--            -
-- OUTPUT:    return a boolean if the program can be checked
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
BEGIN
-- check program name is setup through the MDFY MENU
 IF UNINIT(MasterProgs[i].program_name) THEN -- if uninitialized can't check it.
   IF (MasterProgs[i].enable_montr) THEN
     POST_ERR(38000,'Program ' +int2str(i)+' Not setup for Monitoring', 0, 0) --
     MasterProgs[i].enable_montr = FALSE
   ENDIF
   RETURN(FALSE)
 ENDIF
-- check if the last master integer has been set
 IF UNINIT(MasterProgs[i].LstmastrInt) THEN -- never mastered
   IF (MasterProgs[i].enable_montr) THEN
     POST_ERR(38000,MasterProgs[i].program_name + ' NOT Mastered', 0, 0) --
     MasterProgs[i].enable_montr = FALSE
   ENDIF
   RETURN(FALSE)
 ENDIF
-- check if program output is NOT setup but enabling is TRUE fault and set to FALSE
 IF UNINIT(MasterProgs[i].Modified_do) THEN
   IF (MasterProgs[i].enable_montr) THEN
     POST_ERR(38000,MasterProgs[i].program_name + ' Fault Output NOT setup', 0, 0) --
     MasterProgs[i].enable_montr = FALSE
   ENDIF
   RETURN(FALSE)
 ENDIF

 IF (MasterProgs[i].Modified_do<9) OR (MasterProgs[i].Modified_do>$MAX_DIG_PRT) THEN
   RETURN(FALSE)
 ENDIF
-- check if it is enabled
 IF (MasterProgs[i].enable_montr = FALSE) THEN -- Only need to check when enabled
   -- should not be here it DO not configured so turn off if ON
   IF (DOUT[MasterProgs[i].Modified_do]) THEN
     POST_ERR(38000, 'DO ' + int2str(MasterProgs[i].Modified_do) + ' turned OFF by CHK_MDFY', 0, 0) --
     DOUT[MasterProgs[i].Modified_do] = OFF
   ENDIF
   RETURN(FALSE)
 ENDIF
 -- Load status needs to be checked
 LOAD_STATUS(MasterProgs[i].program_name,loaded, initialized)
   IF NOT loaded THEN -- its loaded, get the modified attribute
    IF (MasterProgs[i].enable_montr) THEN
      POST_ERR(38000,MasterProgs[i].program_name + ' File NOT Loaded on Robot', 0, 0) --
      MasterProgs[i].program_cmnt = 'File NOT Found'
      MasterProgs[i].enable_montr = FALSE
    ENDIF
     RETURN(FALSE)
   ENDIF

  RETURN(TRUE)

END all_setup
--************************************************************************
--                 Main Body of Program
--************************************************************************

BEGIN

IF UNINIT(end_mod_chk) THEN
  end_mod_chk = FALSE
ENDIF

FOR i = 1 TO ARRAY_LEN(MasterProgs) DO
  IF UNINIT(MasterProgs[i].enable_montr) THEN
    MasterProgs[i].enable_montr = FALSE
  ENDIF
  IF UNINIT(MasterProgs[i].mod_found) THEN
    MasterProgs[i].mod_found = FALSE
  ENDIF
ENDFOR --

IF UNINIT(MastrConfigd) THEN
  MastrConfigd = FALSE
ENDIF

REPEAT --

 NumPrgsModfd = 0
 NumPrgsChkd = 0
FOR i = 1 TO ARRAY_LEN(MasterProgs) DO -- for the array lenght of the number of files
   -- check if all settings are set and can be checked

  IF MastrConfigd THEN -- if false then cant check I/O yet menu not set
    IF GIN[Master_Req] = i THEN
      Master_Sched
    ENDIF
  ELSE
    WRITE TPERROR(CHR(cc_clear_win),'MASTRCONFIGD is FALSE,complete SETUP')
  ENDIF

  IF all_setup THEN
    GET_ATTR_PRG(MasterProgs[i].program_name, AT_MDFY_TIME, MasterProgs[i].CurmodInt, string_value, status)
      IF status<> 0 THEN
        POST_ERR(38000, 'Failed to get '+ MasterProgs[i].program_name +' Modified Time', status, 0) --
      ELSE -- convert the last modified interger into a string for viewing
        CNV_TIME_STR(MasterProgs[i].CurmodInt,MasterProgs[i].LastModified)
      ENDIF
    NumPrgsChkd = NumPrgsChkd +1

    -- Compare program current modified integer to the Last time it was mastered
    IF MasterProgs[i].CurmodInt <> MasterProgs[i].LstmastrInt THEN -- if last mod is <> Last Mastered
      IF MasterProgs[i].mod_found = FALSE THEN
        -- get the time this change was caught
        GET_TIME(MasterProgs[i].ModFndTime)
      ENDIF
      MasterProgs[i].mod_found = TRUE
      NumPrgsModfd = NumPrgsModfd + 1 -- Add one to how many programs have been modified
      IF DOUT[MasterProgs[i].Modified_do] = ON THEN -- if not OFF then need to Post Errror 1 time
        CNV_TIME_STR(MasterProgs[i].CurmodInt,TimeModified)
        POST_ERR(38000,MasterProgs[i].program_name + ' MODIFIED on '+TimeModified, 0, 0) --
        DELAY 1000 -- Need delay so Write TPError works correctly
      ENDIF
      WRITE TPERROR(CHR(cc_clear_win),MasterProgs[i].program_name ,' Program Modified')
      DOUT[MasterProgs[i].Modified_do] = OFF -- + OFFLINE
      DELAY 2000
    ELSE -- has not been modified so need to turn it ON
      IF DOUT[MasterProgs[i].Modified_do] = OFF THEN
        POST_ERR(38000, 'DO ' + int2str(MasterProgs[i].Modified_do) + ' turned ON by CHK_MDFY', 0, 0) --
      ENDIF
      DOUT[MasterProgs[i].Modified_do] = ON -- + OFFLINE
    ENDIF
  ENDIF
  DELAY 100
ENDFOR --

 IF (NumPrgsModfd >0) THEN
   IF (NumPrgsModfd = 1) THEN
     --WRITE TPERROR(CHR(cc_clear_win),NumPrgsModfd ,' Modified Program Found')
   ELSE
     WRITE TPERROR(CHR(cc_clear_win),NumPrgsModfd ,' Modified Program(s) Found')
   ENDIF
 ENDIF
 DELAY 500 -- need delay to allow system time to operate
UNTIL (end_mod_chk) --

END CHK_MDFY
