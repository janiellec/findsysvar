--    This material is the property of Fanuc Robotics America  
--    and must be  eturned to Fanuc Robotics America  
--    immediately upon request.  This  material
--    and the information illustrated or contained herein may not be
--    reproduced, copied, used, or transmitted in whole or in part in any way
--    without the prior written consent of Fanuc Robotics America  
--    
--             All Rights Reserved
--             Copyright (C)   1999, 2000
--             Fanuc Robotics America  
--    
--             Karel is a registered trademark of
--             Fanuc Robotics America  
--    +
--    Program:  
--    
--    Description:
--     
--    Language: KAREL
--    
--    Source File: 
-- 
--    Description - 
--
--    SYNTAX:
--    CALL FINDBODY(VP)
--
--      VP : Vision Process Name                   String
--
--    Author: David R. Friedeman 
--            Fanuc Robotics America
--    
--    Modification history:
--  04/27/18 FRIEDEMAN Created for GM G4.
--
--
------------------------------------------------------------------
PROGRAM FINDBODY
------------------------------------------------------------------
%ALPHABETIZE
%COMMENT = 'FINDBODY V833/03'
%NOPAUSE = ERROR + COMMAND + TPENABLE
%NOLOCKGROUP 
%ENVIRONMENT PC
%ENVIRONMENT REGOPE
%ENVIRONMENT IOBLT
%ENVIRONMENT SYSDEF
%ENVIRONMENT CVIS
%SYSTEM
%NOBUSYLAMP
%RWACCESS

%INCLUDE kliotyps
%INCLUDE gmpntcon
%INCLUDE etdccust

VAR
%INCLUDE gmpntvar
  status       : INTEGER
  data_type    : INTEGER
  int_value    : INTEGER
  real_value   : REAL
  string_value : STRING[16]
  vis_proc_nam : STRING[16]
  vis_rqst_num : INTEGER
  vis_stat     : INTEGER
  dummy_int    : INTEGER
  dummy_bool   : BOOLEAN
  dummy_real   : REAL
  vis_timer    : INTEGER
  vis_done     : BOOLEAN
  nom_frm_num  : INTEGER
  real_flag    : BOOLEAN
  nominal_flag : INTEGER
  nominal_pos  : POSITION
  nominal_xyz  : XYZWPR
  located_xyz  : XYZWPR
  diff_xyz     : XYZWPR
  offset_xyz   : XYZWPR
  offset_pos   : POSITION
  inc_retry    : INTEGER
  max_num_rtry : INTEGER
  use_rotation : INTEGER

  index        : INTEGER
  string_size  : INTEGER
  dat_buffer   : ARRAY[MAX_BUFFER] OF BYTE

  cam_view_num : INTEGER
  vis_reg_num  : INTEGER
  find_status  : INTEGER -- Status of "FIND" operation
  get_status   : INTEGER -- Status of "GET" operation

  ofst_tol_xyz : REAL
  ofst_tol_wpr : REAL

  vp_name_str  IN CMOS FROM V500_VAR : STRING[16]
  vp_status    IN CMOS FROM V500_VAR : INTEGER
  vp_pr_index  IN CMOS FROM V500_VAR : INTEGER


ROUTINE check_port( p_io_type, p_index : INTEGER): BOOLEAN FROM pntutils

------------------------------------------------------------------------------
ROUTINE get_real_reg(l_reg_num:INTEGER):REAL -- gets real values of registers
------------------------------------------------------------------------------
VAR
  l_real_flag : BOOLEAN
  l_int_val   : INTEGER
  l_real_val  : REAL
  l_status    : INTEGER

BEGIN
  GET_REG(l_reg_num, l_real_flag, l_int_val, l_real_val, l_status)
  IF l_status <> 0 THEN
    -- WRITE (CR,'BAD DATA FOR REG ',l_reg_num) 
    RETURN(99999)
  ENDIF
  IF NOT l_real_flag THEN
    l_real_val = l_int_val
  ENDIF
  RETURN(l_real_val)
END get_real_reg



---------------------------------------------------------------------------
BEGIN
--
--  Send Data(p1,p2,p3,....pMAX_PARAMS)
--
-- initialize the data types
---------------------------------------------------------------------------

  IF UNINIT(visn_debug) THEN
    visn_debug = FALSE
  ENDIF	

  FOR index = 1 TO MAX_BUFFER DO
    dat_buffer[index] = 0
  ENDFOR

  vis_proc_nam = ''
  status       = 0

  IF check_port(di_ghost_t,di_ghost_i) THEN  
    IF (DIN[di_ghost_i] = TRUE) THEN      
      -- Set zero offsets and return to TP program
      offset_xyz = $MOR_GRP[1].$NILPOS
      -- Save current offset value, for use by TP program
      set_pos_reg(VIS_CUR_OFST,offset_xyz, status)
      -- Set the correct frame, with zero offset.
      $MNUFRAME[1,1] = $MNUFRAME[1,2] : offset_xyz
      POST_ERR(ER3DLGHOSTOF,'',0,ER_WARN) -- Run Without Offsets
      RETURN
    ENDIF
  ENDIF					    

  -- Get the parameters passed by the calling program
  -- The first parameter is the vision process name
  GET_TPE_PRM(1, data_type, int_value, real_value, vis_proc_nam, status)
  IF vis_proc_nam = '' THEN 
    POST_ERR(ER3DLPARAM1,'',0,ER_ABORT) -- First Vision Parameter Value Bad
    DELAY 200 -- Give time to abort
  ENDIF

--  -- Get the NOMINAL frame number
--  GET_TPE_PRM(2, data_type, nom_frm_num, real_value, string_value, status)
--  IF (status <> 0) or (data_type <> PARM_INTEGER) THEN
--    POST_ERR(ER3DLPARAM3,'',0,ER_ABORT) -- Nominal Parameter Value Bad
--    DELAY 200 -- Give time to abort
--  ENDIF

  REPEAT
    vis_rqst_num = 0
    vis_timer    = 0
    vis_done     = FALSE
    cam_view_num = 0  -- Camera '0' is really Camera 1
    vis_reg_num  = 1  -- Always stuff value into VR[1].
    vis_stat = VIS_PENDING


    -- Reset the "Number of automatic vision re-snaps" to zero.
    SET_INT_REG(VIS_CUR_FIND,0,status)
    -- Get the maximum number of automatic vision retry attempts.
    GET_REG(VIS_RE_FIND, dummy_bool, max_num_rtry, dummy_real, dummy_int)
    CONNECT TIMER TO vis_timer
    REPEAT -- Automatically try vision a couple of times
      vis_stat = VIS_PENDING
      vis_rqst_num = vis_rqst_num + 1

      -- Snap the picture
      v_run_find(vis_proc_nam, cam_view_num, find_status)

      DELAY 20

      IF (find_status = 0) THEN

        -- Set nominal data, if the Register is set to 1
        get_reg(VIS_MODE_REG,real_flag,nominal_flag,real_value,status)
     
        IF nominal_flag = 1 THEN
          -- Set the 'Nominal' register back to zero.
          v_set_ref(vis_proc_nam,status)
          DELAY 1000
          set_int_reg(VIS_MODE_REG, 0, status)
--          write(cr,'Nominal Value ',nom_frm_num,' Saved!')
        ENDIF
      ENDIF

      -- Get the offset
      v_get_offset(vis_proc_nam, vis_reg_num, get_status)

      IF (visn_debug = TRUE) THEN
        write(cr,vis_proc_nam,' v_run_find stat = ', find_status)
        write(cr,vis_proc_nam,' v_get_offset stat = ', get_status)
      ENDIF

      -- '0' returned from vision calls means success.  Nonzero = error.
      IF (find_status = 0) AND (get_status = 0) THEN
        vis_stat = VIS_SUCCESS

        -- Set nominal data, if the Register is set to 1
        get_reg(VIS_MODE_REG,real_flag,nominal_flag,real_value,status)

      ENDIF

      IF (vis_stat <> VIS_SUCCESS) THEN
        GET_REG(VIS_CUR_FIND, dummy_bool, inc_retry, dummy_real, dummy_int)
        SET_INT_REG(VIS_CUR_FIND,inc_retry + 1,status)
        -- Only post a message on the first retry attempt
        IF (vis_rqst_num < max_num_rtry) AND (vis_rqst_num = 1) THEN
          POST_ERR(ER3DLRUFRTRY,'inc_retry + 1', 0, ER_WARN) -- Vision Offset Retry Attempt
        ENDIF
        DELAY 100 -- Give up some cpu time before retry.
      ENDIF
    UNTIL (vis_stat = VIS_SUCCESS) OR (vis_rqst_num >= max_num_rtry) OR
          (vis_timer> 15000)  -- Don't wait for timeout 5x
    IF (vis_stat = VIS_SUCCESS) THEN

      -- Do the math here, so we can do offset tolerance checking
      -- before exiting the program.
      -- Get the results from the vision system
      --
      -- Write the offset value to a PR.
      vreg_offset(vis_reg_num,VIS_CUR_OFST, status)
      IF (status <> 0) THEN
        write(cr,'Failed to read vision register ',vis_reg_num)
      ENDIF

      located_xyz = get_pos_reg(VIS_CUR_OFST, status)

      -- Do we want to use rotations?
      GET_REG(VIS_FBROTENB, dummy_bool, use_rotation, dummy_real, dummy_int)

      IF (use_rotation = 0) THEN
      -- Don't care about rotations.  Set them to zero.
        located_xyz.w = 0
        located_xyz.p = 0
        located_xyz.r = 0
      ENDIF

      -- Get the Offset Tolerance register values and compare them to the
      -- actual offsets. Data could be REAL or INTEGER.  Use Real data type.

      ofst_tol_xyz = get_real_reg(V_XYZTOL_REG)
      ofst_tol_wpr = get_real_reg(V_WPRTOL_REG)

      IF (ABS(located_xyz.x) > ofst_tol_xyz) OR
         (ABS(located_xyz.y) > ofst_tol_xyz) OR
         (ABS(located_xyz.z) > ofst_tol_xyz) OR
         (ABS(located_xyz.w) > ofst_tol_wpr) OR
         (ABS(located_xyz.p) > ofst_tol_wpr) OR
         (ABS(located_xyz.r) > ofst_tol_wpr) THEN
        POST_ERR(ER3DLOFSTTOL,'',0,ER_PAUSE)
      ELSE
        -- Okay...
        vis_done = TRUE
        -- Don't set the frame if there was an offset tolerance error.
        $MNUFRAME[1,1] = $MNUFRAME[1,2] : located_xyz
      ENDIF

      -- Set up the data for the GUI...
      vp_name_str = vis_proc_nam -- Vis Process Name
      vp_status   = vis_stat     -- Status
      vp_pr_index = VIS_CUR_OFST -- Pointer to PR containing the offset

      IF check_port(do_data_ok_t,do_data_ok_i) THEN
        PULSE DOUT[do_data_ok_i] FOR 500 NOWAIT
      ENDIF

    ELSE
      IF (vis_timer > 15000) THEN
        -- Post timeout
        POST_ERR(ER3DLTIMEOUT,'',0,ER_PAUSE) -- 3DL Time Out
        DELAY 250
      ELSE
        -- Post whatever error iRVision detected
        IF (find_status <> 0) THEN
          POST_ERR(find_status,'',0,ER_WARN) -- Error during FIND operation
        ENDIF
        IF (get_status <> 0) THEN
          POST_ERR(get_status,'',0,ER_WARN)  -- Error during GET operation
        ENDIF
        -- Too many retries - Post 'Not Found'
        POST_ERR(ER3DLRUFLOCF,'',0,ER_PAUSE) -- 3DL Target Not Found
        DELAY 250
      ENDIF
    ENDIF

  UNTIL (vis_done = TRUE)

END FINDBODY
