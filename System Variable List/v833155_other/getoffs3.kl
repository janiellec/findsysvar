--    This material is the property of Fanuc Robotics America  
--    and must be  eturned to Fanuc Robotics America  
--    immediately upon request.  This  material
--    and the information illustrated or contained herein may not be
--    reproduced, copied, used, or transmitted in whole or in part in any way
--    without the prior written consent of Fanuc Robotics America  
--    
--             All Rights Reserved
--             Copyright (C)   1999, 2000
--             Fanuc Robotics America  
--    
--             Karel is a registered trademark of
--             Fanuc Robotics America  
--    +
--    Program:  
--    
--    Description:
--     
--    Language: KAREL
--    
--    Source File:  
-- 
--    Description - 
--
--    SYNTAX:
--    CALL GETOFFS3(VP,Cam View Num)
--
--      VP : Vision Process Name                   String
--      Cam View Num : Camera View Number          Integer
--
--    Author: David R. Friedeman 
--            Fanuc Robotics America
--    
--    Modification history:
--  04/27/18 FRIEDEMAN Created for GM G4.
--
--
------------------------------------------------------------------
PROGRAM GETOFFS3
------------------------------------------------------------------
%ALPHABETIZE
%COMMENT = 'GETOFFS3 V833/03'
%NOPAUSE = ERROR + COMMAND + TPENABLE
%NOLOCKGROUP 
%ENVIRONMENT PC
%ENVIRONMENT REGOPE
%ENVIRONMENT IOBLT
%ENVIRONMENT CVIS
%ENVIRONMENT SYSDEF
%SYSTEM
%NOBUSYLAMP
%RWACCESS

%INCLUDE kliotyps
%INCLUDE gmpntcon
%INCLUDE etdccust

VAR
%INCLUDE gmpntvar
  status       : INTEGER
  data_type    : INTEGER
  int_value    : INTEGER
  real_value   : REAL
  string_value : STRING[16]
  vis_proc_nam : STRING[16]
  vis_rqst_num : INTEGER
  vis_stat     : INTEGER
  dummy_int    : INTEGER
  dummy_bool   : BOOLEAN
  dummy_real   : REAL
  vis_timer    : INTEGER
  vis_done     : BOOLEAN
  nominal_flag : INTEGER
  real_flag    : BOOLEAN

  index        : INTEGER
  string_size  : INTEGER
  dat_buffer   : ARRAY[MAX_BUFFER] OF BYTE

  autoskip_enb : INTEGER
  disbl_offst  : BOOLEAN

  cam_view_num : INTEGER
  vis_reg_num  : INTEGER
  find_status  : INTEGER -- Status of "FIND" operation
  get_status   : INTEGER -- Status of "GET" operation
  num_found    : INTEGER -- Number of targets found in the camera view
  max_num_rtry : INTEGER -- Number of automatic retry attempts

  vp_name_str  IN CMOS FROM V500_VAR : STRING[16]
  vp_status    IN CMOS FROM V500_VAR : INTEGER
  vp_pr_index  IN CMOS FROM V500_VAR : INTEGER

  offset_xyz   : XYZWPR

ROUTINE check_port( p_io_type, p_index : INTEGER): BOOLEAN FROM pntutils

---------------------------------------------------------------------------
BEGIN
--
--  Send Data(p1,p2,p3,....pMAX_PARAMS)
--
-- initialize the data types
---------------------------------------------------------------------------

  FOR index = 1 TO MAX_BUFFER DO
    dat_buffer[index] = 0
  ENDFOR

  vis_proc_nam = ''
  cam_view_num = 0
  status       = 0

  -- Get the parameters passed by the calling program
  -- The first parameter is the vision process name
  GET_TPE_PRM(1, data_type, int_value, real_value, vis_proc_nam, status)
  IF vis_proc_nam = '' THEN -- First parameter not a string
    POST_ERR(ER3DLPARAM1,'',0,ER_ABORT) -- Vision Process Name Parameter Bad
    DELAY 200 -- Give time to abort
  ENDIF

  -- The second parameter is the index for the positional data (PR[X])
  GET_TPE_PRM(2, data_type, cam_view_num, real_value, string_value, status)

  IF (cam_view_num <> 1) AND (cam_view_num <> 2) AND (cam_view_num <> 3) THEN --**
    POST_ERR(ER3DLPARAM2,'',0,ER_ABORT) -- iRV Multi-Find Index Invalid
    DELAY 200 -- Give time to abort
  ENDIF

  disbl_offst = FALSE

  IF check_port(di_ghost_t,di_ghost_i) THEN  
    IF (DIN[di_ghost_i] = TRUE) THEN      
      disbl_offst = TRUE				    
      vis_stat = VIS_SUCCESS
      -- Set the flag for the TP program - Without this the software might
      -- retry vision repeatedly because the status is bad.
      SET_INT_REG(VIS_PROC_OK,1,status)
      offset_xyz = $MOR_GRP[1].$NILPOS
      -- Ghost mode, so save (0,0,0,0,0,0) in the offset register.
    ENDIF
  ENDIF					    

  -- Skip vision operations if we're in ghost mode.
  IF (disbl_offst = FALSE) THEN

    -- If this is the first snap, let's assume that the vision is okay
    IF (cam_view_num = 1) THEN
      SET_INT_REG(VIS_PROC_OK,1,status) -- Set the flag for the TP program
    ENDIF

    -- Get the maximum number of automatic vision retry attempts.
    GET_REG(VIS_RE_FIND, dummy_bool, max_num_rtry, dummy_real, dummy_int)

    REPEAT
      vis_rqst_num = 0
      vis_timer    = 0
      vis_done     = FALSE
      --cam_view_num = 0  -- Camera '0' is really Camera 1
      vis_reg_num  = 1  -- Always stuff value into VR[1].
      vis_stat = VIS_PENDING
      num_found = 0

      CONNECT TIMER TO vis_timer
      REPEAT -- Automatically try vision a couple of times
        vis_stat = VIS_PENDING
        vis_rqst_num = vis_rqst_num + 1

        -- Snap the picture
        v_run_find(vis_proc_nam, cam_view_num, find_status)

        DELAY 20

        IF (visn_debug = TRUE) THEN
          write(cr,vis_proc_nam,' v_run_find stat = ', find_status)
          write(cr,vis_proc_nam,' v_get_offset stat = ', get_status)
        ENDIF

        -- Add irvisfnd stuff here - Do for all finds so that auto retries
        -- work.
        v_get_vparam(vis_proc_nam,0,cam_view_num,VIS_NUMFOUND,status) 

        DELAY 50

        GET_REG(VIS_NUMFOUND, real_flag, num_found, dummy_real, dummy_int)
        -- STUPID v_get_vparam sets the "Number Found" to a REAL number!!!
        -- If the register was set to a real number instead of an integer,
        -- capture the correct value.
        IF (real_flag = TRUE) THEN
          num_found = trunc(dummy_real)
        ENDIF

        -- '0' returned from vision calls means success.  Nonzero = error.
        IF (find_status = 0) AND (num_found > 0) THEN
          vis_stat = VIS_SUCCESS
        ENDIF

      UNTIL (vis_stat = VIS_SUCCESS) OR (vis_rqst_num >= max_num_rtry) OR
            (vis_timer> 15000)  -- Don't wait for timeout 5x
      IF (vis_stat = VIS_SUCCESS) THEN
        vis_done = TRUE
        -- Don't do this here.  Only save the data if it is the result of the
        -- 3-D Multi-View vision find.  This leaves the rough body location
        -- offset saved in PR[2] (VIS_CUR_OFST)
        -- Write the offset value to a PR.
        --vreg_offset(vis_reg_num,VIS_CUR_OFST, status)  -- Current offset reg
        IF (status <> 0) THEN
          write(cr,'Failed to read vision register ',vis_reg_num)
        ENDIF

      ELSE
        IF (vis_timer > 15000) THEN
          -- Post timeout
          POST_ERR(ER3DLTIMEOUT,'',0,ER_PAUSE) -- Vision Request Time Out
          DELAY 250
        ELSE
          -- Too many retries - Post 'Not Found'
          -- If this error occurred on the second (or third) vision find, then
          -- we must re-find the entire vehicle body part.  This assumes that
          -- an operator will move the vehicle to get the vision to work, and
          -- if SOME of the vehicle has already been successfully found, the
          -- a bad offset will be computed.  The TP program will automatically
          -- re-start the find process if R[VIS_PROC_OK] = 0.
          IF (cam_view_num > 1) THEN  --**
            SET_INT_REG(VIS_PROC_OK,0,status) -- Set the flag for the TP program    
          ENDIF
          POST_ERR(ER3DLNOFOUND,'',0,ER_PAUSE) -- Vision Target Not Found
          DELAY 250
        ENDIF
      ENDIF

    UNTIL (vis_done = TRUE)

    -- If this is the third find, then...   --**
    IF (cam_view_num = 3) THEN              --**

      -- Set nominal data, if the Register is set to 1
      get_reg(VIS_MODE_REG,dummy_bool,nominal_flag,real_value,status)

      -- Nominalization is supposed to be done before the v_get_offset.
      -- This sets the reference for the individual snaps and ensures that a
      -- "Zero" offset is received for the current operation.
      IF nominal_flag = 1 THEN
        v_set_ref(vis_proc_nam,status)
        -- Turn OFF the Nominalization Request
        set_int_reg(VIS_MODE_REG, 0, status)
        DELAY 200
        IF(status <> 0) THEN
          -- Make sure they know it failed!!!
          POST_ERR(status,'',0,ER_WARN)
          DELAY 100
          POST_ERR(ERIRVNOMFAIL,'',0,ER_PAUSE)
          DELAY 200
        ENDIF
      ENDIF

      -- Get the combined offset
      v_get_offset(vis_proc_nam, vis_reg_num, get_status)

      -- Save the offset in a position register (PR[1])
      vreg_offset(vis_reg_num,OFFSET_REG,status)

      IF (get_status = 0) THEN

        -- Set up the data for the GUI...
        vp_name_str = vis_proc_nam -- Vis Process Name
        vp_status   = vis_stat     -- Status
        vp_pr_index = OFFSET_REG   -- Pointer to PR containing the offset

        IF check_port(do_data_ok_t,do_data_ok_i) THEN
          PULSE DOUT[do_data_ok_i] FOR 500 NOWAIT
        ENDIF

        -- Don't set this here... it overwrites the attempt to retry if the
        -- second vision operation (initially) failed.
        -- SET_INT_REG(VIS_PROC_OK,1,status) -- Set the flag for the TP program
      ELSE
        POST_ERR(ER3DLNOFOUND,'',0,ER_PAUSE) -- Failure Code
        get_status = 0 -- Reset for next time.
        SET_INT_REG(VIS_PROC_OK,0,status) -- Set the flag for the TP program    
      ENDIF
    ENDIF

    vp_name_str  = vis_proc_nam
    vp_status    = vis_stat

  ELSE -- We're in Ghost mode - Tell the TP program it's okay to continue.

    SET_INT_REG(VIS_PROC_OK,1,status) -- Set the flag for the TP program
    POST_ERR(ER3DLGHOSTOF,'',0,ER_WARN) -- Run Without Offsets

  ENDIF 

END GETOFFS3
