-- -----------------------------------------------------------------------
--
--   MODULE:         GMUTILITY.KL
--   TITLE:          GMUTILTY PROGRAM
--
--
--   WRITTEN BY:     RANDY KOSASKI
--   REVISION DATE:  1/23/16
--
--   LANGUAGE:       KAREL 8.33 R30iB
--   CONTROL GROUP:  BODY SHOP EXECUTION GROUP
--   STATUS:
--
--
--   ORDER NUMBER:   GMGBL4
--   PROJECT NAME:   GM Global Center
--
--
--         FANUC Robotics retains rights in any and all Software
--         contained in the material attached hereto and said
--         Software may not be copied or reproduced without the
--         written permission of FANUC Robotics.
--
--         All Software, (C) Copyright FANUC Robotics Corporation, 2016
--         DESCRIPTION: Vision Program  program files. These routines will be
--                      called from the main wizard, no prompts are in the Variable file
--                      only the setttings GMWIZMH,GMWIZVIS are the questions
--
--         HISTORY OF CHANGES:
--
--         REVISION   DATE       BY               COMMENTS
--         --------   ---------  ---------------  --------------------
--          A         5/15/16    R.Kosaski        Clear_prog routine was using CHK_LOADED routine changed to use laod status
--
--                    12/3/16    R.Kosaski        Some clean up and added USER PAGE display to ExecSetupAgn
--                                                routine .
--                    1/27/17    R.Kosaski        Added a routine to search file app back for open location.
--          V4.1      2017/02/09 marchaka         Add do_kcl_Cmnd routine for the usage of KCL commands
--          V4.1      2017/03/21 marchaka         Add LaserLine error severity
--			6/23/17  R.Kosaski        Added routine for checking simulation
--          V4.2      2017/07/03 marchaka         Added SPRUNCMD utility
--          V4.3      2018/03/12 marchaka         Added laser app error severities
--          V4.3      2018/04/09 marchaka         Change bwirf_err_sv to 0
--          V4.3      2018/04/30 marchaka         Change
--          V4.4      2019/08/24 marchaka         Added Set_Reg_Val to set integers for data registers
--          V4.4      2019/09/16 marchaka         Added ipfoR_Err_Sv for IPFO with RSI application
--          V4.4      2019/09/25 kosaskirr        Added GET var Routine
--          V4.5      2020/11/05 schoensm         Added PCORP PVALV and Ream error severity for V8.33P10 Laser Grind/Clean
-- --------------------------------------------------------------------------
PROGRAM gmutility
-- --------------------------------------------------------------------------
%COMMENT = 'GM CmnRtns V4.5'

%NOLOCKGROUP
%INVISIBLE
%RWACCESS
%NOPAUSE = ERROR + COMMAND + TPENABLE
%ENVIRONMENT REGOPE -- required for register builtins
%ENVIRONMENT proddef -- Required for the $FEATURE.$MOD[i] variable
%ENVIRONMENT FDEV -- Required for teh COPYFILE builtin
%ENVIRONMENT STRNG -- Required for the Convert Int& Real builtins
%ENVIRONMENT IOSETUP -- Required for teh Set_port_Asg builtin
%ENVIRONMENT MNMCDEF -- Required for the MarcoTable system variables
%ENVIRONMENT TPE -- required for the set_attr tp program header
%ENVIRONMENT SYSDEF -- required for the $TP_INUSER
%ENVIRONMENT KCLOP  -- required for teh KCL command in the DO_KCL_CMND routine
%INCLUDE KLEVCCDF  -- Required for the TPERROR write command for the contants

CONST
 Version = '2020-11-20'
 %INCLUDE KLIOTYPS -- Need for the I/O type declaration
 %INCLUDE gmcnstnt -- all GM constants declared

VAR
  Current_Ver  IN SHADOW :STRING[32] -- Set equal to Version constant in initialization routine

  Enable_Log,
  Reset_Cell   IN SHADOW FROM GMCFGCEL: BOOLEAN -- Used for if all the Cell I/O should be all reset
  TotalErrors,
  Var_Errors,
  SV_Errors,
  load_errors,  -- used by the LOAD_FILE routine to track how many errors occured, Program using should read value
                -- before start loading, then read after they are done, to see how many errors occured
  clear_errors, -- used by the CLEAR_PROG routine to track how many errors occured, Program using should read value
                -- before start clearing, then read after they are done, to see how many errors occured
  copy_errors,
  ans,i,gm_status  : INTEGER
  IO_Errors,Reg_Errors, -- used to count builtins errors for evaluation in end of wizard
  l_entry :INTEGER -- used for the Set_XYZ builtins for entry
  Err_Prefix :STRING[12] -- used to hold the error for data type is failure
  FileNameOnly :STRING[16] -- used for the returned value of a substring builting for program name
  loaded, initialized : BOOLEAN -- Used for for the LOAD_STATUS builtin

-- RK added 9-25-19 for GETSYSVAR routine
  SVrRtrndStr  : STRING[40] -- Used for returned string in the GET_SVAR routine
  SVrRtrndInt  : INTEGER -- Used for returned integer in the GET_SVAR routine
  SVrRtrndRel  : REAL -- Used for returned real value in the GET_SVAR routine
  SVrGetSuces  : BOOLEAN -- used to return if get system variable was successful

-- Workcell Shop specific variables
Cell_IO_Done IN SHADOW FROM GMCellIO: BOOLEAN -- if the workcell I/O has ran completly
CellVarsDone IN SHADOW FROM GMCellVR: BOOLEAN -- if the workcell variables has ran completly
CellPrgsDone IN SHADOW FROM GMCellPG: BOOLEAN -- if the workcell programs has ran completly
CellRegsDone IN SHADOW FROM GMCellRG: BOOLEAN -- if the workcell registers has ran completly

-- Press Shop specific variables
Pres_IO_Done IN SHADOW FROM GMPRESIO: BOOLEAN -- if the I/O has ran completly
PresVarsDone IN SHADOW FROM GMPRESVR: BOOLEAN -- if the variables has ran completly
PresPrgsDone IN SHADOW FROM GMPRESPG: BOOLEAN -- if the programs has ran completly
PresRegsDone IN SHADOW FROM GMPRESRG: BOOLEAN -- if the registers has ran completly

-- GMPT specific variables
GMPT_IO_Done IN SHADOW FROM GMPT_IO: BOOLEAN  -- if the I/O has ran completly
GMPTVarsDone IN SHADOW FROM GMPTVARS: BOOLEAN -- if the variables has ran completly
GMPTPrgsDone IN SHADOW FROM GMPTREGS: BOOLEAN -- if the programs has ran completly
GMPTRegsDone IN SHADOW FROM GMPTPRGS: BOOLEAN -- if the registers has ran completly

-- MH specific vars

  Grp_Is_Setup IN SHADOW FROM GMMHGPIO: BOOLEAN -- Keeps track if routine setup Mhgrip at least first time
  Grp_Is_GRS4  IN SHADOW FROM GMMHGPIO: BOOLEAN -- Identifies if MHGRIP is configured to GRS4 Spec
  InBlockSetup IN SHADOW FROM GMMHGPIO: ARRAY[Max_In_Blks] OF BOOLEAN -- indicates if the input block has been setup before
  AnalgInSetup IN SHADOW FROM GMMHGPIO: ARRAY[Max_In_Blks] OF BOOLEAN -- indicates if the Analog Inputs has been setup before
  OutVlvSetup  IN SHADOW FROM GMMHGPIO: ARRAY[Max_OutBlks] OF BOOLEAN -- indicates if the Valve Pack has been setup before
  Reg_MH_Setup IN SHADOW FROM GMMHREGS: BOOLEAN  -- Keeps track if routine setup Mh Registers at least first time
  Prg_MH_Setup IN SHADOW FROM GMMHREGS: BOOLEAN  -- Keeps track if routine setup Mh Programs at least first time
  IO_MH_Setup  IN SHADOW FROM GMMHREGS: BOOLEAN  -- Keeps track if routine setup Mh I/O at least first time
  Var_MH_Setup IN SHADOW FROM GMMHVARS : BOOLEAN -- Keeps track if routine setup Mh Vars at least first time

-- Vision setups
  Visn_IO_Done IN SHADOW FROM GMVISNIO: BOOLEAN -- if the I/O has ran completly
  VisnVarsDone IN SHADOW FROM GMVISVAR: BOOLEAN -- if the variables has ran completly
  VisnPrgsDone IN SHADOW FROM GMVISPRG: BOOLEAN -- if the programs has ran completly
  VisnRegsDone IN SHADOW FROM GMVISREG: BOOLEAN -- if the registers has ran completly

-- Tool Changer Vars
  NestisSetup  IN SHADOW FROM GMTLCHIO: ARRAY[4] OF BOOLEAN -- indicates if the tool stand has been setup before
  TC_Is_Setup  IN SHADOW FROM GMTLCHIO: BOOLEAN             -- indicates the Tool Changer has already been setup

    Armor_Err_Sv,
    Cell_Err_Sv,
    WTC_Err_Sv,
    EtStd_Err_Sv,
    HenRb_Err_Sv,
    Nelsn_Err_Sv,
    SqrD_Err_Sv,
    RqSvr_Err_Sv,
    Tool_Err_Sv,
    Sca_Err_Sv,
    Weber_Err_Sv,
    LsrLn_Err_Sv,
    Bwirf_Err_Sv,
    Lproc_Err_Sv,
    ScSon_Err_Sv,
    Trumf_Err_Sv,
    Ipfo_Err_Sv,
    IpfoR_Err_Sv,
    SBI_Err_sv,
    Plwm_Err_Sv,
    PCor_Err_Sv,
    PVal_Err_Sv,
    Ream_Err_Sv IN SHADOW FROM GMENETSU: INTEGER -- Used for the Severity $EIP_CONN[x].$ERR_SV setting by GMENETSU

--%INCLUDE GMCFGERR -- the configuration errors and declaration for the error severity variable for each devise
%INCLUDE klrdutil
%INCLUDE gmrdutil

ROUTINE MHUSERPG FROM MHUSERPG  -- forces user screen to pendant
ROUTINE writeLog(p_message: STRING; isError: BOOLEAN) FROM GMWizLog  -- used to write an items to the log file
-------------------------------------------------------------------
ROUTINE Verify_Answr --(P_Answer:INTEGER;P_Min_Answer:INTEGER;P_Max_Answer:INTEGER):BOOLEAN
--                                                               --
-- Verify answer to all questions is valid. If the answer is Less--
-- than or two then the user cannot exit the question unitl a 1 or  --
-- 2 is inputed by the user                                     --
-------------------------------------------------------------------
VAR
Verified:BOOLEAN --returned value if valid True is OK False out of Range

BEGIN
 Verified = FALSE -- set default to False

  IF ((P_Answer <P_Min_Answer) OR (P_Answer> P_Max_Answer)) THEN
    WRITE (cr,'Entry of',P_Answer,' NOT valid. Must be',P_Min_Answer,' -',P_Max_Answer,cr)
    WRITE TPPROMPT (CR, 'Press ENTER key to try again')
    READ TPPROMPT (CR)
  ELSE -- is Verified in range passed Answer
    CLR_STND_SCR(gm_status)
    Verified = TRUE
  ENDIF

RETURN(verified)

END Verify_Answr
-----------------------------------------------------------------------------
ROUTINE clr_allSetup
-- PURPOSE: to clear all the SETUP variables to allow operator to not be prompted
--          again, can be tetious if setup has been done, but do not want to reset entire cell
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
--VAR

BEGIN

   Cell_IO_Done = FALSE
   CellVarsDone = FALSE
   CellPrgsDone = FALSE
   CellRegsDone = FALSE

   Pres_IO_Done = FALSE
   PresVarsDone = FALSE
   PresPrgsDone = FALSE
   PresRegsDone = FALSE

   GMPT_IO_Done = FALSE
   GMPTVarsDone = FALSE
   GMPTPrgsDone = FALSE
   GMPTRegsDone = FALSE

  FOR i = 1 TO ARRAY_LEN(InBlockSetup) DO
    InBlockSetup[i] = FALSE
  ENDFOR --
  FOR i = 1 TO ARRAY_LEN(OutVlvSetup) DO
    OutVlvSetup[i] = FALSE
  ENDFOR --
  FOR i = 1 TO ARRAY_LEN(AnalgInSetup) DO
    AnalgInSetup[i]= FALSE
  ENDFOR --

   Reg_MH_Setup = FALSE
   Prg_MH_Setup = FALSE
   IO_MH_Setup  = FALSE
   Var_MH_Setup = FALSE

   Visn_IO_Done = FALSE
   VisnVarsDone = FALSE
   VisnPrgsDone = FALSE
   VisnRegsDone = FALSE

-- Tool Changer
  FOR i = 1 TO ARRAY_LEN(NestisSetup) DO
    NestisSetup[i] = FALSE
  ENDFOR --
  TC_Is_Setup = FALSE            -- indicates the Tool Changer has already been setup



  RETURN
END clr_allSetup
-----------------------------------------------------------------------------
ROUTINE ExecSetupAgn --(P_deviceName:String):BOOLEAN
-- PURPOSE: some thing has already been setup, ask user to setup again, or
--          Move on to the next item.
--
--
-- INPUT:
--            -
-- OUTPUT:    Boolean if the user said yes or no
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
BEGIN
--**********************************************************************
--- Prompt User for direction if block should be remapped by the robot
--**********************************************************************

-- 12-3-16 RK added for if ran and not on user screen, looks like code is hung
-- 2-17-18 RK  IF ($TP_INUSER=FALSE) THEN
--    FORCE_SPMENU(tp_panel,SPI_TPUSER,1) -- force the user screen to display forms
--  ENDIF
-- 12-3-16 end of RK changes

  REPEAT
    CLR_STND_SCR(gm_status)

    WRITE(cr,P_deviceName,' has already',cr)
    WRITE('been setup before.',cr)
    WRITE('Executing again will RESET',cr)
    WRITE('the ',P_deviceName,' back',cr)
    WRITE('to default configuration',cr)
    WRITE('and comments.',cr)
    WRITE(cr,'Enter 1 to RESET, 0 to cancel.')
    READ(ans)
  UNTIL (Verify_Answr(Ans,0,1))-- Verify Answer is between 0&4

    CLR_STND_SCR(gm_status)

   IF Ans=1 THEN
     POST_ERR(38000,P_deviceName +' Reset by User', 0, 0) --
     WriteLog(P_deviceName+' Reset by User',FALSE)
     RETURN(TRUE)
   ELSE
     WriteLog(P_deviceName+' NOT reset by User',FALSE)
     WRITE TPERROR(CHR(cc_clear_win),P_deviceName,' NOT reset by User')
     RETURN(FALSE)
   ENDIF

END ExecSetupAgn
-----------------------------------------------------------
ROUTINE int2str --(p_integer:INTEGER):STRING
-- Routine to convert integers to string variables
-----------------------------------------------------------
VAR
  l_string: STRING[9]
BEGIN
  l_string = ''
IF UNINIT(p_integer) THEN
  p_integer = 0
ENDIF

  CNV_INT_STR(p_integer, 0, 0, l_string)
  RETURN(SUB_STR(l_string, 2, STR_LEN(l_string)))
END int2str

-----------------------------------------------------------------------------
ROUTINE real2str--(p_real:REAL):STRING
--
-- PURPOSE:  to convert Reals to string variables
--
 ----------------------------------------------------------------------------

VAR
  l_string: STRING[14]

BEGIN
   l_string = ''
IF UNINIT(p_real) THEN
  p_real = 0
ENDIF

   CNV_REAL_STR(p_real, 4, 2, l_string)
  RETURN(SUB_STR(l_string, 2, STR_LEN(l_string)))

IF UNINIT(l_string) THEN
  l_string = '??.??'
ENDIF

  RETURN(l_string)

END real2str
-----------------------------------------------------------------------------
ROUTINE ClrUtltyErrs
-- PURPOSE: to clear any existing errors. this is done at beginning of a routine
--          that uses the common routine in this utility. when routine calls are done
--          then call the AddUtltyErrs and it will identify all errors. if specific one needed
--          then that can also be done.
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
-----------------------------------------------------------------------------
BEGIN

   Clear_errors = 0 --  errors from Clear program routine
   load_errors  = 0 --  errors from loading routine
   IO_Errors    = 0 --  errors from I/O port Config routine
   Copy_Errors  = 0 --  errors from copy file routine
   Reg_Errors   = 0 --  errors from Register comment routine
   SV_Errors    = 0 --  the system variable setting errors
   Var_Errors   = 0 --  the program variables setting errors
END ClrUtltyErrs
-----------------------------------------------------------------------------
ROUTINE AddUtltyErrs--:INTEGER
-- PURPOSE: to add all teh erros in this program for other routine to determine
--          success of all the routines used in each program call
-- OUTPUT:
--            -
-- CALLED BY: Any program, I.E GMCELLIO, GMCELLVR,CMCELLPRG,GMCELLRG
--
--
-----------------------------------------------------------------------------

BEGIN

TotalErrors = 0
TotalErrors = TotalErrors + Clear_errors -- added errors from Clear program routine
TotalErrors = TotalErrors + load_errors  -- added errors from loading routine
TotalErrors = TotalErrors + IO_Errors    -- added errors from I/O port Config routine
TotalErrors = TotalErrors + Copy_Errors  -- added errors from copy file routine
TotalErrors = TotalErrors + Reg_Errors  -- added errors from Register comment routine
TotalErrors = TotalErrors + SV_Errors -- added the system variable setting errors
TotalErrors = TotalErrors + Var_Errors -- Add general Var settings
  RETURN(TotalErrors)

END AddUtltyErrs
-----------------------------------------------------------
ROUTINE set_B_sVar --(P_var_name:STRING;P_Bvar_value:BOOLEAN)
-- PURPOSE: to Set system variables that have a boolean Type
--
--
-- INPUT:  The system Variable to set passed as a string
--         the boolean to set to
--
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(SV_Errors) THEN -- this should be set, but double check
  SV_Errors = 0
ENDIF

 SET_VAR(l_entry,'*SYSTEM*',P_var_name,P_Bvar_value,gm_status)
   IF gm_status <> 0 THEN
     POST_ERR(38000, '[*SYSTEM*]'+P_var_name+' FAILED', gm_status, 0) --
     WriteLog('[*SYSTEM*]'+P_var_name+' to BOOLEAN FAILED,Status ='+int2Str(gm_status), TRUE)
     SV_Errors = SV_Errors + 1
   ENDIF

  RETURN
END set_B_sVar
-----------------------------------------------------------------------------
ROUTINE Set_I_sVar --(P_var_name:STRING;P_Ivar_value:INTEGER)
-- PURPOSE: to Set system variables that have a Interger Type
--
--
-- INPUT:  The system Variable to set passed as a string
--         the integer to set to
--
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(SV_Errors) THEN -- this should be set, but double check
  SV_Errors = 0
ENDIF

 SET_VAR(l_entry,'*SYSTEM*',P_var_name,P_Ivar_value,gm_status)
   IF gm_status <> 0 THEN
     POST_ERR(38000, '[*SYSTEM*]'+P_var_name+' to ' + int2str(P_Ivar_value)+ ' FAILED' , gm_status, 0) --
     WriteLog('[*SYSTEM*]'+P_var_name+' to ' +int2str(P_Ivar_value)+ ' FAILED,Status ='+int2Str(gm_status), TRUE)
    SV_Errors = SV_Errors + 1
   ENDIF

END Set_I_sVar
-----------------------------------------------------------------------------
ROUTINE Set_S_sVar --(P_var_name:STRING;P_Svar_value:STRING)
-- PURPOSE: to Set system variables that have a String Type
--
--
-- INPUT:  The system Variable to set passed as a string
--
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(SV_Errors) THEN -- this should be set, but double check
  SV_Errors = 0
ENDIF

 SET_VAR(l_entry,'*SYSTEM*',P_var_name,P_Svar_value,gm_status)
   IF gm_status <> 0 THEN
     POST_ERR(38000, '[*SYSTEM*]'+P_var_name + ' to' + P_Svar_value+ ' FAILED' , gm_status, 0) --
     WriteLog('[*SYSTEM*]'+P_var_name+' to ' +P_Svar_value+ ' FAILED,Status ='+int2Str(gm_status), TRUE)
    SV_Errors = SV_Errors + 1
   ENDIF

END Set_S_sVar
-----------------------------------------------------------------------------
ROUTINE Set_R_sVar --(P_var_name:STRING;P_Rvar_value:REAL)
-- PURPOSE: to Set system variables that have a Real Type
--
--
-- INPUT:  The system Variable to set passed as a string
--         the Real to set to
--
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(SV_Errors) THEN -- this should be set, but double check
  SV_Errors = 0
ENDIF

 SET_VAR(l_entry,'*SYSTEM*',P_var_name,P_Rvar_value,gm_status)
   IF gm_status <> 0 THEN
     POST_ERR(38000, '[*SYSTEM*]'+P_var_name+' to' +real2str(P_Rvar_value)+ ' FAILED', gm_status, 0) --
     WriteLog('[*SYSTEM*]'+P_var_name+' to' +real2str(P_Rvar_value)+ ' FAILED', TRUE)
     SV_Errors = SV_Errors + 1
   ENDIF

END Set_R_sVar
-----------------------------------------------------------------------------
ROUTINE Set_B_PVar --(P_Prg_name:STRING;P_var_name:STRING;P_var_value:BOOLEAN)
-- PURPOSE: to Set Program variables that have a String Type
--
--
-- INPUT:  The Program Variable to set passed as a string
--
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(Var_Errors) THEN -- this should be set, but double check
  Var_Errors = 0
ENDIF

 --SET_VAR(l_entry, P_Prg_name, P_var_name, P_var_value,gm_status)

 SET_VAR(l_entry,P_Prg_name,P_var_name,P_var_value,gm_status)
   IF gm_status <> 0 THEN
     POST_ERR(38000, P_Prg_name +' '+ P_var_name + ' FAILED' , gm_status, 0) --
     WriteLog('['+P_Prg_name +']'+P_var_name + ' FAILED,Status ='+int2Str(gm_status), TRUE)
    Var_Errors = Var_Errors + 1
   ENDIF

END Set_B_PVar
-----------------------------------------------------------------------------
ROUTINE Set_I_PVar --(P_Prg_name:STRING;P_var_name:STRING;P_var_value:INTEGER)
-- PURPOSE: to Set Program variables that have a String Type
--
-- INPUT:  The Program Variable to set passed as a string
--
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(Var_Errors) THEN -- this should be set, but double check
  Var_Errors = 0
ENDIF

 --SET_VAR(l_entry, P_Prg_name, P_var_name, P_var_value,gm_status)

 SET_VAR(l_entry,P_Prg_name,P_var_name,P_var_value,gm_status)
   IF gm_status <> 0 THEN
     POST_ERR(38000, P_Prg_name +' '+P_var_name +' to '+ int2Str(P_var_value) + ' FAILED' , gm_status, 0) --
     WriteLog('['+P_Prg_name +']'+P_var_name + ' FAILED,Status ='+int2Str(gm_status), TRUE)
    Var_Errors = Var_Errors + 1
   ENDIF

END Set_I_PVar
-----------------------------------------------------------------------------
ROUTINE Set_R_PVar --(P_Prg_name:STRING;P_var_name:STRING;P_var_value:REAL)
-- PURPOSE: to Set Program variables that have a real Type
--
-- INPUT:  The Program Variable to set passed as a real
--
-- OUTPUT:
--            -
-- CALLED BY:
--
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(Var_Errors) THEN -- this should be set, but double check
  Var_Errors = 0
ENDIF

-- SET_VAR(l_entry, P_Prg_name, P_var_name, P_var_value,gm_status)

 SET_VAR(l_entry,P_Prg_name,P_var_name,P_var_value,gm_status)
   IF gm_status <> 0 THEN
     POST_ERR(38000, P_Prg_name +' '+ P_var_name+ ' to '+ Real2str(P_var_value) + ' FAILED' , gm_status, 0) --
     WriteLog('['+P_Prg_name +']'+P_var_name + ' FAILED,Status ='+int2Str(gm_status), TRUE)
    Var_Errors = Var_Errors + 1
   ENDIF

END Set_R_PVar
-----------------------------------------------------------------------------
ROUTINE Set_S_PVar --(P_Prg_name:STRING;P_var_name:STRING;P_var_value:STRING)
-- PURPOSE: to Set Program variables that have a String Type
--
--
-- INPUT:  The Program Variable to set passed as a string
--
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(Var_Errors) THEN -- this should be set, but double check
  Var_Errors = 0
ENDIF

-- SET_VAR(l_entry, P_Prg_name, P_var_name, P_var_value,gm_status)

 SET_VAR(l_entry,P_Prg_name,P_var_name,P_var_value,gm_status)
   IF gm_status <> 0 THEN
     POST_ERR(38000, P_Prg_name +' ' + P_var_name+' FAILED', gm_status, 0) --
     WriteLog('['+P_Prg_name +']'+P_var_name + ' FAILED,Status ='+int2Str(gm_status), TRUE)
    Var_Errors = Var_Errors + 1
   ENDIF

END Set_S_PVar
-----------------------------------------------------------------------------
ROUTINE Comment_Reg --(P_Reg_Type:INTEGER;P_Reg_Num:Integer;P_Reg_Coment:STRING)
-- PURPOSE: to Set system variables that have a String Type
--
--
-- INPUT:  The system Variable to set passed as a string
--         the Real to set to
--
-- OUTPUT:
--            -
-- CALLED BY:
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(Reg_Errors) THEN -- this should be set, but double check
  Reg_Errors = 0
ENDIF

  SELECT (P_Reg_Type) OF --
    CASE (1):  -- Data Register
      Err_Prefix = 'R['
      SET_REG_CMT(P_Reg_Num,P_Reg_Coment,gm_status)
    CASE (2):  -- Position Register
      Err_Prefix = 'PR['
      SET_PREG_CMT(P_Reg_Num,P_Reg_Coment,gm_status)
    CASE (3):  -- String Register
      Err_Prefix = 'SR['
      SET_SREG_CMT(P_Reg_Num,P_Reg_Coment, gm_status)
    ELSE: --
      POST_ERR(38000, 'P_REG_TYPE '+Int2str(P_Reg_Num)+' in GMUTILITY INVALID', 0, 0) --
  ENDSELECT --

  IF gm_status <> 0 THEN
    writeLog('** '+Err_Prefix+int2str(P_Reg_Num)+'] Set to '+P_Reg_Coment+' FAILED Status ='+int2str(gm_status), TRUE)
    POST_ERR(38000,Err_Prefix+int2str(P_Reg_Num)+'] Set to '+P_Reg_Coment+' FAILED', gm_status, 0) --
    DELAY 1000
    Reg_Errors = Reg_Errors + 1
  ENDIF

  RETURN
END Comment_Reg
-----------------------------------------------------------------------------
ROUTINE Set_Reg_Val --(P_Reg_Num:Integer;P_Reg_Val:Integer)
-- PURPOSE: Sets data register integer
--
--
-- INPUT:
--
--
-- OUTPUT:
--            -
-- CALLED BY:
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(Reg_Errors) THEN -- this should be set, but double check
  Reg_Errors = 0
ENDIF

Err_Prefix = 'R['
SET_INT_REG(P_Reg_Num, P_Reg_Val, gm_status)

  IF gm_status <> 0 THEN
    writeLog('** '+Err_Prefix+int2str(P_Reg_Num)+'] Set to '+int2str(P_Reg_Val)+' FAILED Status ='+int2str(gm_status), TRUE)
    POST_ERR(38000,Err_Prefix+int2str(P_Reg_Num)+'] Set to '+int2str(P_Reg_Val)+' FAILED', gm_status, 0) --
    DELAY 1000
    Reg_Errors = Reg_Errors + 1
  ENDIF

  RETURN

END Set_Reg_Val
------------------------------------------------------------------------------
ROUTINE copyFile--(p_src: STRING; p_dst: STRING)
------------------------------------------------------------------------------
BEGIN

IF UNINIT(Copy_Errors) THEN
  Copy_Errors = 0
ENDIF

  COPY_FILE(p_src, p_dst, TRUE, FALSE, gm_status)
  IF (gm_status <> 0) THEN
    writeLog('** FAILED to copy ' + P_src + ' to ' + P_dst+' Status='+int2str(gm_status), TRUE)
    POST_ERR(38000, 'Failed copy ' + p_src+ ' to ' + P_dst, gm_status, 0) --
    Copy_Errors = Copy_Errors + 1
  ENDIF

END copyFile
------------------------------------------------------------------------------
ROUTINE Copy_O_File--(P_src: STRING; P_dst: STRING; P_wrt: BOOLEAN)
------------------------------------------------------------------------------
VAR
  l_status   : INTEGER

BEGIN


IF UNINIT(Copy_Errors) THEN
  Copy_Errors = 0
ENDIF

  COPY_FILE(P_src, P_dst, P_wrt, FALSE, gm_status)
    IF (gm_status = 0) THEN
      writeLog('  Copied ' + P_src + ' overwriting ' + P_dst, FALSE)
    ELSE
      POST_ERR(38000, 'Copy OVER failed ' + P_src+' to ' + P_dst, gm_status, 0) --
      IF (gm_status = 2014)THEN
        writeLog('** Copy from ' + P_src + ' OVER to ' + P_dst+' failed, File NOT Found', TRUE)
      ELSE
        writeLog('** Copy from ' + P_src + ' OVER to ' + P_dst+' failed, Status='+int2str(gm_status), TRUE)
      ENDIF
      Copy_Errors = Copy_Errors + 1
    ENDIF

END Copy_O_File
------------------------------------------------------------------------------
ROUTINE SPRUNCfile--(p_src: STRING; p_dst: STRING)
------------------------------------------------------------------------------
BEGIN

IF UNINIT(Copy_Errors) THEN
  Copy_Errors = 0
ENDIF

  SPRUNCMD('COPY ' + p_src + ' ' + p_dst, gm_status)
    IF (gm_status <> 0) THEN
      writeLog('** FAILED to copy ' + p_src + ' to ' + p_dst+' Status='+int2str(gm_status), TRUE)
      POST_ERR(38000, 'Failed to copy ' + p_src+ ' to ' +p_dst, gm_status, 0)
      Copy_Errors = Copy_Errors + 1
    ENDIF

END SPRUNCfile
-----------------------------------------------------------------------------
ROUTINE Ch_err_sv
-- PURPOSE:  to set the variables for the Error severity for the devices default
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------

BEGIN

  Current_Ver = Version -- Set the version for reference

  IF UNINIT(Cell_Err_Sv) OR (Reset_Cell) THEN
    Cell_Err_Sv = 1
  ENDIF
  IF UNINIT(Armor_Err_Sv) OR (Reset_Cell) THEN
    Armor_Err_Sv = 1
  ENDIF
  IF UNINIT(WTC_Err_Sv) OR (Reset_Cell)THEN
    WTC_Err_Sv = 1
  ENDIF
  IF UNINIT(EtStd_Err_Sv) OR (Reset_Cell) THEN
    EtStd_Err_Sv = 1
  ENDIF
  IF UNINIT(SqrD_Err_Sv) OR (Reset_Cell) THEN
    SqrD_Err_Sv = 1
  ENDIF
  IF UNINIT(RqSvr_Err_Sv) OR (Reset_Cell) THEN
    RqSvr_Err_Sv = 1
  ENDIF
  IF UNINIT(Tool_Err_Sv) OR (Reset_Cell) THEN
    Tool_Err_Sv = 0
  ENDIF
  IF UNINIT(Sca_Err_Sv) OR (Reset_Cell)THEN
    Sca_Err_Sv = 1
  ENDIF
  IF UNINIT(Weber_Err_Sv) OR (Reset_Cell) THEN
    Weber_Err_Sv = 1
  ENDIF
  IF UNINIT(HenRb_Err_Sv) OR (Reset_Cell) THEN
    HenRb_Err_Sv = 1
  ENDIF
  IF UNINIT(Nelsn_Err_Sv) OR (Reset_Cell) THEN
    Nelsn_Err_Sv = 1
  ENDIF
  IF UNINIT(LsrLn_Err_Sv) OR (Reset_Cell) THEN
    LsrLn_Err_Sv = 1
  ENDIF
  IF UNINIT(Trumf_Err_Sv) OR (Reset_Cell) THEN
    Trumf_Err_Sv = 1
  ENDIF
  IF UNINIT(Bwirf_Err_Sv) OR (Reset_Cell) THEN
    Bwirf_Err_Sv = 0
  ENDIF
  IF UNINIT(LProc_Err_Sv) OR (Reset_Cell) THEN
    LProc_Err_Sv = 1
  ENDIF
  IF UNINIT(ScSon_Err_Sv) OR (Reset_Cell) THEN
    ScSon_Err_Sv = 0
  ENDIF
  IF UNINIT(IpfoR_Err_Sv) OR (Reset_Cell) THEN
    IpfoR_Err_Sv = 1
  ENDIF
  IF UNINIT(SBI_Err_Sv) OR (Reset_Cell) THEN
    SBI_Err_Sv = 1
  ENDIF
  IF UNINIT(PCor_Err_Sv) OR (Reset_Cell) THEN
    PCor_Err_Sv = 0
  ENDIF
  IF UNINIT(PVal_Err_Sv) OR (Reset_Cell) THEN
    PVal_Err_Sv = 0
  ENDIF
  IF UNINIT(Ream_Err_Sv) OR (Reset_Cell) THEN
    Ream_Err_Sv = 0
  ENDIF

END Ch_err_sv

-----------------------------------------------------------------------------
ROUTINE Cnfg_Grp--(P_Grp_Type:INTEGER;P_Grp_Num:INTEGER;P_Comm_Type:INTEGER;P_Slot_Num:INTEGER;P_Strt_Num:INTEGER;P_Num_Points:INTEGER):BOOLEAN
-- PURPOSE: To config a group in and output and check for errors
--
--
-- INPUT:       Group Type,
--            - Group Number
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
BEGIN
IF UNINIT(IO_Errors) THEN
  IO_Errors = 0
ENDIF
  SELECT (P_Grp_Type) OF --
    CASE (IO_DIN):  -- Digital Input to be configured
        Err_Prefix = 'DI['
        SET_PORT_ASG(P_Grp_Type,P_Grp_Num,P_Comm_Type,P_Slot_Num,IO_DIN,P_Strt_Num,P_Num_Points,gm_status)
    CASE (IO_DOUT):  -- Digital Output to be configured
        Err_Prefix = 'DO['
        SET_PORT_ASG(P_Grp_Type,P_Grp_Num,P_Comm_Type,P_Slot_Num,IO_DOUT,P_Strt_Num,P_Num_Points,gm_status)
    CASE (IO_GPIN):  -- Group Input to be configured
        Err_Prefix = 'GI['
        SET_PORT_ASG(P_Grp_Type,P_Grp_Num,P_Comm_Type,P_Slot_Num,IO_DIN,P_Strt_Num,P_Num_Points,gm_status)
    CASE (IO_GPOUT):  -- Group Output to be configured
        Err_Prefix = 'GO['
        SET_PORT_ASG(P_Grp_Type,P_Grp_Num,P_Comm_Type,P_Slot_Num,IO_DOUT,P_Strt_Num,P_Num_Points,gm_status)
    CASE (IO_UOPIN):  -- User Input to be configured
        Err_Prefix = 'UI['
        SET_PORT_ASG(P_Grp_Type,P_Grp_Num,P_Comm_Type,P_Slot_Num,IO_DIN,P_Strt_Num,P_Num_Points,gm_status)
    CASE (IO_UOPOUT):  -- User Output to be configured
        Err_Prefix = 'UO['
        SET_PORT_ASG(P_Grp_Type,P_Grp_Num,P_Comm_Type,P_Slot_Num,IO_DOUT,P_Strt_Num,P_Num_Points,gm_status)
    ELSE: --  Unknown post and return
      POST_ERR(38000, 'P_Grp_Type '+Int2str(P_Grp_Type)+' in GMUTILITY INVALID', 0, 0) --
  ENDSELECT --

  IF (gm_status <> 0) AND (gm_Status <> 13149) THEN --PRIO-149 Invalid Assignment Recorded
    POST_ERR(38000,Err_Prefix + int2str(P_Grp_Num)+'] Rack' +int2str(P_Comm_Type) &
    +' Slot'+ Int2str(P_Slot_Num)+' Start'+ int2str(P_Strt_Num)+'#'+int2str(P_Num_Points)+' FAILED', gm_status, 0) --
    DELAY 1000
    IO_Errors = IO_Errors + 1
    RETURN(FALSE)
  ELSE
    RETURN(TRUE)
  ENDIF

END Cnfg_Grp
-----------------------------------------------------------------------------
ROUTINE chk_loaded--(P_Prog_name:String):Boolean
-- PURPOSE: Verify file is loaded before using
--
--
-- INPUT:   Program name to check
--            -
-- OUTPUT:  if program actually loaded, VR only does'nt help
--            -
-- CALLED BY: CALLTHISPROG routine and others
-----------------------------------------------------------------------------
BEGIN

 IF UNINIT(Enable_Log) THEN
   Enable_Log = FALSE --- someone didnt set it??
 ENDIF

LOAD_STATUS(P_Prog_name, loaded, initialized) -- check if loaded

IF (Loaded = FALSE) THEN
  writeLog('Program '+ P_Prog_name+' is Not Loaded for Use', TRUE)
ENDIF

  RETURN(Loaded) -- return if file can be used

END chk_loaded
-----------------------------------------------------------------------------
ROUTINE Unlck_Prog--(P_FileName:String)
-- PURPOSE: to unlock TP Files
--
--
-- INPUT:   File name to unlock
-----------------------------------------------------------------------------

BEGIN

  --make the TP file Name from String, , For length minus 3 should strip .TP off it
   FileNameOnly = SUB_STR(P_FileName,1,(STR_LEN(P_FileName)-3))
  -- RK 6-30-16 added this so if a file is already loaded, AND has write protect on will still load over
  SET_ATTR_PRG(FileNameOnly, AT_PROTECT, 1, FileNameOnly, gm_status)-- set prog att if there, to unprotected
   IF gm_status <> 0 THEN
     POST_ERR(38000, 'Failed to Unlock '+FileNameOnly, gm_status, 0) --
   ENDIF

END Unlck_Prog
-----------------------------------------------------------------------------
ROUTINE Load_File--(P_Frm_Device:String;P_FileName:String;P_overWrite:Integer)
-- PURPOSE: to load a tp File, and report if error occured
--
--
-- INPUT:       P_Frm_Device -- is the device to load file from
--              P_FileName   -- is the TP file to load form the From Device
--              P_overWrite  -- if existing file is there, overwrite it
--
--            -
-- OUTPUT:      None
--            -
-- CALLED BY: All shop program loading routines that want status to be known
--
--
-----------------------------------------------------------------------------
BEGIN

IF UNINIT(load_errors) THEN
  load_errors = 0
ENDIF

    LOAD_STATUS(P_FileName, loaded, initialized) -- check if loaded
    IF loaded THEN -- if file is loaded need to unprotect
      Unlck_Prog(p_FileName)
    ENDIF

    LOAD(P_Frm_device+P_FileName,P_OverWrite,gm_status)

    IF gm_status <> 0 THEN --2036 = File-036 File already Exist, user didnt want over written
      -- check if user wanted to overwrite File-036          LANG-014 program already exists
      IF (P_OverWrite = 0) AND ((gm_status = 2036) OR (gm_status = 21014))THEN
        WriteLog('Load OVER of '+P_FileName+' From '+P_Frm_Device+' not done',FALSE)
      ELSE           --MEMO-006 Protection Error occured
        IF (gm_status <> 7006) THEN
          POST_ERR(38000, 'Load of '+P_Frm_Device+' '+P_FileName +' FAILED', gm_status, 0) --
          writeLog('** Load of '+P_Frm_Device+' '+P_FileName +' FAILED, Status='+int2str(gm_status), TRUE)
          load_errors = load_errors + 1
        --ELSE
         -- WriteLog('Load protection on '+P_FileName+'. Load From '+P_Frm_Device+' not done, Status='+int2str(gm_status),FALSE)
        ENDIF
      ENDIF
    ENDIF

END Load_File

-----------------------------------------------------------------------------
ROUTINE Clear_Prog--(P_FileName:String)
-- PURPOSE: to clear a program that maybe already existing
--
-- INPUT:   DO NOT PASS AN EXTENSION BECAUSE LOAD_STATUS FAILS AND WILL NOT CLEAR PROGRAM FOR .TP
--
--              P_FileName   -- is the file to clear from the Device
--                   no ext :KAREL or Teach Pendant program and variables
--                      .TP :Teach Pendant program
--                      .PC :KAREL program
--                      .VR :KAREL variables
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
-----------------------------------------------------------------------------
BEGIN

 IF UNINIT(Clear_Errors) THEN
   Clear_Errors = 0
 ENDIF

-- RRK added below and removed using CHK_LOADED routine because error posted
--     when never loaded

  LOAD_STATUS(p_fileName, loaded, initialized) -- check if loaded
  IF (Loaded = FALSE) THEN -- no need to clear because it doesn exist
    RETURN
  ENDIF

  -- RK 6-30-16 added this so if a file is loaded, AND has write protect on will still clear
  SET_ATTR_PRG(P_FileName, AT_PROTECT, 1, '', gm_status)-- set prog att if there, to unprotected

    CLEAR(P_FileName,gm_status) -- clear the passed program name
                       -- File-014 File Not Found  --Memo-073 Prog not Exist  VARS-011 Na Data Define for Program
    IF (gm_status <> 0) AND (gm_status <> 2014) AND (gm_status<>7073) AND (gm_status<>16011) THEN -- Not a Problem
      POST_ERR(38000, 'Clearing of '+P_FileName +' FAILED', gm_status, 0) --
      clear_errors = clear_errors + 1
      writeLog('Clearing of '+ P_FileName+' program was not completed!', TRUE)
    ELSE
      IF Enable_Log THEN
        writeLog('Cleared '+ P_FileName+' program', FALSE)
      ENDIF
    ENDIF

END Clear_Prog
-----------------------------------------------------------------------------
ROUTINE CallThisProg--(P_Prog_Name:STRING):BOOLEAN
-- PURPOSE:  to start program, but check if they are loaded first
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
VAR

prog_index :INTEGER

BEGIN

IF chk_loaded(P_Prog_Name) THEN -- Check if loaded before running
  CALL_PROG(P_Prog_Name,prog_index)-- Call Program to run
  RETURN(TRUE)
ELSE
  RETURN(FALSE)
ENDIF

END CallThisProg
-----------------------------------------------------------------------------
ROUTINE Unlck_Macro--(p_stridx, p_endidx : INTEGER)
-- PURPOSE: to unlock the macro tables sent. this allows the wizard to rerun
--          and not blowup.
--
--
-- INPUT:  Start number to update, End number to update.
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
VAR
  x : INTEGER
  x_str : String[4]
BEGIN

  FOR x = p_stridx TO p_endidx DO
     x_str = int2str(x)-- convert to string
    Set_I_sVar('$macrotable[' + x_str + '].$sys_lev_msk',0)
  ENDFOR

END Unlck_Macro
-----------------------------------------------------------------------------
ROUTINE clr_macro_tb--(p_stridx, p_endidx : INTEGER)
-- This routine clear the macro table from start index to end index.
-----------------------------------------------------------------------------
VAR
  x : INTEGER
  x_str : String[4]
BEGIN

  FOR x = p_stridx TO p_endidx DO

     x_str = int2str(x)-- convert to string

    Set_I_sVar('$macrotable[' + x_str + '].$sys_lev_msk',0)
    Set_S_sVar('$macrotable[' + x_str + '].$macro_name','')
    Set_S_sVar('$macrotable[' + x_str + '].$prog_name','')
    Set_I_sVar('$macrotable[' + x_str + '].$ept_index',-1)
    Set_I_sVar('$macrotable[' + x_str + '].$open_id',0)
    Set_I_sVar('$macrotable[' + x_str + '].$assign_type',1)
    Set_I_sVar('$macrotable[' + x_str + '].$assign_id',0)
    Set_I_sVar('$macrotable[' + x_str + '].$mon_no',0)
    Set_I_sVar('$macrotable[' + x_str + '].$prev_subtyp',0)
    Set_I_sVar('$macrotable[' + x_str + '].$user_work',2)
    Set_I_sVar('$macrotable[' + x_str + '].$mcr_rtn',255)
  ENDFOR

END clr_macro_tb

--*********************************************************************************
ROUTINE Chk_Feature--(P_FeatureStr:STRING):BOOLEAN
--*********************************************************************************
VAR
  i       : INTEGER
Feature_Loc : BOOLEAN

BEGIN

Feature_Loc = FALSE -- Reset to return zero unless found

  FOR i = 1 TO ARRAY_LEN($FEATURE.$MOD) DO  -- try and find if the feature is loaded
    IF NOT UNINIT($FEATURE.$MOD[i]) THEN
      IF $FEATURE.$MOD[i] = P_FeatureStr THEN
        RETURN(TRUE)-- return it was found
      ENDIF
    ENDIF
  ENDFOR

RETURN(Feature_Loc)-- Return the feature Location

END Chk_Feature
-----------------------------------------------------------------------------
ROUTINE SetLd_Macro--(p_Mac_number:INTEGER,p_MacName:STRING,p_ProgName:STRING,p_Custname:STRING&
                   -- p_assig_type:INTEGER,p_assig_id:INTEGER,p_protect:BOOLEAN)
-- PURPOSE: to pass a program name, and macro number. the program will
--          rest all the protection, then load the file, then reenable the
--          protection.
--
--
-- INPUT: P_Mac_Number
--        P_MacName
--        P_ProgName
--        P_cust_name
--        P_Assign_type values are:1=nothing, 2= UK, 3=SU,4=MF,5=SP,6=DI,7=RI
--        P_Assign_id
--        Protect it :Boolean
--
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
VAR
Mac_Num_Str : STRING[4] -- used for the Macro number converted to string
BEGIN

  Mac_Num_Str = int2str(p_Mac_Number)-- convert the number to be used below

-- clear the write protect for the macro
  Set_I_sVar('$MACROTABLE['+Mac_Num_Str+'].$SYS_LEV_MSK',0)
  SET_ATTR_PRG(p_ProgName, AT_PROTECT, 1, p_ProgName, gm_status)-- set prog att if there, to unprotected
  Clear_Prog(p_ProgName) -- clear the program that maybe existing?
  Load_File('FRS:',p_CustName+'.TP',1) -- load custom name should be actual name when laoded. this is dumb!

  Set_S_sVar('$macrotable[' + Mac_Num_Str + '].$macro_name',p_MacName)
  Set_S_sVar('$macrotable[' + Mac_Num_Str + '].$prog_name',p_ProgName)
  Set_I_sVar('$macrotable[' + Mac_Num_Str + '].$assign_type',p_assig_type)
  Set_I_sVar('$macrotable[' + Mac_Num_Str + '].$assign_id',p_assig_id)

-- see if need to protect file and macro table
    IF p_protect THEN
      SET_ATTR_PRG(P_ProgName, AT_PROTECT, 2, P_ProgName, gm_status)
      Set_I_sVar('$macrotable[' + Mac_Num_Str + '].$sys_lev_msk',3)
    ENDIF

END SetLd_Macro
-----------------------------------------------------------------------------
ROUTINE Setup_Macro--(p_Mac_number:INTEGER,p_MacName:STRING,p_ProgName:STRING,&
--                    p_assig_type:INTEGER,p_assig_id:INTEGER,p_protect:BOOLEAN)
--
-- PURPOSE: to pass a program name, and macro number. the routine will
--          verify file is loaded, reset all the protection, setup macro then
--          enable the protection if desired.
--
--
-- INPUT: P_Mac_Number
--        P_MacName
--        P_ProgName
--        P_Assign_type values are: 1=nothing,2= UK, 3=SU,4=MF,5=SP,6=DI,7=RI
--        P_Assign_id
--        Protect it :Boolean
--
-----------------------------------------------------------------------------
VAR
Mac_Num_Str : STRING[4] -- used for the Macro number converted to string
BEGIN

  IF NOT (chk_loaded(p_ProgName)) THEN
    Load_File('FRS:',p_ProgName +'.TP',1)
  ENDIF

    Mac_Num_Str = int2str(p_Mac_Number)-- convert the number to be used below
  -- Go and verify the Program exist before setting macro
--  IF chk_loaded(p_ProgName) THEN
    -- set protect off in case was locked
    Set_I_sVar('$macrotable[' + Mac_Num_Str + '].$sys_lev_msk',0)

    Set_S_sVar('$macrotable[' + Mac_Num_Str + '].$macro_name',p_MacName)
    Set_S_sVar('$macrotable[' + Mac_Num_Str + '].$prog_name',p_ProgName)
    Set_I_sVar('$macrotable[' + Mac_Num_Str + '].$assign_type',p_assig_type)
    Set_I_sVar('$macrotable[' + Mac_Num_Str + '].$assign_id',p_assig_id)

    -- see if need to protect file and macro table
    IF p_protect THEN
      SET_ATTR_PRG(P_ProgName, AT_PROTECT, 2, P_ProgName, gm_status)
      Set_I_sVar('$macrotable[' + Mac_Num_Str + '].$sys_lev_msk',3)
    ENDIF
--  ELSE -- program not loaded, log for user to know
--    WriteLog('Macro #' + Mac_Num_Str +' NOT set,'+ P_ProgName+ ' not Loaded',TRUE)
--  ENDIF

END Setup_Macro
-----------------------------------------------------------------------------
ROUTINE ChkIfBckedup --(P_prog_name:STRING):BOOLEAN
-- PURPOSE: to search through the $file_appbck to find if program is already
--          in back structure, if not, then find the first available.
--
-- INPUT:  file name to search for
--            -
-- OUTPUT: if the file exists, return TRUE, if FALSE,
--            -
-- CALLED BY: GMCELLVR or anywhere where user wants to add file app backup
--
--
-----------------------------------------------------------------------------
VAR

entry,
x  : INTEGER -- Used for FOR loop
curbckupname : STRING[32]

BEGIN

   FOR x = 1 to ARRAY_LEN($file_appbck) DO
     curbckupname = '' -- clear name
     GET_VAR(entry, '*SYSTEM*' , '$file_appbck[' +int2str(x)+'].$prog_name', curbckupname, gm_status)
       IF gm_status <> 0 THEN
         IF gm_status <> 12311 THEN  -- uninit comes back if not setup
           POST_ERR(38000, 'Get [*SYSTEM*].$file_appbck[' +int2str(x)+'].$prog_name FAILED', gm_status, 0) --
           writeLog('** Get [*SYSTEM*].$file_appbck[' +int2str(x)+'].$prog_name FAILED, Status='+int2str(gm_status), TRUE)
         ENDIF
       ELSE
         IF (curbckupname = P_prog_name) THEN
           writeLog('$file_appbck['+int2str(x)+'] has '+ P_prog_name +' Already setup' , FALSE)
           RETURN(TRUE)
         ENDIF
       ENDIF
   ENDFOR

   RETURN(FALSE)

END ChkIfBckedup
-----------------------------------------------------------------------------
ROUTINE SetBackUpLoc --:STRING
-- PURPOSE: to search through the $file_appbck to find open location for it
--          in back structure, if not, then return False.
--
-- INPUT:  NONE
--            -
-- OUTPUT: if the Setup was successful, return TRUE, if not FALSE
--            -
-- CALLED BY:
--
-----------------------------------------------------------------------------
VAR
entry,
x  : INTEGER -- Used for FOR loop
cur_loc  : INTEGER -- Used for passing the number found
curbckuploc : STRING[32]
curbckupname : STRING[32]

BEGIN

  curbckuploc = 'NONE'

   FOR x = 1 to ARRAY_LEN($file_appbck) DO
     GET_VAR(entry, '*SYSTEM*' , '$file_appbck[' +int2str(x)+'].$prog_name', curbckupname, gm_status)
       IF gm_status <> 0 THEN
         IF (gm_status = 12311) THEN  -- uninit comes back if not setup
           writeLog('$file_appbck['+int2str(x)+'] is open for setup' , FALSE)
           curbckuploc = '$file_appbck['+int2str(x)+']'
           RETURN(curbckuploc)-- return current variable because it can be used
         ELSE
           POST_ERR(38000, 'Get [*SYSTEM*].$file_appbck[' +int2str(x)+'].$prog_name FAILED', gm_status, 0) --
           writeLog('** Get [*SYSTEM*].$file_appbck[' +int2str(x)+'].$prog_name FAILED, Status='+int2str(gm_status), TRUE)
         ENDIF
       ELSE -- check if curbackupname is open
         IF (curbckupname = '') THEN
           writeLog('$file_appbck['+int2str(x)+'] is open for setup' , FALSE)
           curbckuploc = '$file_appbck['+int2str(x)+']'
           RETURN(curbckuploc)
         ENDIF
       ENDIF
   ENDFOR

   RETURN(curbckuploc)-- returning NONE, no room availalbe

END SetBackUpLoc
-----------------------------------------------------------------------------
ROUTINE do_kcl_Cmnd--(p_instrction:STRING)
-- PURPOSE: to execute the kcl cpmmands from within programs
--
--
-- INPUT:   a Valid KCL command
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
BEGIN

    KCL(p_instrction,gm_status)
      IF (gm_status <>0) THEN
        WriteLog('KCL failed on'+p_instrction,TRUE)
      ELSE
        WriteLog('KCL set '+p_instrction,TRUE)
      ENDIF

END do_kcl_Cmnd
-----------------------------------------------------------------------------
ROUTINE ChkSimulated --(P_Port_Type:INTEGER;P_IO_Number:INTEGER):BOOLEAN
-- PURPOSE: to check if a I/O point is simulated
--
--
-- INPUT:    P_IO_Type:INTEGER - The I/O type as define in KLIOTYPES
--           P_IO_Number:INTEGER - The I/O number to check
-- OUTPUT:   Sim_Active :Boolean
--
-----------------------------------------------------------------------------
VAR
 Sim_Active :BOOLEAN
 tempString :STRING[6]-- used to show type of I/O passed

BEGIN

Sim_Active = FALSE

   GET_PORT_SIM(P_Port_Type, P_IO_Number, Sim_Active, gm_status)
     IF gm_status <> 0 THEN -- if an error
       tempString = '??['
       SELECT (P_Port_Type) OF -- set the text to display
         CASE (io_din ):  --       =  1   -- Digital input
         tempString = 'DI['
         CASE (io_dout):  --       =  2   -- Digital output
         tempString = 'DO['
         CASE (io_anin ):  --      =  3   -- Analog input
         tempString = 'AI['
         CASE (io_anout):  --      =  4   -- Analog output
         tempString = 'AI['
         CASE (io_rdi):  --        =  8   -- Robot digital input
         tempString = 'RI['
         CASE (io_rdo):  --        =  9   -- Robot digital output
         tempString = 'RO['
         CASE (io_wdi):  --        = 16   -- weld inputs
         tempString = 'WI['
         CASE (io_wdo):  --        = 17   -- weld outputs
         tempString = 'WO['
         CASE (io_gpin):  --       = 18   -- Grouped inputs
         tempString = 'GI['
         CASE (io_gpout):  --      = 19   -- Grouped outputs
         tempString = 'GO['
         CASE (io_ldin):  --       = 22   -- laser DIN
         tempString = 'LI['
         CASE (io_ldout):  --      = 23   -- laser DOUT
         tempString = 'LO['
         CASE (io_lain):  --       = 24   -- laser AIN
         tempString = 'LAI['
         CASE (io_laout):  --      = 25   -- laser AOUT
         tempString = 'LAO['
         ELSE: --
         tempString = (int2str(P_IO_Number)) +'['
       ENDSELECT --

       POST_ERR(38000, 'Chk Sim for '+tempString+(int2str(P_IO_Number))+'] FAILED', gm_status, 0) --
     ENDIF

  RETURN(Sim_Active)

END ChkSimulated
-----------------------------------------------------------------------------
ROUTINE GetSysVar --(p_Svar_name:STRING;P_Svar_Type:INTEGER):BOOLEAN
-- PURPOSE: to get system variable, and if return TRUE then the global answer can be used
--
--
-- INPUT:    system variable the routine is to get the value for
--           the type of variable the system var is declared as
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------

BEGIN

  SVrRtrndStr = ''
  SVrRtrndInt = 0
  SVrRtrndRel = 0.0
  SVrGetSuces = FALSE

SELECT (P_Svar_Type) OF --
    CASE (1):  -- results is expect to be a string
      GET_VAR(l_entry, '*SYSTEM*' , P_Svar_Name, SVrRtrndStr, gm_status)
        IF gm_status <> 0 THEN
          POST_ERR(38000, '[*SYSTEM*]'+P_Svar_name+' FAILED', gm_status, 0) --
        ELSE
          SVrGetSuces=TRUE
        ENDIF

    CASE (2):  -- results is expect to be a integer
      GET_VAR(l_entry, '*SYSTEM*' , P_Svar_Name, SVrRtrndInt, gm_status)
        IF gm_status <> 0 THEN
          POST_ERR(38000, '[*SYSTEM*]'+P_Svar_name+' FAILED', gm_status, 0) --
        ELSE
          SVrGetSuces=TRUE
        ENDIF

    CASE (3): -- Results expected to be Real
      GET_VAR(l_entry, '*SYSTEM*' , P_Svar_Name, SVrRtrndRel, gm_status)
        IF gm_status <> 0 THEN
          POST_ERR(38000, '[*SYSTEM*]'+P_Svar_name+' FAILED', gm_status, 0) --
        ELSE
          SVrGetSuces=TRUE
        ENDIF
    ELSE: --
      POST_ERR(38000,P_Svar_Name+'TYPE ' +int2str(P_Svar_Type)+' is UNKNOWN', 0, 0) --
  ENDSELECT --

  RETURN(SVrGetSuces)

END GetSysVar

--************************************************************************
--                 Main Body of Program
--************************************************************************
BEGIN
END gmutility
