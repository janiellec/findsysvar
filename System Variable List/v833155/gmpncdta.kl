-- -----------------------------------------------------------------------
--
--   MODULE: GM Pounce Data.kl
--   TITLE:  Pounce Data setup Menu
--
--   WRITTEN BY:     Randy Kosaski
--   REVISION DATE:  03/8/2016
--
--   LANGUAGE:       KAREL 8.33
--   CONTROL GROUP:  General Motor Global Center
--
--   ORDER NUMBER:   GM Global Center
--   PROJECT NAME:
--
--
--   COPYRIGHT:     Fanuc Robotics America, Inc. retains rights in any
--                  and all Software contained in the material attached
--                  hereto and said Software may not be copied
--                  reproduced without the written permission Fanuc
--                  Robotics America, Inc..
--
--                  All Software, (C) Copyright Fanuc Robotics
--                  America, Inc., 2016
--
--         DESCRIPTION: This program controls the screens for setting up
--                      the fixture grouping.  There are two screens
--                      one for the insert data, one for inspection
--
--         HISTORY OF CHANGES:
--
--         REVISION   DATE       BY               COMMENTS
--         --------   ---------  -------------  --------------------
--
--------------------------------------------------------------------------
PROGRAM GMPNCDTA

%SYSTEM
--%INVISIBLE
                --*****************************************************************
%NOABORT = ERROR + COMMAND-- *** REMOVE COMMENT FOR PRODUCTION NEED TO IGNORE ABORT
                --*****************************************************************
%NOPAUSE = ERROR + COMMAND + TPENABLE
%NOBUSYLAMP
%NOLOCKGROUP
%PRIORITY=100
%NOPAUSESHFT
%ALPHABETIZE
%COMMENT = 'GM Pounce Data'
%INCLUDE klevksp  -- TPMM KAREL softpart loader. and the device_stat and tpdc_tp_c
%INCLUDE klevkmsk
%INCLUDE kliosop
%INCLUDE KLIOTYPS -- used for the GET_PORT_CMT builting for the port types

 CONST

  dly_time    = 4500    --time to keep messages up for
  dict_name   = 'MPNC'  --dictionary name for pounce data
  max_col_wid = 16      --max column width in schedule
  update_only = 4
  ver = '04/07/16'      -- REV. A
  Contr_State = 1 -- read from $SYS_CONFIG.$STARTMD 1 = Controlled Start
  Cold_State  = 2 -- read from $SYS_CONFIG.$STARTMD 2 = Cold Start
  Max_pounces = 10 -- Currently Multiple pounces only supports 10 including HOME

TYPE

  PATH_INFO  = STRUCTURE        --Position Regisiter Path
    Use_Path2_PR      : BOOLEAN --To PR[10] needs Path
    PrgName4Path      : STRING[16]-- the path program name to check to see if loaded in memory
  ENDSTRUCTURE

TYPE

  PR_PATH  = STRUCTURE        --Position Regisiter Path
    Path_to_PR      : ARRAY[Max_pounces] OF PATH_INFO --To PR[10] needs Path
    LastModified    : STRING[20] -- time and date when Soething was edited in Stucture
  ENDSTRUCTURE


VAR
 -- structure data must be in this program for the ACT_FORM or UNKNOWN variable error occurs
 -- i.e. if FROM progname is used 5/5/03
unlocked,
loaded, -- used for the return from builtin PROG_STATUS if TRUE program is loaded
initialized,-- used for the return from builtin PROG_STATUS if TRUE variable file is loaded
Detail_done: BOOLEAN -- used to see if the detail is available

ConStartStat IN CMOS : INTEGER -- used for the controller state 1= Control,2= Cold
                               -- $SYS_CONFIG.$STARTMD
i,
entry,
int_value,
term_mask,
term_char,
open_id    : INTEGER -- Used for routine in getting teach pendant positions
karel_name IN CMOS : STRING[16] -- Used for name of the fixture group variable will be read from
status     IN CMOS :INTEGER -- Status of built-in procedure call nice to see if power cycled because of issue can see cmos

form_number IN CMOS : INTEGER -- Used for which form to display
value_array: ARRAY [60] OF STRING [120]
inact_array: ARRAY [60] OF BOOLEAN
change_array: ARRAY[60] OF BOOLEAN
def_item: INTEGER
Prog_name  : STRING[26] -- Used for
Det_num_name  : STRING[60] -- Used for

StrtFrmWizrd,               -- The menu was started from wizard.
det_done IN CMOS : BOOLEAN -- Used for

PR_Num  IN CMOS :ARRAY[Max_pounces] OF PR_Path -- array of pounce path data

cur_from_Pnc IN CMOS : INTEGER -- used for the Current From pounce to display

all_done:          BOOLEAN             --user wants to exit laser schedules
prmp_file:         FILE                --prompt window on tp
do_detail:         BOOLEAN             --go to detail page on next loop
version_id    IN CMOS : STRING [15]

-- Variables from other programs
ResetPR_Data IN CMOS FROM CKPRPATH : BOOLEAN -- Used for if the user wants to reset the names or use PR variables

Cur_pr,des_pr,  -- used in FOR loops
gm_status  FROM CKPRPATH: INTEGER -- Used for builtins status returned

Cur_Frm_Str  : STRING[3] -- Used for the current Set of Variables being Displayed

UsePRPath,  -- If the Current Path to Path is enabled by user
MustUsePath IN CMOS FROM CKPRPATH: BOOLEAN -- Used for if a shop requires path to path to be created and used



%INCLUDE KLEVCCDF  -- provides character definition
%INCLUDE FXMPNCEG  -- dictionary constant file for Multiple Pounce

%INCLUDE klrdutil
%INCLUDE klrdread

-----------------------------------------------------------
ROUTINE int_2_str(p_integer:INTEGER):STRING
-- Routine to convert integers to string variables
-----------------------------------------------------------
VAR
  l_string: STRING[4]
BEGIN
  l_string = ''
  CNV_INT_STR(p_integer, 0, 0, l_string)
  RETURN(SUB_STR(l_string, 2, STR_LEN(l_string)))
END int_2_str
------------------------------------------------------------------------------
-- ROUTINE Trim
-- Remove leading and trailing spaces
-------------------------------------------------------------------------------
ROUTINE Trim (strText : STRING) : STRING

VAR
  strChar      : STRING[1]
  strTemp      : STRING[128]
  intFront     : INTEGER
  intBack      : INTEGER
  intIndex     : INTEGER
  intLength    : INTEGER

BEGIN

  strChar = ''
  strTemp = ''

IF UNINIT(strText) THEN
  strText = 'UNINT'
  POST_ERR(38000, 'String Not Initialized??', 0, 0) --
ENDIF


  intLength = STR_LEN(strText)

  IF intLength = 0 THEN RETURN(strText) ; ENDIF

  intIndex = 1
  intFront = intIndex

  --find the front of the string
  strChar = SUB_STR(strText, intIndex, 1)
  WHILE strChar = ' ' DO
    intIndex = IntIndex + 1
    IF intIndex <= intLength THEN
      strChar = SUB_STR(strText, intIndex, 1)
      intFront = intIndex
    ELSE
      strChar = ''
    ENDIF

  ENDWHILE

  intIndex = STR_LEN(strText)
  intBack = intIndex

  --find the back of the string
  strChar = SUB_STR(strText, intIndex, 1)
  WHILE strChar = ' ' DO
    intIndex = IntIndex - 1
    IF intIndex >= 1 THEN
      strChar = SUB_STR(strText, intIndex, 1)
      intBack = intIndex
    ELSE
      strChar = ''
    ENDIF
  ENDWHILE

  -- using SUB_STR to extract the string between front and back doesn't work - so we do it the hard way
  FOR intIndex=intFront TO intBack DO
    strChar = SUB_STR(strText, intIndex, 1)
    strTemp = strTemp + strChar
  ENDFOR

  RETURN(strTemp)

END Trim
-------------------------------------------------------------------------------
-- ROUTINE Int2Str
-- Converts integer number to string.
-------------------------------------------------------------------------------
ROUTINE Int2Str (intVal : INTEGER) : STRING

VAR
  strOut : STRING[15]

BEGIN

  CNV_INT_STR(intVal, 15, 0, strOut)
  strOut = Trim(strOut)

  RETURN (strOut)

END Int2Str

-----------------------------------------------------------------------------
ROUTINE init_PthVars
-- PURPOSE:
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------
BEGIN
IF UNINIT(ResetPR_Data) THEN
  ResetPR_Data = FALSE
ENDIF
IF UNINIT(MustUsePath) THEN
  MustUsePath = FALSE
ENDIF

FOR cur_pr = 1 TO ARRAY_LEN(PR_Num) DO  -- Initialize all the variables
  -- create the program name for each program in case enabled
  FOR des_pr = 1 TO ARRAY_LEN(PR_NUM[cur_pr].Path_To_PR) DO
    IF (UNINIT(PR_NUM[cur_pr].Path_To_PR[des_pr].Use_Path2_PR)) OR ResetPR_Data THEN
      IF cur_pr = des_pr THEN
        PR_NUM[cur_pr].Path_To_PR[des_pr].Use_Path2_PR = FALSE -- disable path to ITSELF
      ELSE-- set to whatever default is
        PR_NUM[cur_pr].Path_To_PR[des_pr].Use_Path2_PR = MustUsePath -- set to default for all
      ENDIF

    ENDIF
  ENDFOR --

   FOR des_pr = 1 TO ARRAY_LEN(PR_NUM[cur_pr].Path_To_PR) DO
    IF UNINIT(PR_NUM[cur_pr].Path_To_PR[des_pr].PrgName4Path) THEN
      IF cur_pr = des_pr THEN
        PR_NUM[cur_pr].Path_To_PR[des_pr].PrgName4Path = 'None to Self'-- disable path to ITSELF by clearing name
      ELSE
        PR_NUM[cur_pr].Path_To_PR[des_pr].PrgName4Path = 'PATH_PR'+int2str(cur_pr)+'TOPR'+int2str(des_pr)
      ENDIF
    ENDIF
  ENDFOR --

ENDFOR --

ResetPR_Data = FALSE -- reset back to false to setting dont change next time

END init_PthVars
-----------------------------------------------------------------------------
ROUTINE init_all_var
-- PURPOSE: Initialize all variables
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------

BEGIN

IF UNINIT(karel_name) THEN -- Identify Which program variables are being used
  karel_name = 'GMPNCDTA'
ENDIF
IF UNINIT(int_value) THEN
  int_value = 1
ENDIF
IF UNINIT(initialized) THEN
  initialized = FALSE
ENDIF


 -- get the load status to ensure variable are avaialable
LOAD_STATUS(karel_name, loaded, initialized) -- check if loaded

IF loaded THEN
  --InitGMPTVars -- go make sure all vars are setup
ELSE --Not loaded
  IF (initialized = FALSE) THEN
    POST_ERR(38000,karel_name + ' Not Loaded in GMPNCDTA program', 0, 0) --
    -- need to abort this gracfully after imforming user
    do_detail = FALSE
    det_done = TRUE
    all_done = TRUE
  ENDIF
ENDIF

END init_all_var
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
ROUTINE setup_data
-- PURPOSE: to setup
--
--
-- INPUT:
--            -
-- OUTPUT:
--            -
-- CALLED BY:
--
--
-----------------------------------------------------------------------------

BEGIN

IF UNINIT(all_done) THEN
  all_done = FALSE
ENDIF

FOR i = 1 TO ARRAY_LEN(inact_array) DO
  inact_array[i] = FALSE
ENDFOR --

IF UNINIT(unlocked) THEN
  unlocked = TRUE
ENDIF


--unlocked = TRUE
-- set the value array to be the program variable from the current fixture group
REPEAT --
 FOR i = 1 TO ARRAY_LEN(inact_array) DO
    IF unlocked THEN -- if user know secret to unlock
      inact_array[i] = FALSE
    ELSE
      inact_array[i] = TRUE
    ENDIF
  ENDFOR --


IF UNINIT(cur_from_Pnc) THEN
  cur_from_Pnc = 1
ENDIF

IF UNINIT(karel_name) THEN -- Identify Which program variables are being used
  karel_name = 'GMPNCDTA'
ENDIF
Prog_name = '['+karel_name+']'  -- Program name and software confiq array
cur_Frm_Str = int2str(cur_from_Pnc)
--Value_array[1]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].LastModified' -- the time the wazard was ran by user

Value_array[1]=  Prog_name + 'cur_From_Pnc'   -- used to display the current PR # displaying
Value_array[2]=  Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[1].Use_Path2_PR'   -- If TO PR[1] needs path
Value_array[3]=  Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[1].PrgName4Path'   -- Program to PR[1] uses
Value_array[4]=  Prog_name + 'cur_From_Pnc'  -- used to display the current PR # displaying
Value_array[5]=  Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[2].Use_Path2_PR'   -- If TO PR[2] needs path
Value_array[6]=  Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[2].PrgName4Path'   -- Program to PR[2] uses
Value_array[7]=  Prog_name + 'cur_From_Pnc'   -- used to display the current PR # displaying
Value_array[8]=  Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[3].Use_Path2_PR'   -- If TO PR[3] needs path
Value_array[9]=  Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[3].PrgName4Path'   -- Program to PR[3] uses
Value_array[10]= Prog_name + 'cur_From_Pnc'   -- used to display the current PR # displaying
Value_array[11]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[4].Use_Path2_PR'   -- If TO PR[4] needs path
Value_array[12]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[4].PrgName4Path'   -- Program to PR[4] uses
Value_array[13]= Prog_name + 'cur_From_Pnc'  -- used to display the current PR # displaying
Value_array[14]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[5].Use_Path2_PR'   -- If TO PR[5] needs path
Value_array[15]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[5].PrgName4Path'   -- Program to PR[5] uses

Value_array[16]= Prog_name + 'cur_From_Pnc'   -- used to display the current PR # displaying
Value_array[17]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[6].Use_Path2_PR'   -- If TO PR[6] needs path
Value_array[18]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[6].PrgName4Path'   -- Program to PR[6] uses
Value_array[19]= Prog_name + 'cur_From_Pnc'   -- used to display the current PR # displaying
Value_array[20]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[7].Use_Path2_PR'   -- If TO PR[7] needs path
Value_array[21]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[7].PrgName4Path'   -- Program to PR[7] uses
Value_array[22]= Prog_name + 'cur_From_Pnc'   -- used to display the current PR # displaying
Value_array[23]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[8].Use_Path2_PR'   -- If TO PR[8] needs path
Value_array[24]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[8].PrgName4Path'   -- Program to PR[8] uses
Value_array[25]= Prog_name + 'cur_From_Pnc'   -- used to display the current PR # displaying
Value_array[26]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[9].Use_Path2_PR'   -- If TO PR[9] needs path
Value_array[27]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[9].PrgName4Path'   -- Program to PR[9] uses
Value_array[28]= Prog_name + 'cur_From_Pnc'   -- used to display the current PR # displaying
Value_array[29]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[10].Use_Path2_PR'   -- If TO PR[10] needs path
Value_array[30]= Prog_name +  'PR_Num['+Cur_Frm_Str+'].Path_to_PR[10].PrgName4Path'   -- Program to PR[10] uses

                                                       --term_mask
-- kc_f1_type to handle the TYPE key processing with custommenu[x].$option = 31 will have TYPE work No FORCE USER!
term_mask =  kc_item_chng  + kc_f1_type + kc_func_key-- kc_f1_type + kc_func_key  --kc_other
term_char = -1
  DISCTRL_FORM(dict_name, setup_MPNC, value_array, inact_array, change_array, term_mask, def_item, term_char, status)
    IF status<>0 THEN
      all_done = TRUE
      POST_ERR(38000, 'GMPNCDTA SETUP_DATA Display Failed', status, 2) --
    ENDIF

--WRITE TPERROR(CHR(cc_clear_win),'SOMETHING CHANGED')
 -- form has ended

  SELECT (term_char) OF -- select how the form was ended or which key Cell
    CASE(ky_new_menu):

    CASE(ky_f1): -- [TYPE] functioning

    CASE(ky_f2,ky_f2_s):
        IF cur_from_Pnc >1 THEN
          cur_from_Pnc = (cur_from_Pnc - 1)
        ELSE
          cur_from_Pnc = 10 -- make loop around to save time
        ENDIF
    CASE(ky_f3,ky_f3_s): -- Include SHIFT in Case user is teaching -- Selected EXEC.

        IF cur_from_Pnc <(ARRAY_LEN(PR_Num)) THEN
          cur_from_Pnc = (cur_from_Pnc + 1)
        ELSE
          cur_from_Pnc = 1 -- make loop around to save time
        ENDIF

    CASE(ky_f4,ky_f4_s):
    CASE(ky_undef):
    ELSE: --
  ENDSELECT   --det_term_chr OF


UNTIL ((term_char = ky_new_menu) OR (status <>0)) -- New Screen selected

END setup_data

--------------------------------------------------------------------------------
--------------------        MAIN BODY OF PROGRAM     ---------------------------
--------------------------------------------------------------------------------

BEGIN

 version_id = ver

init_all_var -- initailize all variables

init_PthVars -- Initialize the path variables

-- GO and get the controller state to determine if need to force User SCreen
-- in controlled State, need to force user, if in cold state and menu is a CUSTOM MENU
-- then dont need to, system will

GET_VAR(entry, '*SYSTEM*' , '$SYS_CONFIG.$STARTMD', ConStartStat, status)
   IF status <> 0 THEN
     POST_ERR(38000, '[*SYSTEM*].$SYS_CONFIG.$STARTMD FAILED', status, 0) --
     ConStartStat = cold_state -- force at cold_state
   ENDIF

IF UNINIT(ConStartStat) THEN --make sure code can run
  ConStartStat = Cold_State
ENDIF

IF UNINIT(StrtFrmWizrd) THEN
  StrtFrmWizrd = FALSE
ENDIF

-- Forcing the menu is not needed when using custom menu and $option set to 31 for TYPE function
SELECT (ConStartStat) OF --
CASE (Contr_State):  -- 1 = at Controlled Start Status
  FORCE_SPMENU(tp_panel,SPI_TPUSER2,1) -- force the user screen to display forms
CASE (Cold_State):  -- 2 = at cold state no need to force if system is handling
  ---- Need to force menu if Ran from Wizard
  IF StrtFrmWizrd THEN
    FORCE_SPMENU(tp_panel,SPI_TPUSER2,1) -- force the user screen to display forms
  ENDIF
ELSE: --
  POST_ERR(38000, 'Unknown ConStartStat in GMPTDATA', 0, 0) --
ENDSELECT --


IF UNINIT(form_number) THEN
  form_number = 1
ENDIF
  all_done = FALSE-- set the loop flag
 --unlocked = FALSE
 WHILE NOT (all_done) DO -- do diplay until they say stop
   SELECT (form_number) OF --
      CASE (1):  --
        setup_data -- this is for the initial setting
      CASE (2):  --
      ELSE: --
   ENDSELECT --
 ENDWHILE --

  StrtFrmWizrd = FALSE

END GMPNCDTA
